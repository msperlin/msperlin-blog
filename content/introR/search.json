[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução ao R",
    "section": "",
    "text": "Prefácio\nEm 2017 publiquei o meu primeiro livro sobre R, “Análise de Dados Financeiros e Econômicos com o R”. Com a introdução de diferentes revisões ao longo dos anos, logo percebi que seria desejável ter diversos livros focados dos capítulos, ao invés de uma única obra no tema. Este é o primeiro livro da série, apresentando um introdução completa sobre o uso do R e RStudio.\nSou professor da Universidade Federal do Rio Grande do Sul, onde leciono disciplinas relacionadas ao uso do R em análise de dados. A experiência em sala de aula me proporcionou a experiência de ver, ao vivo, onde os alunos mais erram e qual o melhor caminho para aprender a usar o R. Este livro é um projeto pessoal e acadêmico para disseminar conhecimento para um público maior.\nOutra motivação que tive para escrever o livro foi minha experiência na utilização de códigos disponibilizados por outros pesquisadores. Na maioria das vezes, esses códigos são desorganizados, pouco claros e, possivelmente, funcionam apenas no computador do pesquisador que os escreveu! Assim como se espera que um artigo científico esteja bem escrito, também se deve esperar que o código por trás da respectiva pesquisa seja de qualidade. Porém, esse não é o caso na grande maioria das vezes. Com este livro, irei atacar esse problema, formalizando uma estrutura de código voltada à reprodutibilidade científica, focando em organização e usabilidade. Nesse sentido, espero que as futuras gerações de pesquisadores estejam mais bem preparadas para compartilhar o seu trabalho.\nAntes de prosseguir, um aviso. Não iremos trabalhar usos avançados do R. O conteúdo será limitado a exemplos simples e práticos de utilização do software para a construção de pesquisa baseada em dados financeiros e econômicos. De fato, um dos desafios na escrita deste livro foi definir o limite entre o material introdutório e o avançado. Procurei, sempre que possível, dosar gradualmente o nível de complexidade. Para leitores interessados em conhecer funções avançadas do programa e o seu funcionamento interno, sugiro a leitura do manual oficial do R (Teetor 2011) e de Wickham (2019).\nCom este livro irás aprender os seguinte tópicos:",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "index.html#como-ler-este-livro",
    "href": "index.html#como-ler-este-livro",
    "title": "Introdução ao R",
    "section": "Como ler este livro",
    "text": "Como ler este livro\nEste livro tem uma abordagem prática no uso do R e será acompanhado por uma série de códigos que irão exemplificar e mostrar para o leitor as funcionalidades do programa. Para tirar o máximo de proveito do material, sugiro que você primeiro busque entender o código mostrado e, somente então, tente utilizá-lo em seu próprio computador. O índice remissivo disponibilizado no final do livro impresso serve como uma mapa de uso das funções. Toda vez que uma função é chamada no livro, um registro do número da página é criado no índice remissivo. Esse indica, também, o pacote que a função pertence. Podes utilizar este mapa para localizar o uso de qualquer função ou pacote no decorrer do livro. Sugiro também o uso da versão online do livro no site https://www.msperlin.com/introR/, a qual permite que os código de exemplo sejam copiados direto para a sua sessão do R. Assim, perderás menos tempo digitando código.\nAprender a programar em uma nova linguagem é como aprender uma língua estrangeira: o uso no dia-a-dia é de extrema importância para criar fluência. Sempre que possível, teste o código no seu computador e brinque com o mesmo, modificando os exemplos e verificando o efeito das modificações nas saídas do programa. Procure sempre entender como a rotina estudada pode ajudar na solução de um problema seu. Cada capítulo apresenta no seu final uma lista de exercícios. Podes testar as suas habilidades de programação resolvendo as atividades propostas.\n\nCódigos no livro\nNo decorrer da obra, toda demonstração de código terá duas partes: o código em si e sua saída do R. Essa saída nada mais é do que o resultado dos comandos na tela do programa. Todas as entradas e saídas de código serão sinalizadas no texto com um formato especial. Veja o exemplo a seguir:\n\n# create a list\nL &lt;- list(var1 = 'abc', var2 = 1:5)\n\n# print to prompt\nprint(L)\n\nR&gt; $var1\nR&gt; [1] \"abc\"\nR&gt; \nR&gt; $var2\nR&gt; [1] 1 2 3 4 5\n\n\nNo caso anterior, os textos L &lt;- list(var1 = 'abc', var2 = 1:5) e print(L) são os códigos de entrada. A saída do programa é a apresentação na tela dos elementos de x, com o símbolo antecessor R&gt;. Por enquanto não se preocupe em entender e reproduzir o código utilizado acima. Iremos tratar disso no próximo capítulo.\nNote que faço uso da língua inglesa no código, tanto para a nomeação de objetos quanto para os comentários. Isso não é acidental. O uso da língua inglesa facilita o desenvolvimento de código ao evitar caracteres latinos, além de ser uma das línguas mais utilizadas no mundo. Portanto, é importante já ir se acostumando com esse formato. O vocabulário necessário, porém, é limitado. De forma alguma precisarás ter fluência em inglês para entender o código.\nO código também pode ser espacialmente organizado usando novas linhas. Esse é um procedimento comum em torno de argumentos de funções. O próximo pedaço de código é equivalente ao anterior, e executará exatamente da mesma maneira. Observe como usei uma nova linha para alinhar verticalmente os argumentos da função list. Você verá em breve que, ao longo do livro, esse tipo de alinhamento vertical é constantemente usado em códigos longos. Afinal, o código tem que necessariamente caber na página do livro impresso.\n\n# create a list\nL &lt;- list(var1 = 'abc',\n          var2 = 1:5)\n\n# print to prompt\nprint(L)\n\nR&gt; $var1\nR&gt; [1] \"abc\"\nR&gt; \nR&gt; $var2\nR&gt; [1] 1 2 3 4 5\n\n\nO código também segue uma estrutura bem definida. Uma das decisões a ser feita na escrita de códigos de computação é a forma de nomear os objetos e como lidar com a estrutura do texto do código em geral. É recomendável seguir um padrão limpo de código, de forma que o mesmo seja fácil de ser mantido ao longo do tempo e de ser entendido por outros usuários. Para este livro, foi utilizado uma mistura entre escolhas pessoais e o estilo de código sugerido pelo Google. O usuário, porém, é livre para escolher a estrutura que achar mais eficiente, desde que seja coerente.",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "index.html#animações-de-código",
    "href": "index.html#animações-de-código",
    "title": "Introdução ao R",
    "section": "Animações de código",
    "text": "Animações de código\nEsta edição do livro inclui animações de código no formato gif, as quais devem ajudar a memorizar e visualizar as diferentes operações na plataforma. Para os leitores do livro impresso, obviamente não existe maneira de incluir animações em papel. Como alternativa, cada animação inclui um QRCode que irá direcionar o leitor para página na web com a animação em questão. A imagem a esquerda é a primeira tela de cada animação. Veja o exemplo abaixo na Figure Exemplo de animação:\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1: Exemplo de animação\n\n\n\n\n\nPara utilizar, abra seu celular e aponte a câmera para o QRCode da página. Após isso, basta clicar no link que aparecer na tela do aparelho. O resultado deve ser uma animação em uma página na internet.",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "index.html#material-suplementar",
    "href": "index.html#material-suplementar",
    "title": "Introdução ao R",
    "section": "Material suplementar",
    "text": "Material suplementar\nTodo o material usado no livro está publicamente disponível na Internet e distribuído com um pacote R denominado introR. Este inclui arquivos de dados, e algumas funções que irão facilitar a execução dos exemplos do livro. Se você planeja, como sugerido, escrever código enquanto lê o livro, este pacote ajudará muito em sua jornada.\nPara instalar este pacote no seu computador, basta executar algumas linhas de comando no R. Veja o código destacado a seguir e copie e cole o mesmo no prompt do RStudio (canto inferior esquerdo da tela, com um sinal “&gt;”) e pressione Enter para cada comando. Esteja ciente de que você precisará do R e RStudio instalados em seu computador (consulte 1.4 Como Instalar o R).\n\n# install devtools dependency\ninstall.packages('devtools')\n\n# install book package\ndevtools::install_github('msperlin/introR')\n\nO que este código fará é instalar o pacote devtools, uma dependência necessária para instalar código do Github – um repositório de pacotes onde o livro está hospedado. Depois disso, uma chamada para devtools::install_github('msperlin/introR') irá instalar o pacote em seu computador. Depois da instalação, todos os arquivos do livro estarão disponíveis localmente, salvos em uma pasta do seu computador.\nOpcionalmente, caso quiser olhar os arquivos de dados disponíveis no pacote, basta chamar a seguinte linha de código no prompt do R:\n\nintroR::data_list()\n\nR&gt; \n\n\nR&gt; ── Available data files at '/home/msperlin/R/x86_64-pc-linux\n\n\nR&gt; ℹ CH04_another-funky-csv-file.csv\n\n\nR&gt; ℹ CH04_example-fst.fst\n\n\nR&gt; ℹ CH04_example-Rdata.RData\n\n\nR&gt; ℹ CH04_example-rds.rds\n\n\nR&gt; ℹ CH04_example-sqlite.SQLite\n\n\nR&gt; ℹ CH04_example-tsv.tsv\n\n\nR&gt; ℹ CH04_funky-csv-file.csv\n\n\nR&gt; ℹ CH04_ibovespa-Excel.xlsx\n\n\nR&gt; ℹ CH04_ibovespa.csv\n\n\nR&gt; ℹ CH04_price-and-prejudice.txt\n\n\nR&gt; ℹ CH04_SP500-Excel.xlsx\n\n\nR&gt; ℹ CH04_SP500.csv\n\n\nR&gt; ℹ CH07_FileWithLatinChar_Latin1.txt\n\n\nR&gt; ℹ CH07_FileWithLatinChar_UTF-8.txt\n\n\nR&gt; ℹ CH08_some-stocks-SP500.csv\n\n\nR&gt; ℹ CH08_wide-example-stocks.csv\n\n\nR&gt; ℹ CH10_sp500-stocks-long-by-year.csv\n\n\nR&gt; ℹ CH11_grunfeld.csv\n\n\nR&gt; ℹ CH11_SP500.csv\n\n\nR&gt; ℹ CH11_UCI-Credit-Card.csv\n\n\nR&gt; ℹ EX_B3-stocks.rds\n\n\nR&gt; ℹ EX_football-br.csv\n\n\nR&gt; ℹ EX_Ibov_PETR4.csv\n\n\nR&gt; ℹ EX_ibovespa.rds\n\n\nR&gt; ℹ EX_SP500-stocks-wide.csv\n\n\nR&gt; ℹ EX_SP500-stocks-yearly.rds\n\n\nR&gt; ℹ EX_SP500-stocks.rds\n\n\nR&gt; ℹ EX_TD-data.rds\n\n\nR&gt; ℹ EX_TweetsElonMusk.csv\n\n\nR&gt; \n\n\nR&gt; ✔ You can get the local path of file using introR::data_path(name_of_file)\n\n\nR&gt; ✔ Example: local_path &lt;- introR::data_path('CH04_price-and-prejudice.txt')",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "index.html#conteúdo-para-instrutores",
    "href": "index.html#conteúdo-para-instrutores",
    "title": "Introdução ao R",
    "section": "Conteúdo para instrutores",
    "text": "Conteúdo para instrutores\nSe você for um instrutor de R, aqui encontrarás bastante material para usar em suas aulas:\n\nExercícios estáticos na internet\n\nCada capítulo deste livro inclui exercícios que seus alunos podem praticar. Todas as soluções estão disponíveis na versão online do livro, disponível em https://www.msperlin.com/introR/.\n\nExercícios exportáveis para pdf ou plataformas de e-learning\n\nTodos exercícios do livro estão no formato do pacote {exams} (Zeileis et al. 2022) e são exportáveis para arquivos em pdf ou então para plataformas de e-learning tal como o Moodle ou Blackboard. Isso significa que podes usar os mesmos exercícios para criar provas e atividades que são automaticamente corrigidas pela plataforma de e-learning. Veja este post no blog para maiores detalhes.\n\nAcesso ao livro na internet\n\nExiste uma versão online e gratuita do livro, disponível em https://www.msperlin.com/introR/ &gt;. Seu alunos, mesmo aqueles que não compraram o livro, terão acesso ao material do próprio celular.\n\n\nEspero que goste deste livro. Este é um projeto pessoal e especial, sendo compilado desde 2017 a base de muito suor e, literalmente, litros de café.\nBoa leitura!\nMarcelo S. Perlin",
    "crumbs": [
      "Prefácio"
    ]
  },
  {
    "objectID": "01-introdução.html",
    "href": "01-introdução.html",
    "title": "1  Introdução",
    "section": "",
    "text": "1.1 O que é o R\nO R é uma linguagem de programação criada em 1993, e voltada para a resolução de problemas estatísticos e visualização gráfica de dados. O código base do R foi inspirado na linguagem S, inicialmente criada no laboratório da Bell/AT&T por John Chambers e seus colegas. A ideia de criar uma linguagem de programação voltada a estatística foi redesenhada por dois acadêmicos, Ross Ihaka e Robert Gentleman, ambos da universidade de Auckland, Nova Zelândia.\nHoje, R é sinônimo de programação voltada à análise de dados, com uma larga base de usuários acadêmicos e da indústria. É muito provável que analistas de áreas diversas, desde Economia até Biologia, ou mesmo Música, encontrem no R uma quantidade significativa de códigos que facilitem suas análises. No campo empresarial, grandes empresas como Google e Microsoft já adotaram o R como a linguagem interna para a análise de dados. O R é atualmente mantido pelo R Foundation e o R Consortium, um esforço coletivo para financiar projetos de extensão da linguagem.\nE o mais importante: o R é totalmente livre e disponível em vários sistemas operacionais. Seja você um usuário do Windows, do Linux/Unix ou do MacOS, existe uma instalação do R para a sua plataforma, e os seus códigos devem rodar entre uma e outra com mínimas alterações.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "01-introdução.html#o-que-é-o-r",
    "href": "01-introdução.html#o-que-é-o-r",
    "title": "1  Introdução",
    "section": "",
    "text": "Qual a origem do nome R?\n\n\n\nO que pode ser dito como um ato pouco criativo, os desenvolvedores escolheram a letra R pois era a primeira letra de seus primeiros nomes, Ross e Robert. Possivelmente, foi uma brincadeira com a linguagem S, a qual serviu de inspiração para o R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "01-introdução.html#por-que-escolher-o-r",
    "href": "01-introdução.html#por-que-escolher-o-r",
    "title": "1  Introdução",
    "section": "1.2 Por que Escolher o R",
    "text": "1.2 Por que Escolher o R\nPossivelmente você esteja se perguntando por que deve optar pelo R e investir tempo em sua aprendizagem, ao invés de escolher uma outra linguagem.\nEm primeiro lugar, o R é uma plataforma madura, estável, continuamente suportada e intensamente utilizada na indústria. Ao escolher o R, você terá a bagagem computacional necessária não somente para uma carreira acadêmica em pesquisa científica, mas também para o trabalho em organizações privadas. Nesse sentido, com a escolha de outra linguagem de programação menos popular ou proprietária/comercial, é provável que tal linguagem não seja utilizada em um ambiente empresarial e isso pode limitar as suas futuras oportunidades profissionais. Sem dúvida, o conhecimento de programação em um plataforma aberta de análise de dados aumenta a sua atratividade como profissional.\nAprender a linguagem do R é fácil. A experiência que tenho ensinando o R em sala de aula me permite afirmar que os alunos, mesmo aqueles sem experiência em programação, apresentam facilidade em aprender a linguagem e em utilizá-la para criar seus próprios códigos de pesquisa. A linguagem é intuitiva e certas normas e funções podem ser estendidas para diferentes casos. Após entender como o programa funciona, fica fácil descobrir novas funcionalidades partindo de uma lógica anterior. Essa notação compartilhada entre procedimentos facilita o aprendizado.\nA interface do R e RStudio torna o uso da ferramenta bastante produtivo. A interface gráfica aberta e gratuita disponibilizada pela RStudio/Posit facilita o uso do software, assim como a produtividade do usuário. Utilizando o ambiente de trabalho integrado do R e o RStudio, têm-se a disposição diversas ferramentas que facilitam e estendem o uso da plataforma.\nOs pacotes do R permitem as mais diversas funcionalidades. Logo veremos que o R permite o uso de código de outros usuários, os quais podem ser localmente instalados através de um simples comando. Esses estendem a linguagem básica do R e possibilitam as mais diversas funcionalidades. Além das funções óbvias de analisar dados, podes utilizar o R para mandar emails, escrever e publicar um livro, contar piadas e poemas (é sério!), utilizar o chat GPT para responder perguntas, acessar e coletar dados da internet, entre diversas outras funcionalidades.\nO R tem compatibilidade com diferentes linguagens e sistemas operacionais. Se, por algum motivo, o usuário precisar utilizar código de outra linguagem de programação tal como C++, Python, Julia, é fácil integrar a mesma dentro de um programa do R. Diversos pacotes estão disponíveis para facilitar esse processo. Portanto, o usuário nunca fica restrito a uma única linguagem e tem flexibilidade para escolher as suas ferramentas de trabalho.\nO R é totalmente gratuito! O programa e todos os seus pacotes são completamente livres, não tendo custo algum de licença e distribuição. Portanto, você pode utilizá-lo e modificá-lo livremente no seu trabalho ou computador pessoal. Essa é uma razão muito forte para a adoção da linguagem em um ambiente empresarial, onde a obtenção de licenças individuais e coletivas de outros softwares comerciais pode incidir um alto custo financeiro.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "01-introdução.html#usos-do-r",
    "href": "01-introdução.html#usos-do-r",
    "title": "1  Introdução",
    "section": "1.3 Usos do R",
    "text": "1.3 Usos do R\nO R é uma linguagem de programação completa e qualquer problema computacional relacionado a dados pode ser resolvido com base nela. Dada a adoção do R por diferentes áreas de conhecimento, a lista de possibilidades é extensa. Para o caso de Finanças e Economia, destaco abaixo as possíveis utilizações do programa:\n\nSubstituir e melhorar tarefas intensivas e repetitivas dentro de ambientes corporativos, geralmente realizadas em planilhas eletrônicas;\nCriação de relatórios estruturados periódicos com a tecnologia RMarkdown e quarto. Podes, por exemplo, criar um relatório automatizado que importe dados brutos e analise um conjunte de dados de vendas no mês.\nDesenvolvimento de rotinas para administrar portfolios de investimentos e executar ordens financeiras;\nCriação de ferramentas para controle, avaliação e divulgação de índices econômicos sobre um país ou região;\nExecução de diversas possibilidades de pesquisa científica através da estimação de modelos econométricos e testes de hipóteses;\nCriação e manutenção de websites dinâmicos ou estáticos através do pacotes shiny, blogdown ou distill;\n\nAlém dos usos destacados anteriormente, o acesso público a pacotes desenvolvidos por usuários expande ainda mais essas funcionalidades. O site do CRAN (Comprehensive R Archive Network) oferece um painel com uma lista de pacotes separadas por temas, incluindo Finanças e Econometria.\n\n\n\n\n\n\nEncontrando pacotes para determinada área\n\n\n\nA página do task views, localizada em https://cran.r-project.org/web/views é um ótimo lugar para estudar pacotes e buscar soluções para um problema específico. Lá encontrarás os pacotes separados por tema e subtema específico, assim como também uma breve descrição. Porém, saiba que a lista é moderada com baixa frequência de atualização, e apresenta apenas os principais itens. A lista completa de pacotes é muito maior do que o apresentado no Task Views.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "01-introdução.html#sec-instalacao",
    "href": "01-introdução.html#sec-instalacao",
    "title": "1  Introdução",
    "section": "1.4 Como Instalar o R",
    "text": "1.4 Como Instalar o R\nO R é instalado no seu sistema operacional como qualquer outro programa. A maneira mais direta e funcional de instalá-lo é ir ao website do R em https://www.r-project.org/ e clicar no link CRAN do painel Download, conforme mostrado na animação em Figure 1.1.\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 1.1: Instalando o R no Windows\n\n\n\n\n\nResumindo, os passos para a instalação do R no Windows são:\n\nApós clicar em Download-CRAN, a próxima tela apresenta a escolha do espelho para baixar os arquivos de instalação. O repositório do CRAN é espelhado em diversas partes do mundo, permitindo acesso rápido para os usuários. Para a grande maioria dos leitores deste livro, essa localidade deve ser o Brasil. Portanto, você pode escolher um dos links da instituição mais próxima, tal como o da UFPR (Universidade Federal do Paraná). Em caso de dúvida, escolha o repositório do RStudio 0-Cloud, o qual automaticamente direciona para o local mais próximo.\nO próximo passo é selecionar o sistema operacional do computador. Devido à maior popularidade da plataforma Windows, a partir de agora daremos enfoque à instalação do R nesse sistema. As instruções de instalação nos demais sistemas operacionais podem ser facilmente encontradas na internet. Destaca-se que, independente da plataforma, o modo de uso do R é o mesmo. Existem, porém, algumas exceções, principalmente quando o R interage com o sistema de arquivos.\nApós clicar no link Download R for Windows, a próxima tela irá mostrar as seguintes opções de download: base, contrib, old.contrib e RTools. Dentre as opções de download, a primeira (base) deve ser selecionada. O link acessa a instalação básica do R para Windows. O link contrib e old.contrib acessa os arquivos dos pacotes/módulos disponíveis para o R. Não precisas acessar estes últimos links, existe uma maneira muito mais fácil de baixar e instalar pacotes, como veremos em seguida. O último link, RTools, serve para instalar dependências necessárias para compilar dependências em outras linguagens de programação. Minha sugestão é que já instale o Rtools pois, a medida que for instalando novos pacotes, o mesmo se tornará parte essencial no uso do R.\nApós clicar no link base, a próxima tela mostrará o link para o download do arquivo de instalação do R no Windows. Após baixar o arquivo, abra-o e siga os passos da tela de instalação do R. Escolha a língua inglesa em todas etapas do processo. O uso da língua inglesa não é acidental. Este é a melhor forma, mesmo para iniciantes, de se aprender a usar o R. É possível instalar uma versão em português porém isso limita o potencial da ferramenta. Caso não for fluente em inglês, não se preocupe, o vocabulário necessário é básico. Neste momento, nenhuma outra configuração especial é necessária. Sugiro manter todas as escolhas padrão selecionadas e simplesmente ir aceitando as telas de diálogo. Após a instalação do R, partimos para a instalação do RStudio.\n\n\nR_ver &lt;- R.version\n\nmajor &lt;- R_ver$major\nminor &lt;- R_ver$minor\n\nR_version_str &lt;- paste0(major, \".\", minor)\n\n\n\n\n\n\n\nImportante\n\n\n\nA cada quatro meses uma nova versão do R é lançada, corrigindo bugs e implementando novas soluções. Temos dois tipos principais de versões, major e minor. Por exemplo, na data de compilação do livro, 07/04/2024, a última versão disponível do R é 4.3.3. O primeiro dígito (4) indica a versão major e todos os demais são do tipo minor. Geralmente, as mudanças minor são bem específicas e, possivelmente, terão pouco impacto no seu trabalho.\nPorém, mudanças do tipo major refletem totalmente no ecossistema de pacotes do R. Toda vez que instalar uma nova versão major do R, o diretório onde os pacotes são instalados é renovado, isto é, terás que reinstalar todos os pacotes utilizados no seu trabalho. O problema é que não é incomum problemas de incompatibilidade de pacotes com a nova versão.\nMinha dica é: toda vez que uma nova versão major do R sair, espere algumas semanas ou até um mês antes de instalar na sua máquina. Assim, o autores dos pacotes terão mais tempo para atualizar os seus códigos, minimizando a possibilidade de problemas de compatibilidade.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "01-introdução.html#instalando-o-rstudio",
    "href": "01-introdução.html#instalando-o-rstudio",
    "title": "1  Introdução",
    "section": "1.5 Instalando o RStudio",
    "text": "1.5 Instalando o RStudio\nA instalação do R inclui a sua própria interface gráfica, um programa que facilita a edição e execução de nossos scripts. Essa, porém, possui várias limitações. O RStudio é um software que torna o uso e o visual do R muito mais prático e eficiente. Uma forma de entender essa relação é com uma analogia com carros. Enquanto o R é o motor da linguagem de programação, o RStudio é a carroceria e o painel de instrumentos. Além de apresentar um visual mais atrativo, o RStudio também é acrescido de várias funcionalidades que facilitam a vida do usuário, possibilitando a construção de projetos e pacotes do próprio R, a criação de documentos dinâmicos (rmarkdown/quarto) e a interface com edição de textos em LaTeX, entre várias outras. Assim como o R, o RStudio também é gratuito e pode ser utilizado no ambiente empresarial.\nA instalação do RStudio é mais simples do que a do R. Os arquivos estão disponíveis no endereço disponibilizado no site da empresa Posit. Após acessar a página, clique em Download RStudio e depois em Download Rstudio Desktop. Logo após, basta selecionar o arquivo relativo ao sistema operacional em que você irá trabalhar. Provavelmente, essa opção será Windows Vista/7/8/10. Note que, assim como o R, o RStudio também está disponível para diferentes plataformas.\nDestaco que o uso do RStudio não é essencial para desenvolver programas no R. Outros softwares de interface estão disponíveis e podem ser utilizados. Porém, dada minha experiência atual, o RStudio é o programa de interface que oferece a maior variedade de funcionalidades para essa linguagem, além de ser amplamente utilizado, o que justifica a sua escolha. Como uma alternativa ao RStudio, sugiro o vscode, o qual possui uma ótima integração com o R (veja quadro a seguir).\n\n\n\n\n\n\nSobre o Vscode\n\n\n\nO vscode é um editor de código multi-plataforma, com suporte para praticamente todas as linguagens de programação, incluindo R. O grande benefício é flexibilidade e customização, além da possibilidade de usar a mesma interface para diferentes linguagens. Como exemplo, o conteúdo inteiro do livro foi escrito e editado no vscode, com ótimas ferramentas de gramática e organização do texto. Porém, minha principal escolha de interface para qualquer projeto de R é sempre o RStudio.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "01-introdução.html#recursos-na-internet",
    "href": "01-introdução.html#recursos-na-internet",
    "title": "1  Introdução",
    "section": "1.6 Recursos na Internet",
    "text": "1.6 Recursos na Internet\nA comunidade R é viva e envolvente. Na internet é possível encontrar uma diversidade de material sobre o uso do R. Diversos usuários, assim como o próprio autor do livro, publicam material sobre o uso R em seus blogs. Isso inclui anúncios de pacotes, publicações sobre análise de dados na vida real, curiosidades, novidades e tutoriais. R-Bloggers é um site internacional que agrega esses blogs em um único local, tornando mais fácil para qualquer um acessar e participar. O conteúdo do R-Bloggers, porém, é todo em inglês.\nRecentemente, uma lista de blogs locais sobre o R está compilada e organizada por Marcos Vital no Github. Eu recomendo a inscrição no feed do R-Bloggers, além dos blogs nacionais. Não só você será informado sobre o que está acontecendo no universo do R, mas também aprenderá muito lendo artigos e os códigos de outros usuários.\nAprender e usar R pode ser uma experiência social. Várias conferências e grupos de usuários estão disponíveis em muitos países, incluindo o Brasil. O grupo R Brasil - Programadores no Facebook é bastante ativo, com um grande número de participantes. Recomendo fortemente a inscrição neste grupo e o acompanhamento das discussões relacionadas ao uso do R. Diversas conferências locais sobre o R são divulgadas nesse grupo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "01-introdução.html#exercícios",
    "href": "01-introdução.html#exercícios",
    "title": "1  Introdução",
    "section": "1.7 Exercícios",
    "text": "1.7 Exercícios\n\nQ.1 - A primeira versão do R foi desenvolvida com base em qual outra linguagem de programação?\n\nC++\nS\nJavascript\nPython\nJulia\n\n\nQ.2 - Qual o nome dos autores da primeira versão do R?\n\nLinus Torvalds e Richard Stallman\nJohn Chambers e Robert Engle\nRoger Federer e Rafael Nadal\nGuido van Rossum e Bjarne Stroustrup\nRoss Ihaka e Robert Gentleman\n\n\nQ.3 - Qual o principal diferencial do R em relação a outras linguagens de programação, tal como Python, C++, javascript e demais?\n\nFacilidade para a análise estatística de dados\nExecução rápida de códigos\nFacilita o desenvolvimento de aplicativos web\nFacilita o desenvolvimento de aplicativos para celular\nFacilidade de uso, em geral\n\n\nQ.4 - Qual a razão para o nome da linguagem de programação ser R?\n\nCompartilhamento da letra R por seus autores.\nR = Reausable code.\nEra a única letra ainda não usada como linguagem de programação.\nA mãe de um dos autores se chamada Renata e, por isso, ele homenageou-a com o nome R.\nUma letra foi sorteada na própria linguagem de programação, e o resultado foi R.\n\n\nQ.5 - Sobre o R, considere as seguintes alternativas:\nI - O R é uma plataforma de programação madura e estável;\nII - O RStudio é uma linguagem de programação alternativa ao R;\nIII - O R não tem compatibilidade com diferentes linguagens de programação;\nQuais alternativas estão corretas?\n\nTRUE, TRUE, FALSE\nTRUE, FALSE, FALSE\nTRUE, FALSE, TRUE\nFALSE, FALSE, FALSE\nTRUE, TRUE, TRUE\n\n\nQ.6 - Assim que tiver R e RStudio instalado, dirija-se ao site de pacotes do CRAN1 e procure por tecnologias que usas no seu trabalho. Por exemplo, se usas Planilhas do Google (Sheets)2 ostensivamente no seu trabalho, logo descobrirá que existe um pacote no CRAN que interage com planilhas do Google na nuvem.\n\nQ.7 - No site de instalação do R no Windows é possível instalar também o aplicativo Rtools. Para que ele serve?\n\nCompilar relatórios técnicos\nCriar gráficos\nConstruir páginas na web\nFazer café (?)\nCompilação de pacotes do R no Windows\n\n\nQ.8 - Use o Google para pesquisar por grupos de R em sua região. Verifique se os encontros são frequentes e, caso não tiver um impedimento maior, vá para um desses encontros e faça novos amigos.\n\nQ.9 - Dirija-se ao site do RBloggers3 e procure por um tópico do seu interesse, tal como futebol (soccer) ou investimentos (investments). Leia pelo menos três artigos encontrados.\n\nQ.10 - Caso trabalhe em uma instituição com infraestrutura de computação, converse com o encarregado e busque entender quais são as tecnologias empregadas. Verifique se, através do R, é possível ter acesso a todas tabelas dos bancos de dados. Por enquanto não existe necessidade de escrever código, ainda. Apenas verifique se esta possibilidade existe.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "01-introdução.html#footnotes",
    "href": "01-introdução.html#footnotes",
    "title": "1  Introdução",
    "section": "",
    "text": "https://cloud.r-project.org/web/packages/available_packages_by_date.html↩︎\nhttps://www.google.com/sheets/about/↩︎\nhttps://www.r-bloggers.com/↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "02-primeiros-passos-rstudio.html",
    "href": "02-primeiros-passos-rstudio.html",
    "title": "2  Primeiros Passos com o RStudio",
    "section": "",
    "text": "2.1 Executando Códigos em um Script\nAgora, vamos juntar todos os códigos digitados anteriormente e colar na tela do editor (lado esquerdo superior), assim como mostrado a seguir:\n# set objects\nx &lt;- 1\ny &lt;- 'my text'\n\n# print it\nprint(x)\nprint(1:50)\nApós colar todos os comandos no editor, salve o arquivo .R em alguma pasta pessoal. Esse arquivo, o qual no momento não faz nada de especial, registrou os passos de um algoritmo simples que cria dois objetos e mostra os seus valores. Futuramente, o seu script tomará uma forma mais complexa, com a importação de dados, manipulação e modelagem dos mesmos e saída de tabelas e figuras.\nNo RStudio existem alguns atalhos predefinidos para executar códigos que economizam bastante tempo. Para executar um script inteiro, basta apertar control + shift + s. Esse é o comando source. Com o RStudio aberto, sugiro testar essa combinação de teclas e verificar como o código digitado anteriormente é executado, mostrando os valores no prompt do R. Visualmente, o resultado deve ser próximo ao apresentado na Figure 2.3.\nFigure 2.3: Exemplo de Rotina no R\nOutro comando muito útil é a execução de código linha por linha (atalho control+enter). Neste caso, não é executado todo o arquivo, mas somente a linha em que o cursor do mouse se encontra. Este atalho é bastante útil no desenvolvimento de rotinas pois permite que cada linha seja testada antes de executar o programa inteiro. Como um exemplo de uso, aponte o cursor para a linha print(x) e pressione control + enter. Verás que o valor de x é mostrado na tela do prompt. A seguir destaco outros atalhos do RStudio, os quais também podem ser muito úteis.\nSugere-se que esses atalhos sejam memorizados e utilizados. Isso facilita bastante o uso do programa. Para aqueles que gostam de utilizar o mouse, uma maneira alternativa para rodar o código do script é apertar o botão source, localizado no canto direito superior do editor de rotinas. Isto é equivalente ao atalho control+shift+s.\nComo podemos ver, existem diversas maneiras de executar uma rotina de pesquisa. Na prática, porém, iras centralizar o uso em dois comandos apenas: control+shift+enter para rodar o script inteiro e control+enter para rodar por linha.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros Passos com o RStudio</span>"
    ]
  },
  {
    "objectID": "02-primeiros-passos-rstudio.html#sec-execucao",
    "href": "02-primeiros-passos-rstudio.html#sec-execucao",
    "title": "2  Primeiros Passos com o RStudio",
    "section": "",
    "text": "control+shift+s executa o arquivo atual do RStudio, sem mostrar comandos no prompt (sem “eco” do código – somente saída dos comandos);\ncontrol+shift+enter: executa o arquivo atual, mostrando comandos na tela (com “eco” e saída do código);\ncontrol+enter: executa a linha selecionada, mostrando comandos na tela;\ncontrol+shift+b: executa os códigos do início do arquivo até a linha atual onde o cursor se encontra;\ncontrol+shift+e: executa os códigos da linha onde o cursor se encontra até o final do arquivo.\n\n\n\n\n\n\n\n\n\nUtilizando vários scripts\n\n\n\nÉ muito comum que um código de pesquisa seja dividido em diversos scrips do R. Isso organiza o trabalho, dividindo o trabalho total em etapas separadas. Assim, podemos ter um script principal, responsável por rodar os demais.\nNeste caso, para executar os scripts em sequência, basta chamá-los no script principal com o comando source() , como no código a seguir:\n\n# Import all data\nsource('01-import-data.R')\n\n# Clean up\nsource('02-clean-data.R')\n\n# Build tables\nsource('03-build-table.R')\n\nO código anterior é equivalente a abrirmos e executarmos (control + shift + s) cada um dos scripts sequencialmente.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros Passos com o RStudio</span>"
    ]
  },
  {
    "objectID": "02-primeiros-passos-rstudio.html#tipos-de-arquivos",
    "href": "02-primeiros-passos-rstudio.html#tipos-de-arquivos",
    "title": "2  Primeiros Passos com o RStudio",
    "section": "2.2 Tipos de Arquivos",
    "text": "2.2 Tipos de Arquivos\nAssim como outros programas, o R e o RStudio possuem um ecossistema de arquivos e cada extensão tem uma finalidade diferente. A seguir apresenta-se uma descrição de diversas extensões de arquivos exclusivos ao R e RStudio. Os itens da lista estão ordenados por ordem de importância e uso.\nArquivos com extensão .R: Representam arquivos texto contendo diversas instruções para o R. Esses são os arquivos que conterão o código da pesquisa e onde passaremos a maior parte do tempo. Também pode ser chamado de um script ou rotina de pesquisa. Como sugestão, pode-se dividir toda uma pesquisa em etapas e arquivos numerados. Exemplos: 01-Get-Data.R, 02-Clean-data.R, 03-Estimate-Models.R. Como curiosidade, o arquivo .R pode ser aberto por qualquer editor de texto, tal como o Notepad do Windows.\nArquivos com extensão .RData e .rds: armazenam dados nativos do R. Esses arquivos servem para salvar (ou congelar) objetos do R em um arquivo no disco rígido do computador para, em sessão futura, serem novamente carregados. Por exemplo, podes guardar o resultado de uma pesquisa em uma tabela, a qual é salva em um arquivo com extensão .RData ou .rds. Exemplos: Raw-Data.RData, Table-Results.rds.\nArquivos com extensão .Rmd e .qmd: São arquivos relacionados a tecnologia Rmarkdown e Quarto. O uso desses arquivos permite a criação de documentos onde texto e código são integrados.\nArquivos com extensão .Rproj: Contém informações para a edição de projetos no RStudio. O sistema de projetos do RStudio permite a configuração customizada do projeto e também facilita a utilização de ferramentas de controle de código, tal como controle de versões. O seu uso, porém, não é essencial. Para aqueles com interesse em conhecer esta funcionalidade, sugiro a leitura do manual do RStudio. Uma maneira simples de entender os tipos de projetos disponíveis é, no RStudio, clicar em File, New project, New Folder e assim deve aparecer uma tela com todos os tipos possíveis de projetos no RStudio. Exemplo: My-Dissertation-Project.Rproj.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros Passos com o RStudio</span>"
    ]
  },
  {
    "objectID": "02-primeiros-passos-rstudio.html#testando-código",
    "href": "02-primeiros-passos-rstudio.html#testando-código",
    "title": "2  Primeiros Passos com o RStudio",
    "section": "2.3 Testando Código",
    "text": "2.3 Testando Código\nO desenvolvimento de códigos em R segue um conjunto de etapas. Primeiro você escreverá uma nova linha de comando em uma rotina. Essa linha será testada com o atalho control + enter, verificando-se a ocorrência de erros e as saídas na tela. Caso não houver erro e o resultado for igual ao esperado, parte-se para a próxima linha de código.\nUm ciclo de trabalho fica claro, a escrita do código da linha atual é seguida pela execução, seguido da verificação de resultados, modificação caso necessário e assim por diante. Esse é um processo normal e esperado. Dado que uma rotina é lida e executada de cima para baixo, você precisa ter certeza de que cada linha de código está corretamente definida antes de passar para a próxima.\nQuando você está tentando encontrar um erro em um script preexistente, o R oferece algumas ferramentas para controlar e avaliar sua execução. Isso é especialmente útil quando você possui um código longo e complicado. A ferramenta de teste mais simples e fácil de utilizar que o RStudio oferece é o ponto de interrupção do código. No RStudio, você pode clicar no lado esquerdo do editor e aparecerá um círculo vermelho, como na Figure 2.4.\nO círculo vermelho indica um ponto de interrupção do código que forçará o R a pausar a execução nessa linha. Quando a execução atinge o ponto de interrupção, o prompt mudará para browser[1]&gt; e você poderá verificar o conteúdo dos objetos. No console, você tem a opção de continuar a execução para o próximo ponto de interrupção ou interrompê-la. O mesmo resultado pode ser alcançado usando a função browser() .\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.4: Depuração de Código\n\n\n\n\n\nO resultado prático do código da animação em Figure 2.4 é o mesmo que utilizar o círculo vermelho do RStudio, Figure 2.4. Porém, o uso do browser() permite mais controle sobre onde a execução deve ser pausada. Para sair do ambiente de depuramento (debug), aperte enter no prompt do RStudio ou clique no botão continue, localizado acima do prompt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros Passos com o RStudio</span>"
    ]
  },
  {
    "objectID": "02-primeiros-passos-rstudio.html#cancelando-a-execução-de-um-código",
    "href": "02-primeiros-passos-rstudio.html#cancelando-a-execução-de-um-código",
    "title": "2  Primeiros Passos com o RStudio",
    "section": "2.4 Cancelando a Execução de um Código",
    "text": "2.4 Cancelando a Execução de um Código\nToda vez que o R estiver executando algum código, uma sinalização visual no formato de um pequeno círculo vermelho no canto direito do prompt irá aparecer. Caso conseguir ler (o símbolo é pequeno em monitores modernos), o texto indica o termo stop. Esse símbolo não somente indica que o programa ainda está rodando mas também pode ser utilizado para cancelar a execução de um código. Para isso, basta clicar no referido botão. Outra maneira de cancelar uma execução é apontar o mouse no prompt e pressionar a tecla Esc no teclado (veja Figure 2.5).\nPara testar o cancelamento de código, copie e cole o código a seguir em um script do RStudio. Após salvar, rode o mesmo com control+shift+s.\n\nfor (i in 1:100) {\n  message('\\nRunning code (please make it stop by hitting esc!)')\n  Sys.sleep(1)\n}\n\nO código anterior usa um comando especial do tipo for para mostrar a mensagem a cada segundo. Neste caso, o código demorará 100 segundos para rodar. Caso não desejes esperar, aperte esc para cancelar a execução. Por enquanto, não se preocupe com as funções utilizadas no exemplo. Iremos discutir o uso do comando for na ?sec-programacao.\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.5: Parando a execução de um script",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros Passos com o RStudio</span>"
    ]
  },
  {
    "objectID": "02-primeiros-passos-rstudio.html#procurando-ajuda",
    "href": "02-primeiros-passos-rstudio.html#procurando-ajuda",
    "title": "2  Primeiros Passos com o RStudio",
    "section": "2.5 Procurando Ajuda",
    "text": "2.5 Procurando Ajuda\nUma tarefa muito comum no RStudio é procurar ajuda. O R possui milhares de funções, e memorizar os detalhes de uso de todas elas é uma tarefa quase impossível. Assim, até mesmo usuários avançados comumente procuram ajuda sobre tarefas específicas no programa, seja para entender detalhes sobre algumas funções ou estudar um novo procedimento.\nÉ possível buscar ajuda utilizando tanto o painel de help do RStudio como diretamente do prompt. Para isso, basta digitar o ponto de interrogação junto ao objeto sobre o qual se deseja ajuda, tal como em ?mean. Nesse caso, o objeto mean() é uma função e o uso do comando irá abrir o painel de ajuda sobre ela.\nNo R, toda tela de ajuda de uma função é igual, conforme se vê na Figure 2.6 apresentada a seguir. Esta mostra uma descrição da função mean() , seus argumentos de entrada explicados e também o seu objeto de saída. A tela de ajuda segue com referências e sugestões para outras funções relacionadas. Mais importante, os exemplos de uso da função aparecem por último e podem ser copiados e colados para acelerar o aprendizado no uso da função.\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.6: Usando o sistema de ajuda do RStudio\n\n\n\n\n\nCaso quiséssemos procurar um termo nos arquivos de ajuda, bastaria utilizar o comando ??\"standard deviation\". Essa operação irá procurar a ocorrência do termo em todos os pacotes do R e é muito útil para aprender como realizar alguma operação, nesse caso o cálculo de desvio padrão.\nComo sugestão, o ponto inicial e mais direto para aprender uma nova função é observando o seu exemplo de uso, localizada no final da página de ajuda. Com isto, podes verificar quais tipos de objetos de entrada a mesma aceita e qual o formato e o tipo de objeto na sua saída. Após isso, leia atentamente a tela de ajuda para entender se a mesma faz exatamente o que esperas e quais são as suas opções de uso nas respectivas entradas. Caso a função realizar o procedimento desejado, podes copiar e colar o exemplo de uso para o teu próprio script, ajustando onde for necessário.\n\n\n\n\n\n\nAtenção\n\n\n\nUm dos erros comuns de quem está iniciando a usar o R é usar funções sem entender exatamente o que as mesmas fazem! Note que sem confiança nas funções, perde-se toda a confiança nos resultados do script. Como regra, nunca assuma nada sobre as funções, por mais óbvia que possas achar. Leia exaustivamente a sua descrição no arquivo de ajuda e entenda o que a mesma faz. Muitas vezes é possível testar as funções para ver na prática se elas entregam o esperado. Se a descrição não é clara, entre em contato com o autor, ou então procure por alternativas mais transparentes.\n\n\nOutra fonte muito importante de ajuda é a própria internet. Sites como stackoverflow.com e mailing lists específicos do R, cujo conteúdo também está na internet, são fontes preciosas de informação. Havendo alguma dúvida que não foi possível solucionar via leitura dos arquivos de ajuda do R, vale o esforço de procurar uma solução via mecanismo de busca na internet. Em muitas situações, o seu problema, por mais específico que seja, já ocorreu e já foi solucionado por outros usuários.\nCaso estiver recebendo uma mensagem de erro enigmática, outra dica é copiar e colar a mesma para uma pesquisa no Google. Aqui apresenta-se outro benefício do uso da língua inglesa. É mais provável que encontres a solução se o erro for escrito em inglês, dado o maior número de usuários na comunidade global. Caso não encontrar uma solução desta forma, podes inserir uma pergunta no stackoverflow ou no grupo Brasileiro do R no Facebook.\n\n\n\n\n\n\nCuidado\n\n\n\nToda vez que for pedir ajuda na internet, procure sempre 1) descrever claramente o seu problema e 2) adicionar um código reproduzível do seu problema. Assim, o leitor pode facilmente verificar o que está acontecendo ao rodar o exemplo no seu computador. Não tenho dúvida que, se respeitar ambas as regras, logo uma pessoa caridosa lhe ajudará com o seu problema.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros Passos com o RStudio</span>"
    ]
  },
  {
    "objectID": "02-primeiros-passos-rstudio.html#autocomplete",
    "href": "02-primeiros-passos-rstudio.html#autocomplete",
    "title": "2  Primeiros Passos com o RStudio",
    "section": "2.6 Utilizando Code Completion com a Tecla tab",
    "text": "2.6 Utilizando Code Completion com a Tecla tab\nUm dos recursos mais úteis do RStudio é o preenchimento automático de código (code completion). Essa é uma ferramenta de edição que facilita o encontro de nomes de objetos, nome de pacotes, nome de arquivos e nomes de entradas em funções. O seu uso é muito simples. Após digitar um texto qualquer, basta apertar a tecla tab e uma série de opções aparecerá. Veja a Figure 2.7 apresentada a seguir, em que, após digitar a letra f e apertar tab, aparece uma janela com uma lista de objetos que iniciam com a respectiva letra.\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.7: Usando o sistema de ajuda do RStudio\n\n\n\n\n\nEssa ferramenta também funciona para pacotes. Para verificar, digite library(r) no prompt ou no editor, coloque o cursor entre os parênteses e aperte tab. O resultado deve ser algo parecido com a Figure 2.8.\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.8: Usando o autocomplete para procurar pacotes\n\n\n\n\n\nObserve que uma descrição do pacote ou objeto também é oferecida. Isso facilita bastante o dia a dia, pois a memorização das funcionalidades e dos nomes dos pacotes e os objetos do R não é uma tarefa fácil. O uso do tab diminui o tempo de investigação dos nomes e evita possíveis erros de digitação na definição destes.\nO uso dessa ferramenta torna-se ainda mais benéfico quando os objetos são nomeados com algum tipo de padrão. No restante do livro observarás que os objetos tendem a ser nomeados com o prefixo my, como em my_x, my_num, my_char. O uso desse padrão facilita o encontro futuro do nome dos objetos, pois basta digitar my, apertar tab e uma lista de todos os objetos criados pelo usuário aparecerá.\nOutro uso do tab é no encontro de arquivos e pastas no computador. Basta criar uma variável como my_file &lt;- \" \", apontar o cursor para o meio das aspas e apertar a tecla tab. Uma tela com os arquivos e pastas do diretório atual de trabalho aparecerá, conforme mostrado na Figure 2.9. Nesse caso específico, o R estava direcionado para a minha pasta de códigos, em que é possível enxergar diversos trabalhos realizados no passado.\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.9: Usando o autocomplete para navegar diretórios\n\n\n\n\n\nUma dica aqui é utilizar o tab com a raiz do computador. Assumindo que o disco do seu computador está alocado para C:/, digite my_file &lt;- \"C:/\" e pressione tab após o símbolo /. Uma tela com os arquivos da raiz do computador aparecerá no RStudio. Podes facilmente navegar o sistema de arquivos utilizando as setas e enter.\nO autocomplete também funciona para encontrar e definir as entradas de uma função. Veja um exemplo na Figure 2.10.\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.10: Usando o autocomplete para navegar argumentos de funções\n\n\n\n\n\n\n\n\n\n\n\nImportante\n\n\n\nO autocomplete é uma das ferramentas mais importantes do RStudio, salvando tempo e esforço no encontro de objetos, arquivos e diretórios do disco rígido, pacotes e funções. Apesar de não ser exclusiva ao RStudio, minha opinião é de que, para o R, o autocomplete do RStudio é o melhor disponível. Acostume-se a utilizar a tecla tab o quanto antes e logo verá como fica mais fácil escrever código rapidamente, e sem erros de digitação.\n\n\n\nQ.1 - Qual dos seguintes comandos abaixo executa um Script do R?\n\nControl + Shift + Enter\nShift + F\nControl+Shift + B\nControl + E\nControl + Shift + T\n\n\nQ.2 - Utilizando o sistema de ajuda do R, procure informações sobre a função mean() . O argumento “na.rm” serve para que?\n\nDefine se o resultado é mostrado na tela ou não\nDefinir o tipo de média (aritmética ou geométrica)\nRetira valores negativos de x\nRetirar valores NA do vetor de entrada x\nRemover valores extremos de x\n\n\nQ.3 - Novamente utilizando o sistema de ajuda do R, procure informações sobre a função browser() . Para que ela serve?\n\nRetira os valores positivos de um vetor numérico\nAbrir uma página da internet no Chrome ou firefox\nComo alternativa ao comando print, apresenta um resultado na tela do R\nProcurar ajuda para um comando na internet\nCriar um breakpoint no código, interrompendo a sua execução temporariamente, de forma a facilitar a inspeção da execução\n\n\nQ.4 - Sobre a ferramente autocomplete do RStudio, considere as seguintes afirmações:\nI - O Autocomplete serve para preencher códigos do R, facilitando o encontro de funções, objetos e arquivos do computador.\nII - O autocomplete funciona através da tecla tab. Após digitar parcialmente um nome, aperta-se o tab para que diversas opções aparecem para o usuário.\nIII - O autocomplete é uma ótima maneira de navegar pelos arquivos e pastas do computador.\nQuais alternativas estão corretas?\n\nApenas a I e II está correta\nApenas a II está correta\nApenas a III está correta\nTodas estão corretas\nApenas a I está correta",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Primeiros Passos com o RStudio</span>"
    ]
  },
  {
    "objectID": "03-primeiros-passos-R.html",
    "href": "03-primeiros-passos-R.html",
    "title": "3  Primeiros Passos com o R",
    "section": "",
    "text": "3.1 Objetos e Funções\nAo escrever um código no R, tudo é um objeto, e cada tipo de objeto tem suas propriedades. Por exemplo, o valor da temperatura média em determinado local ao longo do tempo – em vários meses e anos – pode ser representado como um objeto do tipo vetor numérico. As datas em si, no formato YYYY-MM-DD (ano-mês-dia), podem ser representadas como texto (character) ou a própria classe Date. Por fim, podemos representar conjuntamente os dados de temperatura e as datas armazenando-os em um objeto único do tipo dataframe, o qual nada mais é do que uma tabela com linhas e colunas. Todos esses objetos fazem parte do ecossistema do R e é através da manipulação destes que tiramos o máximo proveito do software.\nOs principais tipos de objetos do R são:\nEnquanto representamos informações do mundo real com as diferentes classes no R, um tipo especial de objeto é a função, a qual representa um procedimento preestabelecido que está disponível para o usuário. O R possui uma grande quantidade de funções, as quais possibilitam que o usuário realize uma vasta gama de procedimentos. Por exemplo, os comandos básicos do R, não incluindo demais pacotes, somam um total de 1270 funções. Com base neles e outros iremos importar dados, calcular médias, testar hipóteses, limpar dados, e muito mais.\nCada função possui um próprio nome. Por exemplo, a função sort() é um procedimento que ordena valores utilizados como input. Caso quiséssemos ordenar os valores no vetor numérico [2, 1, 3, 0], basta inserir no prompt o seguinte comando e apertar enter:\nsort(c(2, 1, 3, 0), decreasing = TRUE)\n\nR&gt; [1] 3 2 1 0\nO comando c(2, 1, 3, 0) combina os valores em um vetor (maiores detalhes sobre comando c() serão dados em seção futura). Observe que a função sort() é utilizada com parênteses de início e fim. Esses parênteses servem para destacar as entradas (inputs), isto é, as informações enviadas para a função produzir alguma coisa. Cada entrada (ou opção) da função é separada por uma vírgula, tal como em MinhaFuncao(entrada01, entrada02, entrada03, ...). No caso do código anterior, note que usamos a opção decreasing = TRUE. Essa é uma instrução específica para a função sort() ordenar de forma decrescente os elementos do vetor de entrada. Veja a diferença:\nsort(c(2, 1, 3, 0), decreasing = FALSE)\n\nR&gt; [1] 0 1 2 3\nO uso de funções está no coração do R e iremos dedicar grande parte do livro a elas. Por enquanto, essa breve introdução já serve o seu propósito. O principal é entender que uma função usa suas entradas para produzir algo de volta. Nos próximos capítulos iremos utilizar funções já existentes para as mais diferentes finalidades: baixar dados da internet, ler arquivos, realizar testes estatísticos e muito mais. Na ?sec-programacao iremos tratar deste assunto com maior profundidade, incluindo a forma de escrevermos nossas próprias funções.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Primeiros Passos com o R</span>"
    ]
  },
  {
    "objectID": "03-primeiros-passos-R.html#objetos-e-funções",
    "href": "03-primeiros-passos-R.html#objetos-e-funções",
    "title": "3  Primeiros Passos com o R",
    "section": "",
    "text": "numéricos (numeric)\n\nrepresentam números e medidas.\n\ncaracteres (character)\n\nrepresentam texto.\n\nfatores (factors)\n\nrepresentam grupos dentro dos dados, tipo “Casado/Solteiro”, “Destro/Canhoto”.\n\ndataframes ou tibbles\n\nagrupam dados na representação de tabelas, as quais podem conter dados numéricos, caracteres e fatores em um único objeto. Uma de suas restrições é que cada coluna da tabela tenha o mesmo número de elementos.\n\nlistas\n\nagrupam dados em um único objeto, porém sem restrição sobre o tipo e o número de elementos em cada sub-objeto.\n\n\n\n\n\n\n\n\n\nPacote base\n\n\n\nO base é certamente o pacote mais utilizado no R e já vem pré-instalado. O mesmo possui uma quantidade imensa de funções, com os mais diferentes propósitos. Saiba que o base é automaticamente carregado na inicialização de sua sessão do R, permitindo acesso direto às suas funções.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Primeiros Passos com o R</span>"
    ]
  },
  {
    "objectID": "03-primeiros-passos-R.html#criando-objetos-simples",
    "href": "03-primeiros-passos-R.html#criando-objetos-simples",
    "title": "3  Primeiros Passos com o R",
    "section": "3.2 Criando Objetos Simples",
    "text": "3.2 Criando Objetos Simples\nUm dos comandos mais básicos no R é a definição de objetos. Como foi mostrado nas seções anteriores, pode-se definir um objeto com o uso do comando &lt;-, o qual, para o português, é traduzido para o verbo defina (assign em inglês).\nConsidere o código a seguir. Para rodar o código no seu computador, escreva (ou copie e cole) o código mostrado em um novo script do RStudio e aperte control + shift + enter. Mais detalhes sobre diferentes maneiras de executar código no RStudio serão dadas em Section 2.1\n\n# set x\nmy_x &lt;- 123\n\n# set x, y and z in one line\nmy_x &lt;- 1 ; my_y &lt;- 2; my_z &lt;- 3\n\nLê-se esse código como x é definido como 123. A direção da seta define onde o valor será armazenado. Por exemplo, utilizar 123 -&gt; my_x também funcionaria, apesar de ser uma sintaxe pouco utilizada ou recomendada. Note que também é possível escrever diversos comandos na mesma linha com o uso da semi-vírgula (;).\n\n\n\n\n\n\nImportante\n\n\n\nO uso do símbolo &lt;- para a definição de objetos é específico do R. Na época da concepção da linguagem S, de onde o R foi baseado, existiam teclados com uma tecla específica que definia diretamente o símbolo de seta. Teclados contemporâneos, porém, não possuem mais esta configuração. Uma alternativa é utilizar o atalho para o símbolo, o qual, no Windows, é definido por alt + -.\n\n\n\n\n\n\n\n\nPosso usar o símbolo “=”?\n\n\n\nÉ possível também usar o símbolo = para definir objetos assim como o &lt;-. Saliento que esta é prática comum em outras linguagens de programação. Porém, no ecossistema do R, a utilização do = com esse fim específico não é recomendada. O símbolo de igualdade tem o seu uso especial e resguardado na definição de argumentos de uma função tal como sort(x = 1:10, decreasing = TRUE). Como sugestão, dê preferência ao uso do &lt;- para a criação de novos objetos.\n\n\nO R executa o código procurando objetos e funções disponíveis no seu ambiente de trabalho (enviromnent). Se tentarmos acessar um objeto que não existe, o R irá retornar uma mensagem de erro:\n\nprint(z)\n\n\n\nR&gt; Error in print(z): object 'z' not found\n\n\nIsso ocorre pois o objeto z não existe na sessão atual do R. Se criarmos uma variável z como z &lt;- 123 e repetirmos o comando print(z), não teremos a mesma mensagem de erro.\nUm ponto importante aqui é a definição de objetos de classes diferentes com o uso de símbolos específicos. O uso de aspas duplas (\" \") ou simples (' ') define objetos da classe texto enquanto números são definidos pelo próprio valor. Conforme será mostrado, cada objeto no R tem uma classe e cada classe tem um comportamento diferente. Portanto, objetos criados com o uso de aspas pertencem à classe character. Podemos confirmar isso via código:\n\n# set vars\nx &lt;- 1\ny &lt;- '1'\n\n# display classes\nclass(x)\n\nR&gt; [1] \"numeric\"\n\nclass(y)\n\nR&gt; [1] \"character\"\n\n\nAs saídas anteriores mostram que a variável x é do tipo numérico, enquanto a variável y é do tipo texto (character). Ambas fazem parte das classes básicas de objetos no R. Por enquanto, este é o mínimo que deves saber para avançar nos próximos capítulos. Iremos estudar este assunto mais profundamente na Chapter 6.\n\n\n\n\n\n\nImportante\n\n\n\nA nomeação dos objetos criados no R é importante. Tirando alguns casos específicos, o usuário pode nomear os objetos como quiser. Essa liberdade, porém, pode ser um problema. É desejável sempre dar nomes curtos que façam sentido ao conteúdo do objeto e que sejam simples de entender. Isso facilita o entendimento do código por outros usuários e faz parte das normas sugeridas para a estruturação do código do Google.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Primeiros Passos com o R</span>"
    ]
  },
  {
    "objectID": "03-primeiros-passos-R.html#vetores-atômicos",
    "href": "03-primeiros-passos-R.html#vetores-atômicos",
    "title": "3  Primeiros Passos com o R",
    "section": "3.3 Vetores Atômicos",
    "text": "3.3 Vetores Atômicos\nAnteriormente, criamos objetos simples tal como x &lt;- 1 e x &lt;- 'abc'. Enquanto isso é suficiente para demonstrar os comandos básicos do R, na prática tais comandos são bastante limitados, uma vez que um problema real de análise de dados certamente irá ter um maior volume de informações do mundo real.\nUm dos procedimentos mais utilizados no R é a criação de vetores atômicos. Estes são objetos que guardam uma série de elementos da mesma classe, o que justifica a sua propriedade “atômica”. Um exemplo seria representar no R uma série de preços diários de uma ação negociada em bolsa de valores. Tal série possui vários valores numéricos que formam um vetor da classe numérica.\nVetores atômicos são criados no R através do uso do comando c()** **, o qual é oriundo do verbo em inglês combine. Por exemplo, caso eu quisesse combinar os valores 1, 2 e 3 em um vetor, eu poderia fazê-lo através do seguinte comando:\n\n# set vector\nx &lt;- c(1, 2, 3)\n\n# print it\nprint(x)\n\nR&gt; [1] 1 2 3\n\n\nEsse comando funciona da mesma maneira para qualquer número de elementos. Caso necessário, poderíamos criar um vetor com mais elementos simplesmente adicionando valores após o 3, tal como em x &lt;- c(1, 2, 3, 4, 5).\nO uso do comando c() não é exclusivo para vetores numéricos. Por exemplo, poderíamos criar um vetor de outra classe de dados, tal como character:\n\ny &lt;- c('text 1', 'text 2', 'text 3', 'text 4')\nprint(y)\n\nR&gt; [1] \"text 1\" \"text 2\" \"text 3\" \"text 4\"\n\n\nA única restrição no uso do comando c() é que todos os itens do vetor tenham a mesma classe. Se inserirmos dados de classes diferentes, o R irá tentar transformar os itens para a mesma classe seguindo uma lógica própria, onde a classe mais complexa sempre tem preferência. Caso ele não consiga transformar todos os elementos para a classe mais complexa, uma mensagem de erro será retornada. Observe, no próximo exemplo, que ao misturarmos text com números, os valores numéricos no primeiro e segundo elemento de x2 são transformados para a classe de caracteres.\n\n# numeric class\nx1 &lt;- c(1, 2, 3)\nclass(x1)\n\nR&gt; [1] \"numeric\"\n\n# character class\nx2 &lt;- c(1, 2, '3')\nclass(x2)\n\nR&gt; [1] \"character\"\n\n\nOutra utilização do comando c() é a combinação de vetores. De fato, isto é exatamente o que fizemos ao executar o código c(1, 2, 3). Neste caso, cada vetor possuía um elemento. Podemos realizar o mesmo com vetores maiores. Veja a seguir:\n\n# set x and y\nx &lt;- c(1, 2, 3)\ny &lt;- c(4, 5)\n\n# print concatenation between x and y\nprint(c(x, y))\n\nR&gt; [1] 1 2 3 4 5\n\n\nPortanto, o comando c() possui duas funções principais: criar e combinar vetores.\nAlternativamente, podemos também criar vetores utilizando nomes para os elementos:\n\n# create named vector\nnamed_vec &lt;- c(\"x\" = 1, \"y\" = 2)\n\n# print its contents\nprint(named_vec)\n\nR&gt; x y \nR&gt; 1 2\n\n\nAssim, podemos acessar cada elemento usando o seu nome:\n\n# print only \"x\" value in named_vec\nprint(named_vec[\"x\"])\n\nR&gt; x \nR&gt; 1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Primeiros Passos com o R</span>"
    ]
  },
  {
    "objectID": "03-primeiros-passos-R.html#conhecendo-os-objetos-criados",
    "href": "03-primeiros-passos-R.html#conhecendo-os-objetos-criados",
    "title": "3  Primeiros Passos com o R",
    "section": "3.4 Conhecendo os Objetos Criados",
    "text": "3.4 Conhecendo os Objetos Criados\nApós a execução de diversos comandos no editor ou prompt, é desejável saber quais são os objetos criados pelo código. É possível descobrir essa informação simplesmente olhando para o lado direito superior do RStudio, na aba da área de trabalho. Porém, existe um comando que sinaliza a mesma informação no prompt. Com o fim de saber quais são as variáveis atualmente disponíveis na memória do R, pode-se utilizar o comando ls() . Observe o exemplo a seguir:\n\n# set vars\nx &lt;- 1\ny &lt;- 2\nz &lt;- 3\n\n# show current objects\nls()\n\n\n\nR&gt; [1] \"x\" \"y\" \"z\"\n\n\nOs objetos x, y e z foram criados e estavam disponíveis no ambiente de trabalho atual, juntamente com outros objetos. Para descobrir os valores dos mesmos, basta digitar os nomes dos objetos e apertar enter no prompt:\n\nx\n\nR&gt; [1] 1\n\ny\n\nR&gt; [1] 2\n\nz\n\nR&gt; [1] 3\n\n\nDigitar o nome do objeto na tela tem o mesmo resultado que utilizar a função print() . De fato, ao executar o nome de uma variável, internamente o R passa esse objeto para a função print() .\nNo R, conforme já mostrado, todos os objetos pertencem a alguma classe. Para descobrir a classe de um objeto, basta utilizar a função class() . Observe no exemplo a seguir que x é um objeto da classe numérica e y é um objeto da classe de texto (character).\n\n# set vars\nx &lt;- 1\ny &lt;- 'a'\n\n# check classes\nclass(x)\n\nR&gt; [1] \"numeric\"\n\nclass(y)\n\nR&gt; [1] \"character\"\n\n\nOutra maneira de conhecer melhor um objeto é verificar a sua representação em texto. Todo objeto no R possui uma representação textual e a verificação desta é realizada através da função str() :\n\n# print textual representation of a vector\nx &lt;- 1:10\nprint(str(x))\n\nR&gt;  int [1:10] 1 2 3 4 5 6 7 8 9 10\nR&gt; NULL\n\n\nEssa função é particularmente útil quando se está tentando entender os detalhes de um objeto mais complexo, tal como uma tabela. A utilidade da representação textual é que nela aparece o tamanho do objeto e suas classes internas. Nesse caso, o objeto x é da classe integer e possui dez elementos. Como exemplo para um objeto mais complexo, as seguir apresentamos a representação textual de um objeto do tipo dataframe:\n\n# print textual representation of a dataframe\ndf &lt;- data.frame(x = 1:10, y = \"ABC\")\nprint(str(df))\n\nR&gt; 'data.frame':    10 obs. of  2 variables:\nR&gt;  $ x: int  1 2 3 4 5 6 7 8 9 10\nR&gt;  $ y: chr  \"ABC\" \"ABC\" \"ABC\" \"ABC\" ...\nR&gt; NULL",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Primeiros Passos com o R</span>"
    ]
  },
  {
    "objectID": "03-primeiros-passos-R.html#conhecendo-o-tamanho-dos-objetos",
    "href": "03-primeiros-passos-R.html#conhecendo-o-tamanho-dos-objetos",
    "title": "3  Primeiros Passos com o R",
    "section": "3.5 Conhecendo o Tamanho dos Objetos",
    "text": "3.5 Conhecendo o Tamanho dos Objetos\nNa prática de programação com o R, é muito importante saber o tamanho das variáveis que estão sendo utilizadas. Isso serve não somente para auxiliar o usuário na verificação de possíveis erros do código, mas também para saber o tamanho necessário em certos procedimentos de iteração tal como loops, os quais serão tratados em capítulo futuro.\nNo R, o tamanho do objeto pode ser verificado com o uso de quatro principais funções: length() , nrow() , ncol() e dim() .\nA função length() é destinada a objetos com uma única dimensão, tal como vetores atômicos:\n\n# set x\nx &lt;- c(2, 3, 3, 4, 2, 1)\n\n# get length x\nn &lt;- length(x)\n\n# display message\nmessage(paste('The length of x is', n))\n\nR&gt; The length of x is 6\n\n\nPara objetos com mais de uma dimensão, por exemplo matrizes e dataframes, utilizam-se as funções nrow() , ncol() e dim() para descobrir o número de linhas (primeira dimensão) e o número de colunas (segunda dimensão). Veja a diferença a seguir.\n\n# set matrix and print it\nx &lt;- matrix(1:20, nrow = 4, ncol = 5)\nprint(x)\n\nR&gt;      [,1] [,2] [,3] [,4] [,5]\nR&gt; [1,]    1    5    9   13   17\nR&gt; [2,]    2    6   10   14   18\nR&gt; [3,]    3    7   11   15   19\nR&gt; [4,]    4    8   12   16   20\n\n# find number of rows, columns and elements\nmy_nrow &lt;- nrow(x)\nmy_ncol &lt;- ncol(x)\nmy_length &lt;- length(x)\n\n# print message\nmessage(paste('\\nThe number of lines in x is ', my_nrow))\n\nR&gt; \nR&gt; The number of lines in x is  4\n\nmessage(paste('\\nThe number of columns in x is ', my_ncol))\n\nR&gt; \nR&gt; The number of columns in x is  5\n\nmessage(paste('\\nThe number of elements in x is ', my_length))\n\nR&gt; \nR&gt; The number of elements in x is  20\n\n\nJá a função dim() mostra a dimensão do objeto, resultando em um vetor numérico como saída. Essa deve ser utilizada quando o objeto tiver mais de duas dimensões. Na prática, esses casos são raros. Um exemplo para a variável x é dado a seguir:\n\nprint(dim(x))\n\nR&gt; [1] 4 5\n\n\nPara o caso de objetos com mais de duas dimensões, podemos utilizar a função array() para criá-los e dim() para descobrir o seu tamanho:\n\n# set array with dimension\nmy_array &lt;- array(1:9, dim = c(3,3,3))\n\n# print it\nprint(my_array)\n\nR&gt; , , 1\nR&gt; \nR&gt;      [,1] [,2] [,3]\nR&gt; [1,]    1    4    7\nR&gt; [2,]    2    5    8\nR&gt; [3,]    3    6    9\nR&gt; \nR&gt; , , 2\nR&gt; \nR&gt;      [,1] [,2] [,3]\nR&gt; [1,]    1    4    7\nR&gt; [2,]    2    5    8\nR&gt; [3,]    3    6    9\nR&gt; \nR&gt; , , 3\nR&gt; \nR&gt;      [,1] [,2] [,3]\nR&gt; [1,]    1    4    7\nR&gt; [2,]    2    5    8\nR&gt; [3,]    3    6    9\n\n# print its dimension\nprint(dim(my_array))\n\nR&gt; [1] 3 3 3\n\n\nReforçando, cada objeto no R tem suas propriedades e funções específicas para manipulação.\n\n\n\n\n\n\nCuidado\n\n\n\nUma observação importante aqui é que as funções anteriores não servem para descobrir o número de letras em um texto. Esse é um erro bastante comum. Por exemplo, caso tivéssemos um objeto do tipo texto e usássemos a função length() , o resultado seria o seguinte:\n\n# set char object\nmy_char &lt;- 'abcde'\n\n# find its length (and NOT number of characters)\nprint(length(my_char))\n\nR&gt; [1] 1\n\n\nIsso ocorre pois a função length() retorna o número de elementos. Nesse caso, my_char possui apenas um elemento. Para descobrir o número de caracteres no objeto, utilizamos a função nchar() , conforme a seguir:\n\n# using nchar for number of characters\nprint(nchar(my_char))\n\nR&gt; [1] 5",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Primeiros Passos com o R</span>"
    ]
  },
  {
    "objectID": "03-primeiros-passos-R.html#exercícios",
    "href": "03-primeiros-passos-R.html#exercícios",
    "title": "3  Primeiros Passos com o R",
    "section": "3.6 Exercícios",
    "text": "3.6 Exercícios\n\nQ.1 - Crie um novo script, salve o mesmo em uma pasta pessoal. Agora, escreva os comandos no script que definam dois objetos: um contendo uma sequência entre 1 e 100 e outro com o texto do seu nome (ex. 'Ricardo'). Execute o código com os atalhos no teclado.\n\nQ.2 - No script criado anteriormente, use função message() para mostrar a seguinte frase no prompt do R: \"My name is ....\".\n\nQ.3 - Você e três amigos foram comer um delicioso X em Porto Alegre RS. A conta final ficou como a seguir:\n\n\n\n\n\n\n\n\nNome\nPedido\nValor\n\n\n\n\nVocê\nX salada\n20\n\n\nMarcelo\nX bacon\n25\n\n\nRicardo\nX salada\n20\n\n\nAmadeus\nX Galinha\n22\n\n\n\n\n\n\n\nNo final da janta decidiram que iriam dividir a conta igualmente, isto é, basta somar os gastos individuais, e dividir pelo número de participantes.\nUsando o R, crie um código que resulte no valor a ser pago por cada participante do jantar.\n\nR$ 15,34\nR$ 6,97\nR$ 21,75\nR$ 2,79\nR$ 11,15\n\n\nQ.4 - Qual o comando do R que mostra todos objetos disponíveis na sua sessão do R?\n\nmean()\nmessage()\nprint()\nls()\ncat()\n\n\nQ.5 - Qual das seguintes funções não mostra um texto na tela?\n\nprint()\ncat()\ncli::cli_alert()\nmessage()\ndisplay()\n\n\nQ.6 - Qual das funções abaixo possui o mesmo resultado do comando paste0(c(\"a\", \"b\", \"c\"))?\n\nprint(c(“a”, “b”, “c”))\ncat(c(“a”, “b”, “c”))\nmessage(c(“a”, “b”, “c”))\npaste(c(“a”, “b”, “c”), sep = ““)\ncli::cli_alert(c(“a”, “b”, “c”))“)\n\n\nQ.7 - Considere o objeto criado com o código a seguir:\n\n{. .cell-code} M &lt;- matrix(1:12, nrow = 3)\n\nQual o número de colunas no objeto resultante?\n\n9\n1\n6\n3\n4",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Primeiros Passos com o R</span>"
    ]
  },
  {
    "objectID": "04-pacotes.html",
    "href": "04-pacotes.html",
    "title": "4  Pacotes do R",
    "section": "",
    "text": "4.1 Instalando Pacotes do CRAN\nPara instalar um pacote, basta utilizar o comando install.packages() . Como exemplo, vamos instalar um pacote que será utilizado nos capítulos futuros, o {readr} (Wickham, Hester, and Bryan 2024):\n# install pkg readr\ninstall.packages('readr')\nCopie e cole este comando no prompt e pronto! O R irá baixar os arquivos necessários e instalar o pacote {readr} (Wickham, Hester, and Bryan 2024) e suas dependências. Após isto, as funções relativas ao pacote estarão prontas para serem usadas após o carregamento do módulo. Observe que definimos o nome do pacote na instalação como se fosse texto, com o uso das aspas (\"). Caso o pacote instalado seja dependente de outros pacotes, o R automaticamente instala todos módulos faltantes. Assim, todos os requerimentos para o uso do respectivo pacote já estarão satisfeitos e tudo funcionará perfeitamente. É possível, porém, que um pacote tenha uma dependência externa. Como exemplo, pacote {quarto} (Allaire and Dervieux 2024) depende da existência de uma instalação do LaTex. Geralmente essa é anunciada na sua descrição e um erro é sinalizado na execução do programa quando o LaTex não é encontrado. Fique atento, portanto, a esses casos.\nAproveitando o tópico, sugiro que o leitor já instale todos os pacotes do {tidyverse} (Wickham 2023b) com o seguinte código:\n# install pkgs from tidyverse\ninstall.packages('tidyverse')\nO {tidyverse} (Wickham 2023b) é um conjunto de pacotes voltados a data science e com uma sintaxe própria e consistente, voltada a praticabilidade. Verás que, em uma instalação nova do R, o {tidyverse} (Wickham 2023b) depende de uma grande quantidade de pacotes.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pacotes do R</span>"
    ]
  },
  {
    "objectID": "04-pacotes.html#instalando-pacotes-do-github",
    "href": "04-pacotes.html#instalando-pacotes-do-github",
    "title": "4  Pacotes do R",
    "section": "4.2 Instalando Pacotes do Github",
    "text": "4.2 Instalando Pacotes do Github\nPara instalar um pacote diretamente do Github, um dos pré-requisitos é o pacote {devtools} (Wickham et al. 2022), disponível no CRAN:\n\n# install devtools\ninstall.packages('devtools')\n\nApós isto, utilize função devtools::install_github() para instalar um pacote diretamente do Github. Note que o símbolo :: indica que função install_github() pertence ao pacote {devtools}. Com esta particular sintaxe, não precisamos carregar todo o pacote para utilizar apenas uma função.\nNo exemplo a seguir instalamos a versão em desenvolvimento do pacote {ggplot2} (Wickham et al. 2024), cuja versão oficial também está disponível no CRAN:\n\n# install ggplot2 from github\ndevtools::install_github(\"hadley/ggplot2\")\n\nObserve que o nome do usuário do repositório também é incluído. No caso anterior, o nome hadley pertence ao desenvolvedor principal do {ggplot2} (Wickham et al. 2024), Hadley Wickham. No decorrer do livro notará que esse nome aparecerá diversas vezes, dado que Hadley é um prolífico e competente desenvolvedor de diversos pacotes do R e do {tidyverse} (Wickham 2023b).\n\n\n\n\n\n\nCuidado\n\n\n\nUm aviso aqui é importante. Os pacotes do github não são moderados. Qualquer pessoa pode enviar código para lá e o conteúdo não é checado. Nunca instale pacotes do github sem conhecer os autores. Apesar de improvável – nunca aconteceu comigo por exemplo – é possível que esses possuam algum código malicioso.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pacotes do R</span>"
    ]
  },
  {
    "objectID": "04-pacotes.html#carregando-pacotes",
    "href": "04-pacotes.html#carregando-pacotes",
    "title": "4  Pacotes do R",
    "section": "4.3 Carregando Pacotes",
    "text": "4.3 Carregando Pacotes\nDentro de uma rotina de pesquisa, utilizamos a função library() para carregar um pacote na nossa sessão do R. Ao fecharmos o RStudio ou então iniciar uma nova sessão do R, os pacotes são descarregados. Vale salientar que alguns pacotes, tal como o {base} (R Core Team 2023a) e o {stats} (R Core Team 2023b), são inicializados automaticamente a cada nova sessão. A grande maioria, porém, deve ser carregada no início dos scripts. Veja o exemplo a seguir:\n\n# load dplyr\nlibrary(dplyr)\n\nA partir disso, todas as funções do pacote estarão disponíveis para o usuário. Note que não é necessário utilizar aspas (\") ao carregar o pacote. Caso utilize uma função específica do pacote e não deseje carregar todo ele, pode fazê-lo através do uso do símbolo especial ::, conforme o exemplo a seguir.\n\n# call fct fortune() from pkg fortune\nfortunes::fortune(10)\n\nR&gt; \nR&gt; Overall, SAS is about 11 years behind R and S-Plus in\nR&gt; statistical capabilities (last year it was about 10 years\nR&gt; behind) in my estimation.\nR&gt;    -- Frank Harrell (SAS User, 1969-1991)\nR&gt;       R-help (September 2003)\n\n\nNesse caso, utilizamos a função fortunes::fortune() do próprio pacote {fortunes} (Zeileis 2016), o qual mostra na tela uma frase possivelmente engraçada escolhida do mailing list do R. Nesse caso, selecionamos a mensagem número 10. Se não tiver disponível o pacote, o R mostrará a seguinte mensagem de erro:\n\n\nR&gt; Error in library(\"fortune\") : there is no package called \"fortune\"\n\n\nPara resolver, utilize o comando install.packages(\"fortunes\") para instalar o pacote no seu computador. Execute o código fortunes::fortune(10) no prompt para confirmar a instalação. Toda vez que se deparar com essa mensagem de erro, deves instalar o pacote que está faltando.\nOutra maneira de carregar um pacote é através da função require() . Esta tem um comportamento diferente da função library() pois não emite erro se o pacote não estiver instalado. Usualmente, require() é utilizado dentro da definição de funções ou no teste do carregamento do pacote. Caso o usuário crie uma função customizada que necessite de procedimentos de um pacote em particular, o mesmo deve carregar o pacote no escopo da função. Por exemplo, veja o código a seguir, em que criamos uma função dependente do pacote {quantmod} (Ryan and Ulrich 2024):\n\nmy_fct &lt;- function(x){\n  require(quantmod)\n\n  df &lt;- getSymbols(x, auto.assign = F)\n  return(df)\n}\n\nNesse caso, a função quantmod::getSymbols() faz parte do pacote {quantmod} (Ryan and Ulrich 2024). Não se preocupe agora com a estrutura utilizada para criar uma função no R. Essa será explicada em capítulo futuro.\n\n\n\n\n\n\nCuidado!\n\n\n\nUma precaucão que deve sempre ser tomada quando se carrega um pacote é um possível conflito de funções. Por exemplo, existe uma função chamada filter() no pacote {dplyr} (Wickham et al. 2023) e também no pacote {stats} (R Core Team 2023b). Caso carregarmos ambos pacotes e chamarmos a função filter() no escopo do código, qual delas o R irá usar?\nPois bem, a preferência é sempre para o último pacote carregado. Esse é um tipo de problema que pode gerar muita confusão. Felizmente, note que o próprio R acusa um conflito de nome de funções no carregamento do pacote. Para testar, inicie uma nova sessão do R e carregue o pacote {dplyr} (Wickham et al. 2023). Verás que uma mensagem indica haver dois conflitos com o pacote stats e quatro com pacote o {base} (R Core Team 2023a). Alternativamente, pacote {conflicted} (Wickham 2023a) oferece uma maneira explícita de administrar possíveis conflitos e definir quais funções são usadas no código.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pacotes do R</span>"
    ]
  },
  {
    "objectID": "04-pacotes.html#atualizando-pacotes",
    "href": "04-pacotes.html#atualizando-pacotes",
    "title": "4  Pacotes do R",
    "section": "4.4 Atualizando Pacotes",
    "text": "4.4 Atualizando Pacotes\nAo longo do tempo, é natural que os pacotes disponibilizados no CRAN sejam atualizados para acomodar novas funcionalidades ou se adaptar a mudanças em suas dependências. Assim, é recomendável que os usuários atualizem os seus pacotes instalados para uma nova versão através da internet. Esse procedimento é bastante fácil. Uma maneira direta de atualizar pacotes é clicar no botão update no painel de pacotes no canto direito inferior do RStudio, conforme mostrado na Figure 4.1.\n\n\n\n\n\n\n\n\nFigure 4.1: Atualizando pacotes no R\n\n\n\n\n\nA atualização de pacotes através do prompt também é possível. Para isso, basta utilizar o comando update.packages() , conforme mostrado a seguir.\n\nupdate.packages()\n\nO comando update.packages() compara a versão dos pacotes instalados em relação a versão disponível no CRAN. Caso tiver alguma diferença, a nova versão é instalada. Após a execução do comando, todos os pacotes estarão atualizados com a versão disponível nos servidores do CRAN.\n\n\n\n\n\n\nImportante\n\n\n\nVersionamento de pacotes é extremamente importante para manter a reprodutibilidade do código. Apesar de ser raro de acontecer, é possível que a atualização de um pacote no R modifique, para os mesmos dados, resultados já obtidos anteriormente. Tenho uma experiência particularmente memorável quando um artigo científico retornou da revisão e, devido a atualização de um dos pacotes, não consegui reproduzir os resultados apresentados no artigo original. No final das contas deu tudo certo, mas o trauma fica. Reporto, porém, que isto é muito raro de acontecer.\nUma solução para este problema é congelar as versões dos pacotes para cada projeto usando a ferramenta {renv} (Ushey and Wickham 2024) do RStudio. Em resumo, o {renv} (Ushey and Wickham 2024) faz cópias locais dos pacotes utilizados no projeto, os quais têm preferência aos pacotes do sistema. Assim, se um pacote for atualizado no sistema, mas não no projeto, o código R vai continuar usando a versão mais antiga e seu código sempre rodará nas mesmas condições.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pacotes do R</span>"
    ]
  },
  {
    "objectID": "04-pacotes.html#pacote-intror",
    "href": "04-pacotes.html#pacote-intror",
    "title": "4  Pacotes do R",
    "section": "4.5 Pacote introR",
    "text": "4.5 Pacote introR\nNas seções futuras iremos utilizar o pacote do livro – introR – para carregar diversos exemplos de arquivos. Se você seguiu as instruções da seção Material Suplementar localizada no prefácio do livro, já deves ter o pacote instalado. Caso contrário, execute o seguinte código:\n\n# install devtools (if not installed)\nif (!require(devtools)) install.packages ('devtools')\n\n# install book package\ndevtools::install_github ('msperlin/introR')\n\nUma vez que você instalou o pacote {introR} (R-introR?), todos os arquivos de dados usados no livro foram baixados. Podemos verificar os cinco primeiros arquivos disponíveis com o comando introR::data_list() :\n\n# list available data files\nintroR::data_list()\n\nR&gt; \n\n\nR&gt; ── Available data files at '/home/msperlin/R/x86_64-pc-linux\n\n\nR&gt; ℹ CH04_another-funky-csv-file.csv\n\n\nR&gt; ℹ CH04_example-fst.fst\n\n\nR&gt; ℹ CH04_example-Rdata.RData\n\n\nR&gt; ℹ CH04_example-rds.rds\n\n\nR&gt; ℹ CH04_example-sqlite.SQLite\n\n\nR&gt; ℹ CH04_example-tsv.tsv\n\n\nR&gt; ℹ CH04_funky-csv-file.csv\n\n\nR&gt; ℹ CH04_ibovespa-Excel.xlsx\n\n\nR&gt; ℹ CH04_ibovespa.csv\n\n\nR&gt; ℹ CH04_price-and-prejudice.txt\n\n\nR&gt; ℹ CH04_SP500-Excel.xlsx\n\n\nR&gt; ℹ CH04_SP500.csv\n\n\nR&gt; ℹ CH07_FileWithLatinChar_Latin1.txt\n\n\nR&gt; ℹ CH07_FileWithLatinChar_UTF-8.txt\n\n\nR&gt; ℹ CH08_some-stocks-SP500.csv\n\n\nR&gt; ℹ CH08_wide-example-stocks.csv\n\n\nR&gt; ℹ CH10_sp500-stocks-long-by-year.csv\n\n\nR&gt; ℹ CH11_grunfeld.csv\n\n\nR&gt; ℹ CH11_SP500.csv\n\n\nR&gt; ℹ CH11_UCI-Credit-Card.csv\n\n\nR&gt; ℹ EX_B3-stocks.rds\n\n\nR&gt; ℹ EX_football-br.csv\n\n\nR&gt; ℹ EX_Ibov_PETR4.csv\n\n\nR&gt; ℹ EX_ibovespa.rds\n\n\nR&gt; ℹ EX_SP500-stocks-wide.csv\n\n\nR&gt; ℹ EX_SP500-stocks-yearly.rds\n\n\nR&gt; ℹ EX_SP500-stocks.rds\n\n\nR&gt; ℹ EX_TD-data.rds\n\n\nR&gt; ℹ EX_TweetsElonMusk.csv\n\n\nR&gt; \n\n\nR&gt; ✔ You can get the local path of file using introR::data_path(name_of_file)\n\n\nR&gt; ✔ Example: local_path &lt;- introR::data_path('CH04_funky-csv-file.csv')\n\n\nOs arquivos anteriores estão salvos na pasta de instalação dos pacote introR. Para ter o caminho completo, basta usar função introR::data_path() tendo o nome do arquivo como entrada:\n\n# get location of file\nmy_f &lt;- introR::data_path('CH11_grunfeld.csv')\n\n# print it\nprint(my_f)\n\nR&gt; /home/msperlin/R/x86_64-pc-linux-gnu-library/4.3/introR/extdata/data/CH11_grunfeld.csv\n\n\nA partir de agora iremos usar a função introR::data_path para obter o caminho dos arquivos utilizados nos exemplos. Note que, desde que tenha o pacote introR instalado, podes facilmente reproduzir todos os exemplos do livro no seu computador.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pacotes do R</span>"
    ]
  },
  {
    "objectID": "04-pacotes.html#exercícios",
    "href": "04-pacotes.html#exercícios",
    "title": "4  Pacotes do R",
    "section": "4.6 Exercícios",
    "text": "4.6 Exercícios\n\nQ.1 - Toda vez que o usuário instala um pacote do R, os arquivos particulares ao pacote são armazenados localmente em uma pasta específica do computador. Utilizando comando Sys.getenv('R_LIBS_USER') e list.dirs, liste todos os diretórios desta pasta. Quantos pacotes estão disponíveis nesta pasta do seu computador?\n\nQ.2 - Use função install.packages() para instalar o pacote {yfR} (Perlin 2023) no seu computador. Após a instalação, use função yfR::get_yf para baixar dados de preços para a ação da Petrobrás – PETR3 (PETR3.SA no Yahoo finance) – nos últimos 15 dias. Dica: use função Sys.Date() para definir data atual e Sys.Date() - 15 para calcular a data localizada 15 dias no passado.\n\nQ.3 - Pacote {cranlogs} (R-cranlogs?) permite o acesso a estatísticas de downloads de pacotes do CRAN. Após instalar o pacote no seu computador, use função cranlogs::cran_top_downloads() para verificar quais são os 10 pacotes mais instalados pela comunidade global no último mês. Qual o pacote em primeiro lugar? Dica: Defina a entrada da função cran_top_downloads como sendo when = 'last-week'. Também note que a resposta aqui pode não ser a mesma que obteve pois esta depende do dia em que foi executado o código.\n\ncli\nrlang\ntextshaping\nragg\nggplot2\n\n\nQ.4 - Utilizando pacote devtools, instale a versão de desenvolvimento do pacote {ggplot2} (Wickham et al. 2024), disponível no repositório de Hadley Hickman. Carregue o pacote usando library e crie uma figura simples com o código qplot(y = rnorm(10), x = 1:10).\n\n\n\n\nAllaire, JJ, and Christophe Dervieux. 2024. Quarto: R Interface to Quarto Markdown Publishing System. https://github.com/quarto-dev/quarto-r.\n\n\nPerlin, Marcelo. 2023. yfR: Downloads and Organizes Financial Data from Yahoo Finance. https://github.com/ropensci/yfR.\n\n\nR Core Team. 2023b. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/.\n\n\n———. 2023a. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/.\n\n\nRyan, Jeffrey A., and Joshua M. Ulrich. 2024. Quantmod: Quantitative Financial Modelling Framework. https://www.quantmod.com/.\n\n\nUshey, Kevin, and Hadley Wickham. 2024. Renv: Project Environments. https://rstudio.github.io/renv/.\n\n\nWickham, Hadley. 2023a. Conflicted: An Alternative Conflict Resolution Strategy. https://conflicted.r-lib.org/.\n\n\n———. 2023b. Tidyverse: Easily Install and Load the Tidyverse. https://tidyverse.tidyverse.org.\n\n\nWickham, Hadley, Winston Chang, Lionel Henry, Thomas Lin Pedersen, Kohske Takahashi, Claus Wilke, Kara Woo, Hiroaki Yutani, Dewey Dunnington, and Teun van den Brand. 2024. Ggplot2: Create Elegant Data Visualisations Using the Grammar of Graphics. https://ggplot2.tidyverse.org.\n\n\nWickham, Hadley, Romain François, Lionel Henry, Kirill Müller, and Davis Vaughan. 2023. Dplyr: A Grammar of Data Manipulation. https://dplyr.tidyverse.org.\n\n\nWickham, Hadley, Jim Hester, and Jennifer Bryan. 2024. Readr: Read Rectangular Text Data. https://readr.tidyverse.org.\n\n\nWickham, Hadley, Jim Hester, Winston Chang, and Jennifer Bryan. 2022. Devtools: Tools to Make Developing r Packages Easier. https://devtools.r-lib.org/.\n\n\nZeileis, Achim. 2016. Fortunes: R Fortunes. https://CRAN.R-project.org/package=fortunes.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Pacotes do R</span>"
    ]
  },
  {
    "objectID": "05-interagindo-computador-internet.html",
    "href": "05-interagindo-computador-internet.html",
    "title": "5  Interagindo com o Sistema Operacional e a Internet",
    "section": "",
    "text": "5.1 Mostrando e Mudando o Diretório de Trabalho\nAssim como outros softwares, o R sempre trabalha em algum diretório. O diretório de trabalho é onde o R procura arquivos para importar dados. É nesse mesmo diretório que o R salva arquivos, caso não definirmos um endereço no computador explicitamente. Essa saída pode ser um arquivo de uma figura, um arquivo de texto ou uma planilha eletrônica.\nEm sua inicialização, o R possui como diretório padrão a pasta de documentos do usuário cujo atalho é o tilda ('~'). Como boa prática de criação e organização de scripts, deve-se sempre mudar o diretório de trabalho para onde o arquivo do script está localizado. Isso facilita a importação e exportação de dados de arquivos. Uma forma simples e direta de mudar o diretório de trabalho é utilizar o sistema de projetos do RStudio. Toda vez que um projeto é aberto, a sessão do R automaticamente será direcionado ao diretório do projeto (veja Figure 5.1).\nFigure 5.1: Usando o sistema de projetos do RStudio\nAdicionalmente, para buscar o diretório atual de trabalho, basta utilizar a função getwd() :\n# get current directory\nmy_dir &lt;- getwd()\n\n# print it\nprint(my_dir)\n\nR&gt; [1] \"/tmp/RtmpSTKABH/book-compile__c7222ff4b456\"\nO resultado do código anterior mostra a pasta onde este livro foi escrito. Esse é o diretório onde os arquivos do livro foram compilados dentro do ambiente Linux.\nA mudança de diretório de trabalho é realizada através do comando setwd() . Por exemplo, caso quiséssemos mudar o nosso diretório de trabalho para uma pasta do Windows chamada C:/Minha pesquisa/, basta digitar no prompt:\n# set dir\nmy_d &lt;- 'C:/Minha Pesquisa/'\nsetwd(my_d)\nCaso o descobrimento da pasta de trabalho for difícil, uma estratégia eficiente é utilizar um explorador de arquivos, tal como o Explorer no Windows. Abra esse aplicativo e vá até o local onde quer trabalhar com o seu script. Após isso, coloque o cursor na barra de endereço e selecione todo o endereço. Aperte control+c para copiar o endereço para a área de transferência. Volte para o seu código e cole o mesmo no código. Atenção nesta etapa, o Windows utiliza a barra invertida para definir endereços no computador, enquanto o R utiliza a barra normal. Caso tente utilizar a barra invertida, um erro será mostrado na tela. Veja o exemplo a seguir.\nmy_d &lt;- 'C:\\Minha pesquisa\\'\nsetwd(my_d)\nO erro terá a seguinte mensagem:\nA justificativa para o erro é que a barra invertida \\ é um caractere reservado no R e não pode ser utilizado isoladamente. Caso precises, podes defini-lo no objeto de texto com dupla barra, tal como em \\\\. Veja no exemplo a seguir, onde a dupla barra é substituída por uma barra única:\n# set char with \\\nmy_char &lt;- 'using \\\\'\n\n# print it\nmessage(my_char)\n\nR&gt; using \\\nA solução do problema é simples. Após copiar o endereço, modifique todas as barras para a barra normal, assim como no código a seguir:\nmy_d &lt;- 'C:/Minha pesquisa/'\nsetwd(my_d)\nÉ possível também utilizar barras invertidas duplas \\\\ na definição de diretórios, porém não se recomenda essa formatação, pois não é compatível com outros sistemas operacionais.\nOutro ponto importante aqui é o uso de endereços relativos. Por exemplo, caso esteja trabalhando em um diretório que contém um subdiretório chamado Data, podes entrar nele com o seguinte código:\n# change to subfolder\nsetwd('Data')\nOutra possibilidade pouco conhecida no uso de setwd() é que é possível entrar em níveis inferiores do sistema de diretórios com .., tal como em:\n# change to previous level\nsetwd('..')\nPortanto, caso estejas trabalhando no diretório C:/My Research/ e executar o comando setwd('..'), o diretório atual de trabalho viraria C:/, um nível inferior a pasta C:/My Research/.\nUma maneira mais moderna e pouco conhecida de definir o diretório de trabalho é usar as funções internas do RStudio. Este é um conjunto de funções que só funcionam dentro do RStudio e fornecem diversas informações sobre o arquivo sendo editado. Para descobrir o caminho do arquivo atual que está sendo editado no RStudio e configurar o diretório de trabalho para lá, você pode escrever:\nmy_path &lt;- dirname(rstudioapi::getActiveDocumentContext()$path)\nsetwd(my_path)\nDessa forma, o script mudará o diretório para sua própria localização. Apesar de não ser um código compacto ou elegante, ele é bastante funcional. Caso copie o arquivo para outro diretório, o valor de my_path muda para o novo diretório. Esteja ciente, no entanto, de que esse truque só funciona no editor de rotinas do RStudio e dentro de um arquivo salvo. O código não funcionará a partir do prompt ou se utilizar o vscode como sua plataforma de escrita de códigos.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Interagindo com o Sistema Operacional e a Internet</span>"
    ]
  },
  {
    "objectID": "05-interagindo-computador-internet.html#mostrando-e-mudando-o-diretório-de-trabalho",
    "href": "05-interagindo-computador-internet.html#mostrando-e-mudando-o-diretório-de-trabalho",
    "title": "5  Interagindo com o Sistema Operacional e a Internet",
    "section": "",
    "text": "Error: '\\M' is an unrecognized escape in character string...\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUtilizando a pasta “Documentos”\n\n\n\nOutro truque bastante útil para definir diretórios de trabalho no R é usar o símbolo ~. Esse define a pasta 'Documentos' no Windows, a qual é única para cada usuário. No ambiente Linux e Mac, o ~ define a pasta home. Portanto, ao executar setwd('~'), irás direcionar o R a uma pasta de fácil acesso e livre modificação pelo usuário atual do computador.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Interagindo com o Sistema Operacional e a Internet</span>"
    ]
  },
  {
    "objectID": "05-interagindo-computador-internet.html#listando-arquivos-e-pastas",
    "href": "05-interagindo-computador-internet.html#listando-arquivos-e-pastas",
    "title": "5  Interagindo com o Sistema Operacional e a Internet",
    "section": "5.2 Listando Arquivos e Pastas",
    "text": "5.2 Listando Arquivos e Pastas\nPara listar arquivos do computador, basta utilizar o função list.files() ou então a alternativa do tidyverse, fs::dir_ls() . O primeiro argumento define o diretório para listar os arquivos. Na construção deste livro foi criado um diretório chamado resources/figs, onde as figuras utilizadas no livro estão salvas são salvos. Pode-se verificar os arquivos nessa pasta com o seguinte código:\n\nmy_f &lt;- fs::dir_ls(path = \"resources/figs\")\nprint(my_f[1:5])\n\nR&gt; resources/figs/CAPAdigital-AnaliseDadosR.jpg\nR&gt; resources/figs/Command_view.png\nR&gt; resources/figs/ExemploAjuda.png\nR&gt; resources/figs/Exemplo_inline_code.png\nR&gt; resources/figs/Favicon\n\n\nObserve que nesse diretório encontram-se vários arquivos com extensão .png. Destaca-se que também é possível listar os arquivos de forma recursiva, isto é, listar os arquivos de subpastas do endereço original. Para verificar, tente utilizar o seguinte código no seu computador:\n\n# list all files recursively\nfs::dir_ls(path = getwd(),  \n           recurse = TRUE)\n\nO comando anterior irá listar todos os arquivos existentes na pasta atual e subpastas de trabalho. Dependendo de onde o comando foi executado, pode levar um certo tempo para o término do processo. Caso precisar cancelar a execução, aperte esc no teclado. Caso o retorno da chamada for um objeto vazio, então é porque estás trabalhando com o R em uma pasta vazia!\nPara listar diretórios do computador, basta utilizar o comando list.dirs() ou então a função fs::dir_ls() com argumento type = \"directory\". Veja a seguir.\n\n# list directories\nmy_dirs &lt;- fs::dir_ls(\".\", type = \"directory\")\nprint(my_dirs)\n\nR&gt; EOCE-Rmd     _book        backup       gdfpd2_cache \nR&gt; gfred_cache  resources    site_libs\n\n\nNo caso anterior, o comando lista todos os diretórios do trabalho atual sem recursividade. A saída do comando mostra os diretórios que utilizei para escrever este livro. Nesse mesmo diretório, encontram-se os capítulos do livro, organizados por arquivos e baseados na linguagem Quarto. Para listar somente os arquivos com extensão .qmd, utiliza-se o argumento glob = \".qmd\" da função fs::dir_ls() , como a seguir:\n\nqmd_files &lt;- fs::dir_ls(\".\", glob = \"*.qmd$\")\n\nprint(qmd_files)\n\nR&gt; 00a-prefacio.qmd\nR&gt; 00b-agradecimentos.qmd\nR&gt; 01-introdução.qmd\nR&gt; 02-primeiros-passos-rstudio.qmd\nR&gt; 03-primeiros-passos-R.qmd\nR&gt; 04-pacotes.qmd\nR&gt; 05-interagindo-computador-internet.qmd\nR&gt; 06-objetos-basicos.qmd\nR&gt; 07-objetos-armazenamento.qmd\nR&gt; 08-importacao-exportacao-dados.qmd\nR&gt; 10-intro-programacao.qmd\nR&gt; 99-references.qmd\nR&gt; _BemVindo.qmd\nR&gt; index.qmd\n\n\nO texto *.qmd$ orienta o R a procurar todos arquivos que terminam o seu nome com o texto .qmd. Os símbolos '*'' e '$' são operadores específicos para o encontro de padrões em texto em uma linguagem chamada regex (regular expressions). O símbolo * diz para ignorar qualquer texto anterior a “.qmd” e $ indica o fim do nome do arquivo. Os arquivos apresentados anteriormente contêm todo o conteúdo deste livro, incluindo este próprio parágrafo!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Interagindo com o Sistema Operacional e a Internet</span>"
    ]
  },
  {
    "objectID": "05-interagindo-computador-internet.html#apagando-arquivos-e-diretórios",
    "href": "05-interagindo-computador-internet.html#apagando-arquivos-e-diretórios",
    "title": "5  Interagindo com o Sistema Operacional e a Internet",
    "section": "5.3 Apagando Arquivos e Diretórios",
    "text": "5.3 Apagando Arquivos e Diretórios\nA remoção de arquivos é realizada através do comando file.remove() ou então fs::file_delete() . O próximo código cria um arquivo .csv e depois o remove da memória do computador:\n\n# create temporary file in docs folder\nmy_file &lt;- '~/MyTemp.csv'\nwrite.csv(x = data.frame(x=1:10),\n          file = my_file)\n\n# delete it\nfs::file_delete(my_file)\n\nLembre-se que deves ter permissão do seu sistema operacional para apagar um arquivo.\nPara deletar diretórios e todos os seus elementos, utilizamos unlink() ou então fs::dir_delete() :\n\n# create temp dir\nname_temp &lt;- \"TEMP\"\nfs::dir_create(name_temp)\n\n# fill it with file\nmy_file &lt;- fs::path(name_temp, \"tempfile.csv\")\nwrite.csv(x = data.frame(x=1:10),\n          file = my_file)\n\nfs::dir_delete(name_temp)\n\nA função, neste caso, não retorna nada. Podes checar se o diretório existe com fs::dir_exists() :\n\nfs::dir_exists(name_temp)\n\nR&gt;  TEMP \nR&gt; FALSE\n\n\n\n\n\n\n\n\nCuidado com a remoção de arquivos e diretórios!\n\n\n\nTenha muito cuidado com comandos de remover pastas e arquivos no R, principalmente quando utilizar recursividade, isto é, quanto apagar todas as pastas e arquivos existentes no caminho desejado. Uma execução errada e partes importantes do seu disco rígido podem ser apagadas, deixando o seu computador inoperável. Saiba que o R realmente apaga os arquivos e não somente manda para a lixeira. Portanto, ao apagar diretórios inteiros, não poderás recuperar os arquivos facilmente.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Interagindo com o Sistema Operacional e a Internet</span>"
    ]
  },
  {
    "objectID": "05-interagindo-computador-internet.html#utilizando-arquivos-e-diretórios-temporários",
    "href": "05-interagindo-computador-internet.html#utilizando-arquivos-e-diretórios-temporários",
    "title": "5  Interagindo com o Sistema Operacional e a Internet",
    "section": "5.4 Utilizando Arquivos e Diretórios Temporários",
    "text": "5.4 Utilizando Arquivos e Diretórios Temporários\nToda vez que uma nova sessão do R é inicializada, o programa automaticamente cria uma pasta temporária no seu sistema. É nesse diretório que o R guarda quaisquer arquivos e pastas descartáveis que possam ser necessárias na sua sessão. No momento que a sessão do R é finalizada, tal como quando fechamos o RStudio, as pastas temporárias são removidas da memória do computador.\nO endereço do diretório temporário de uma sessão do R é verificado com tempdir() ou fs::path_temp() :\n\nmy_tempdir &lt;- fs::path_temp()\nmessage(stringr::str_glue('My tempdir is {my_tempdir}'))\n\nR&gt; My tempdir is /tmp/RtmpLxVikW\n\n\nO último texto do diretório, neste caso RtmpLxVikW é aleatóriamente definido e irá trocar a cada nova sessão do R.\nA mesma dinâmica é encontrada para nomes de arquivos. Caso queira, por algum motivo, utilizar um nome temporário e aleatório para algum arquivo com extensão .txt, utilize tempfile() ou fs::file_temp() e defina o tipo de arquivo com as entradas da função:\n\nmy_tempfile &lt;- fs::file_temp(ext = '.txt')\nmessage(my_tempfile)\n\nR&gt; /tmp/RtmpLxVikW/filed95913892218.txt\n\n\nNote que o nome do arquivo – filed95913892218.txt – é totalmente aleatório e mudará a cada chamada da função. Note também que o arquivo temporário está localizado na pasta /tmp/RtmpLxVikW.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Interagindo com o Sistema Operacional e a Internet</span>"
    ]
  },
  {
    "objectID": "05-interagindo-computador-internet.html#baixando-arquivos-da-internet",
    "href": "05-interagindo-computador-internet.html#baixando-arquivos-da-internet",
    "title": "5  Interagindo com o Sistema Operacional e a Internet",
    "section": "5.5 Baixando Arquivos da Internet",
    "text": "5.5 Baixando Arquivos da Internet\nO R pode baixar arquivos da Internet diretamente no código. Isso é realizado com a função download.file() . Veja o exemplo a seguir, onde baixamos uma planilha de Excel do site da Microsoft, e salvamos em um arquivo temporário:\n\n# set link\nlink_dl &lt;- 'go.microsoft.com/fwlink/?LinkID=521962'\nlocal_file &lt;- fs::file_temp(ext = '.xlsx') # name of local file\n\ndownload.file(url = link_dl,\n              destfile = local_file)\n\nO uso de download.file() é bastante prático quando se está trabalhando com dados da Internet que são constantemente atualizados. Basta baixar e atualizar o arquivo com dados no início do script. Poderíamos continuar a rotina lendo o arquivo baixado e realizando a nossa análise dos dados disponíveis.\nUm exemplo nesse caso é a tabela de empresas listadas na bolsa divulgada pela CVM (comissão de valores mobiliários). A tabela está disponível em um arquivo no site. Podemos baixar o arquivo e, logo em seguida, ler os dados.\n\n# set destination link and file\nmy_link &lt;- 'http://dados.cvm.gov.br/dados/CIA_ABERTA/CAD/DADOS/cad_cia_aberta.csv'\nmy_destfile &lt;- fs::file_temp(ext = '.csv')\n\n# download file\ndownload.file(my_link, \n              destfile = my_destfile, \n              mode = \"wb\")\n\n# read it\ndf_cvm &lt;- readr::read_csv2(my_destfile,\n                     #delim = '\\t',\n                     locale = readr::locale(encoding = 'Latin1'),\n                     col_types = readr::cols())\n\nR&gt; ℹ Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n\n# check available columns\nprint(names(df_cvm))\n\nR&gt;  [1] \"CNPJ_CIA\"           \"DENOM_SOCIAL\"      \nR&gt;  [3] \"DENOM_COMERC\"       \"DT_REG\"            \nR&gt;  [5] \"DT_CONST\"           \"DT_CANCEL\"         \nR&gt;  [7] \"MOTIVO_CANCEL\"      \"SIT\"               \nR&gt;  [9] \"DT_INI_SIT\"         \"CD_CVM\"            \nR&gt; [11] \"SETOR_ATIV\"         \"TP_MERC\"           \nR&gt; [13] \"CATEG_REG\"          \"DT_INI_CATEG\"      \nR&gt; [15] \"SIT_EMISSOR\"        \"DT_INI_SIT_EMISSOR\"\nR&gt; [17] \"CONTROLE_ACIONARIO\" \"TP_ENDER\"          \nR&gt; [19] \"LOGRADOURO\"         \"COMPL\"             \nR&gt; [21] \"BAIRRO\"             \"MUN\"               \nR&gt; [23] \"UF\"                 \"PAIS\"              \nR&gt; [25] \"CEP\"                \"DDD_TEL\"           \nR&gt; [27] \"TEL\"                \"DDD_FAX\"           \nR&gt; [29] \"FAX\"                \"EMAIL\"             \nR&gt; [31] \"TP_RESP\"            \"RESP\"              \nR&gt; [33] \"DT_INI_RESP\"        \"LOGRADOURO_RESP\"   \nR&gt; [35] \"COMPL_RESP\"         \"BAIRRO_RESP\"       \nR&gt; [37] \"MUN_RESP\"           \"UF_RESP\"           \nR&gt; [39] \"PAIS_RESP\"          \"CEP_RESP\"          \nR&gt; [41] \"DDD_TEL_RESP\"       \"TEL_RESP\"          \nR&gt; [43] \"DDD_FAX_RESP\"       \"FAX_RESP\"          \nR&gt; [45] \"EMAIL_RESP\"         \"CNPJ_AUDITOR\"      \nR&gt; [47] \"AUDITOR\"\n\n\nExistem diversas informações interessantes nestes dados incluindo nome e CNPJ de empresas listadas (ou de-listadas) da bolsa de valores Brasileira. E, mais importante, o arquivo está sempre atualizado. O código anterior estará sempre buscando os dados mais recentes a cada execução.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Interagindo com o Sistema Operacional e a Internet</span>"
    ]
  },
  {
    "objectID": "05-interagindo-computador-internet.html#interagindo-com-apis",
    "href": "05-interagindo-computador-internet.html#interagindo-com-apis",
    "title": "5  Interagindo com o Sistema Operacional e a Internet",
    "section": "5.6 Interagindo com APIs",
    "text": "5.6 Interagindo com APIs\nAs APIs (Application Programming Interfaces) são sistemas que permitem a iteração entre diferentes softwares. O caso mais comum é um sistema local, seu computador, requisitando algum serviço da internet. As aplicações do uso de API com o R são imensas:\n\nAcesso a dados: APIs fornecem acesso a uma grande variedade de dados, desde informações climáticas e notícias até dados de mercado e APIs de redes sociais.\nIntegração com outras ferramentas: APIs permitem integrar o R com outras ferramentas, como dashboards, plataformas de análise e sistemas de BI.\nAutomação de tarefas: APIs podem ser usadas para automatizar tarefas repetitivas, como a coleta de dados ou a geração de relatórios.\n\nAqui, vamos apresentar um exemplo simples de requisição de dados de um API do tipo json. O site https://api.sampleapis.com apresenta um API para requisição de um banco de dados atualizado sobre cervejas. Para importar os dados, é muito simples, basta usar função jsonlite::fromJSON() com o endereço do API.\n\nurl &lt;- \"https://api.sampleapis.com/beers/stouts\"\n\ndf_beer &lt;- jsonlite::fromJSON(url)\n\nhead(df_beer)\n\nR&gt;     price                                    name\nR&gt; 1  $29.99                            Founders CBS\nR&gt; 2  $26.99 Founders KBS (Kentucky Breakfast Stout)\nR&gt; 3   $9.99                Founders Breakfast Stout\nR&gt; 4 $249.99                           Prairie BOMB!\nR&gt; 5  $15.99                    Oskar Blues Ten FIDY\nR&gt; 6  $12.99                 Founders Imperial Stout\nR&gt;   rating.average rating.reviews\nR&gt; 1       1.349809            105\nR&gt; 2       3.319229            135\nR&gt; 3       4.020476            199\nR&gt; 4       3.588323            288\nR&gt; 5       1.554664            125\nR&gt; 6       1.669031            350\nR&gt;                                                                            image\nR&gt; 1 https://www.totalwine.com/media/sys_master/twmmedia/hfb/h90/10682638663710.png\nR&gt; 2  https://www.totalwine.com/media/sys_master/twmmedia/haa/h27/8819208028190.png\nR&gt; 3  https://www.totalwine.com/media/sys_master/twmmedia/ha2/he2/8796687728670.png\nR&gt; 4 https://www.totalwine.com/media/sys_master/twmmedia/h0b/h40/10608572923934.png\nR&gt; 5 https://www.totalwine.com/media/sys_master/twmmedia/hc1/h8e/11465945481246.png\nR&gt; 6  https://www.totalwine.com/media/sys_master/twmmedia/h75/hd7/8809528655902.png\nR&gt;   id\nR&gt; 1  1\nR&gt; 2  2\nR&gt; 3  3\nR&gt; 4  4\nR&gt; 5  5\nR&gt; 6  6\n\n\nOs dados retornamos já estão no formato de tabela (dataframe), com 117 linhas e 5 colunas. As informações incluem preço, nome, rating, e imagem.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Interagindo com o Sistema Operacional e a Internet</span>"
    ]
  },
  {
    "objectID": "05-interagindo-computador-internet.html#exercícios",
    "href": "05-interagindo-computador-internet.html#exercícios",
    "title": "5  Interagindo com o Sistema Operacional e a Internet",
    "section": "5.7 Exercícios",
    "text": "5.7 Exercícios\n\nQ.1 - Crie um novo e mostre no prompt o diretório atual de trabalho (veja função getwd() , tal como em print(getwd())). Agora, modifique o seu diretório de trabalho para o Desktop (Área de Trabalho) e mostre a seguinte mensagem na tela do prompt: 'My desktop address is ....'. Dica: use e abuse da ferramenta autocomplete do RStudio para rapidamente encontrar a pasta do desktop.\n\nQ.2 - Utilize o R para baixar o arquivo compactado disponível neste link. Salve o mesmo como um arquivo na pasta temporária da sessão (veja função fs::file_temp) e com a correta extensão zip.\n\nQ.3 - Após resolver a questão anterior, utilize o R para descompactar o arquivo baixado para uma pasta temporária. Quantos arquivos estão disponíveis no arquivo compactado?\n\n5\n7\n3\n2\n4\n\n\nQ.4 - O comando Sys.getenv ('R_LIBS_USER') retorna a pasta onde o R guarda todos os arquivos dos diferente pacotes. Use função fs::dir_ls para listar todas as subpastas do diretório anterior.\n\nQ.5 - O site https://sampleapis.com/ possui um API aberto ao público para a importação de dados sobre a série Futurama. Com base no seu conhecimento de R, baixe a lista de episódios da série utilizando o serviço do site. Quantas episódios estão disponíveis nos dados?",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Interagindo com o Sistema Operacional e a Internet</span>"
    ]
  },
  {
    "objectID": "06-objetos-basicos.html",
    "href": "06-objetos-basicos.html",
    "title": "6  As Classes Básicas de Objetos",
    "section": "",
    "text": "6.1 Objetos Numéricos\nUma das classes mais utilizadas no R. Os valores numéricos são representações de uma quantidade. Por exemplo: o preço de uma ação em determinada data, o volume negociado de um contrato financeiro em determinado dia, a inflação anual de um país, entre várias outras possibilidades.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>As Classes Básicas de Objetos</span>"
    ]
  },
  {
    "objectID": "06-objetos-basicos.html#objetos-numéricos",
    "href": "06-objetos-basicos.html#objetos-numéricos",
    "title": "6  As Classes Básicas de Objetos",
    "section": "",
    "text": "6.1.1 Criando e Manipulando Vetores Numéricos\nA criação e manipulação de valores numéricos é fácil e direta. Os símbolos de operações matemáticas seguem o esperado, tal como soma (+), diminuição (-), divisão (/) e multiplicação (*). Todas as operações matemáticas são efetuadas com a orientação de elemento para elemento e possuem notação vetorial. Isso significa, por exemplo, que podemos manipular vetores inteiros em uma única linha de comando. Veja a seguir, onde se cria dois vetores e realiza-se diversas operações entre eles.\n\n# create numeric vectors\nx &lt;- 1:5\ny &lt;- 2:6\n\n# print sum\nprint(x+y)\n\nR&gt; [1]  3  5  7  9 11\n\n# print multiplication\nprint(x*y)\n\nR&gt; [1]  2  6 12 20 30\n\n# print division\nprint(x/y)\n\nR&gt; [1] 0.5000000 0.6666667 0.7500000 0.8000000 0.8333333\n\n# print exponentiation\nprint(x^y)\n\nR&gt; [1]     1     8    81  1024 15625\n\n\nUm diferencial do R em relação a outras linguagens é que, nele, são aceitas operações entre vetores diferentes. Por exemplo, podemos somar um vetor numérico de quatro elementos com outro de apenas dois. Nesse caso, aplica-se a chamada regra de reciclagem (recycling rule). Ela define que, se dois vetores de tamanho diferente estão interagindo, o vetor menor é repetido tantas vezes quantas forem necessárias para obter-se o mesmo número de elementos do vetor maior. Veja o exemplo a seguir:\n\n# set x with 4 elements and y with 2\nx &lt;- 1:4\ny &lt;- 2:1\n\n# print sum\nprint(x + y)\n\nR&gt; [1] 3 3 5 5\n\n\nO resultado de x + y é equivalente a 1:4 + c(2, 1, 2, 1). Caso interagirmos vetores em que o tamanho do maior não é múltiplo do menor, o R realiza o mesmo procedimento de reciclagem, porém emite uma mensagem de warning:\n\n# set x = 4 elements and y with 3\nx &lt;- c(1, 2, 3, 4)\ny &lt;- c(1, 2, 3)\n\n# print sum (recycling rule)\nprint(x +y)\n\nR&gt; Warning in x + y: longer object length is not a multiple of\nR&gt; shorter object length\n\n\nR&gt; [1] 2 4 6 5\n\n\nOs três primeiros elementos de x foram somados aos três primeiros elementos de y. O quarto elemento de x foi somado ao primeiro elemento de y. Uma vez que não havia um quarto elemento em y, o ciclo reinicia, resgatando o primeiro elemento de y e resultando em uma soma igual a 5.\nOs elementos de um vetor numérico também podem ser nomeados quando na criação do vetor:\n\n# create named vector\nx &lt;- c(item1 = 10,\n       item2 = 14,\n       item3 = 9,\n       item4 = 2)\n\n# print it\nprint(x)\n\nR&gt; item1 item2 item3 item4 \nR&gt;    10    14     9     2\n\n\nPara nomear os elementos após a criação, podemos utilizar a função names() . Veja a seguir:\n\n# create unnamed vector\nx &lt;- c(10, 14, 9, 2)\n\n# set names of elements\nnames(x) &lt;- c('item1', 'item2', 'item3', 'item4')\n\n# print it\nprint(x)\n\nR&gt; item1 item2 item3 item4 \nR&gt;    10    14     9     2\n\n\nVetores numéricos vazios também podem ser criados. Em algumas situações de desenvolvimento de código faz sentido pré-alocar o vetor antes de preenchê-lo com valores. Nesse caso, utilize a função numeric() :\n\n# create empty numeric vector of length 10\nmy_x &lt;- numeric(length = 10)\n\n# print it\nprint(my_x)\n\nR&gt;  [1] 0 0 0 0 0 0 0 0 0 0\n\n\nObserve que, nesse caso, os valores de my_x são definidos como zero.\n\n6.1.1.1 Criando Sequências de Valores\nExistem duas maneiras de criar uma sequência de valores no R. A primeira, que já foi utilizada nos exemplos anteriores, é o uso do operador :, tal como em my_seq &lt;- 1:10 e my_seq &lt;- -5:5. Esse método é bastante prático, pois a notação é clara e direta.\nPorém, o uso do operador : limita as possibilidades. A diferença entre os valores adjacentes é sempre 1 para sequências ascendentes e -1 para sequências descendentes. Função seq() é uma versão mais poderosa do operador :, possibilitando sequências customizadas com argumento by.\n\n# set sequence from -10 to 10, by 2 \nmy_seq &lt;- seq(from = -10, to = 10, by = 2)\n\n# print it\nprint(my_seq)\n\nR&gt;  [1] -10  -8  -6  -4  -2   0   2   4   6   8  10\n\n\nOutro atributo interessante da função seq() é a possibilidade de criar vetores com um valor inicial, um valor final e o número de elementos desejado. Isso é realizado com o uso da opção length.out. Observe o código a seguir, onde cria-se um vetor de 0 até 10 com 20 elementos:\n\n# set sequence with fixed size\nmy_seq &lt;- seq(from = 0, to = 10, length.out = 20)\n\n# print it\nprint(my_seq)\n\nR&gt;  [1]  0.0000000  0.5263158  1.0526316  1.5789474  2.1052632\nR&gt;  [6]  2.6315789  3.1578947  3.6842105  4.2105263  4.7368421\nR&gt; [11]  5.2631579  5.7894737  6.3157895  6.8421053  7.3684211\nR&gt; [16]  7.8947368  8.4210526  8.9473684  9.4736842 10.0000000\n\n\nNo caso anterior, o tamanho final do vetor foi definido e a própria função se encarregou de descobrir qual a variação necessária entre cada valor de my_seq.\n\n\n6.1.1.2 Criando Vetores com Elementos Repetidos\nOutra função interessante é a que cria vetores com o uso de repetição. Por exemplo: imagine que estamos interessado em um vetor preenchido com o valor 1 dez vezes. Para isso, basta utilizar a função rep() :\n\n# repeat vector three times\nmy_x &lt;- rep(x = 1, times = 10)\n\n# print it\nprint(my_x)\n\nR&gt;  [1] 1 1 1 1 1 1 1 1 1 1\n\n\nA função também funciona com vetores. Considere uma situação onde temos um vetor com os valores c(1,2) e gostaríamos de criar um vetor maior com os elementos c(1, 2, 1, 2, 1, 2) - isto é, repetindo o vetor menor três vezes. Veja o resultado a seguir:\n\n# repeat vector three times\nmy_x &lt;- rep(x = c(1, 2), times = 3)\n\n# print it\nprint(my_x)\n\nR&gt; [1] 1 2 1 2 1 2\n\n\n\n\n6.1.1.3 Criando Vetores com Números Aleatórios\nEm muitas situações será necessário a criação de números aleatórios. Esse procedimento numérico é bastante utilizado para simular modelos matemáticos em Finanças. Por exemplo, o método de simulação de preços de ativos de Monte Carlo parte da simulação de números aleatórios (McLeish 2011). No R, existem diversas funções que criam números aleatórios para diferentes distribuições estatísticas. As mais utilizadas, porém, são as funções rnorm() e runif() .\nA função rnorm() gera números aleatórios da distribuição Normal, com opções para a média (tendência) e o desvio padrão (variabilidade). Veja o seu uso a seguir:\n\n# generate 10000 random numbers from a Normal distribution\nmy_rnd_vec &lt;- rnorm(n = 10000,\n                    mean = 0,\n                    sd = 1)\n\n# print first 20 elements\nprint(my_rnd_vec[1:20])\n\nR&gt;  [1]  0.7183573 -0.4323095  0.8732910  0.3038258 -0.9903015\nR&gt;  [6]  1.0563647  0.6104315  0.8816475  0.8042165  1.0417182\nR&gt; [11] -0.2741214 -1.0241149  0.7873664 -0.3595144  1.1126881\nR&gt; [16]  0.7623427 -0.6837628 -0.2864175 -0.1282310 -0.5121757\n\n\nO código anterior gera uma grande quantidade de números aleatórios de uma distribuição Normal com média zero e desvio padrão igual a um.\nFunção runif() também gera valores aleatórios, porém da distribuição uniforme e dentro de um intervalor. Ela é geralmente utilizada para simular probabilidades, valores entre 0 e 1. A função runif() tem três parâmetros de entrada: o número de valores aleatórios desejado, o valor mínimo e o valor máximo. Veja exemplo a seguir:\n\n# create a random vector with minimum and maximum\nmy_rnd_vec &lt;- runif(n = 5,\n                    min = -5,\n                    max = 5)\n\n# print it\nprint(my_rnd_vec)\n\nR&gt; [1]  1.522490  4.829018 -1.761385  4.677146  4.069865\n\n\nObserve que ambas as funções anteriores são limitadas à suas respectivas distribuições. Uma maneira alternativa e flexível de gerar valores aleatórios é utilizar a função sample() . Essa tem como entrada um vetor qualquer e retorna uma versão embaralhada de seus elementos. A sua flexibilidade reside no fato de que o vetor de entrada pode ser qualquer coisa. Por exemplo, caso quiséssemos criar um vetor aleatório com os números c(0, 5, 15, 20, 25) apenas, poderíamos fazê-lo da seguinte forma:\n\n# create sequence\nmy_vec &lt;- seq(from = 0, to = 25, by=5)\n\n# sample sequence\nmy_rnd_vec &lt;- sample(my_vec)\n\n# print it\nprint(my_rnd_vec)\n\nR&gt; [1] 20  0 10 25 15  5\n\n\nA função sample() também permite a seleção aleatória de um certo número de termos. Por exemplo, caso quiséssemos selecionar aleatoriamente apenas um elemento de my_vec, escreveríamos o código da seguinte maneira:\n\n# sample one element of my_vec\nmy_rnd_vec &lt;- sample(my_vec, size = 1)\n\n# print it\nprint(my_rnd_vec)\n\nR&gt; [1] 10\n\n\nCaso quiséssemos dois elementos, escreveríamos:\n\n# sample two elements of my_vec\nmy_rnd_vec &lt;- sample(my_vec, size = 2)\n\n# print it\nprint(my_rnd_vec)\n\nR&gt; [1] 10 25\n\n\nTambém é possível selecionar valores de uma amostra menor para a criação de um vetor maior. Por exemplo, considere o caso em que se tem um vetor com os números c(10, 15, 20) e deseja-se criar um vetor aleatório com dez elementos retirados desse vetor menor, com repetição. Para isso, podemos utilizar a opção replace = TRUE.\n\n# create vector\nmy_vec &lt;- c(5, 10, 15)\n\n# sample\nmy_rnd_vec &lt;- sample(x = my_vec, size = 10, replace = TRUE)\nprint(my_rnd_vec)\n\nR&gt;  [1] 15 10  5 10  5  5  5  5  5 10\n\n\nVale destacar que a função sample() funciona para qualquer tipo ou objeto, não sendo, portanto, exclusiva para vetores numéricos. Poderíamos, também, escolher elementos aleatórios de um vetor de texto ou então uma lista:\n\n# example of sample with characters\nprint(sample(c('elem 1', 'elem 2', 'elem 3'),\n             size = 1))\n\nR&gt; [1] \"elem 2\"\n\n# example of sample with list\nprint(sample(list(x = c(1,1,1),\n                  y = c('a', 'b')),\n             size = 1))\n\nR&gt; $y\nR&gt; [1] \"a\" \"b\"\n\n\nÉ importante ressaltar que a geração de valores aleatórios no R (ou qualquer outro programa) não é totalmente aleatória! De fato, o próprio computador escolhe os valores dentre uma fila de valores possíveis. Cada vez que funções tal como rnorm() , runif() e sample() são utilizadas, o computador escolhe um lugar diferente dessa fila de acordo com vários parâmetros, incluindo a data e o horário atual do sistema. Portanto, do ponto de vista do usuário, os valores são gerados de forma imprevisível. Para o computador, porém, essa seleção é determinística e previsível.\nUma possibilidade interessante no R é selecionar uma posição específica na fila de valores aleatórios utilizando função set.seed() . É ela que fixa a semente para gerar os valores. Na prática, o resultado é que todos os números e seleções aleatórias realizadas pelo código serão iguais em cada execução, independente do computador ou horário. O uso de set.seed() é bastante recomendado para manter a reprodutibilidade dos códigos envolvendo aleatoriedade. Veja o exemplo a seguir, onde utiliza-se essa função.\n\n# fix seed\nset.seed(seed = 10)\n\n# set vec and print\nmy_rnd_vec_1 &lt;- runif(5)\nprint(my_rnd_vec_1)\n\nR&gt; [1] 0.50747820 0.30676851 0.42690767 0.69310208 0.08513597\n\n# set vec and print\nmy_rnd_vec_2 &lt;- runif(5)\nprint(my_rnd_vec_2)\n\nR&gt; [1] 0.2254366 0.2745305 0.2723051 0.6158293 0.4296715\n\n\nNo código anterior, o valor de set.seed() é um inteiro escolhido pelo usuário. Após a chamada de set.seed() , todas as seleções e números aleatórios irão iniciar do mesmo ponto e, portanto, serão iguais. Motivo o leitor a executar o código anterior em sua sessão do R. Verás que os valores de my_rnd_vec_1 e my_rnd_vec_2 serão exatamente iguais aos valores colocados aqui.\nO uso de set.seed() também funciona para o caso de sample() . Veja a seguir:\n\n# fix seed\nset.seed(seed = 15)\n\n# print vectors\nprint(sample(1:10))\n\nR&gt;  [1]  5  2  1  6  8 10  3  7  9  4\n\nprint(sample(10:20))\n\nR&gt;  [1] 13 15 10 17 20 14 19 12 11 18 16\n\n\nNovamente, execute os comandos anteriores no R e verás que o resultado na tela bate com o apresentado aqui.\n\n\n\n6.1.2 Acessando Elementos de um Vetor Numérico\nTodos os elementos de um vetor numérico podem ser acessados através do uso de colchetes ([ ]). Por exemplo, caso quiséssemos apenas o primeiro elemento de x, teríamos:\n\n# set vector\nx &lt;- c(-1, 4, -9, 2)\n\n# get first element\nfirst_elem_x &lt;- x[1]\n\n# print it\nprint(first_elem_x)\n\nR&gt; [1] -1\n\n\nA mesma notação é válida para extrair porções de um vetor. Caso quiséssemos um subvetor de x com o primeiro e o segundo elemento, faríamos essa operação da seguinte forma:\n\n# sub-vector of x\nsub_x &lt;- x[1:2]\n\n# print it\nprint(sub_x)\n\nR&gt; [1] -1  4\n\n\nPara acessar elementos nomeados de um vetor numérico, basta utilizar seu nome junto aos colchetes.\n\n# set named vector\nx &lt;- c(item1 = 10, item2 = 14, item3 = -9, item4 = -2)\n\n# access elements by name\nprint(x['item2'])\n\nR&gt; item2 \nR&gt;    14\n\nprint(x[c('item2','item4')])\n\nR&gt; item2 item4 \nR&gt;    14    -2\n\n\nO acesso aos elementos de um vetor numérico também é possível através de testes lógicos. Por exemplo, caso tivéssemos interesse em saber quais os valores de x que são maiores do que 0, o código resultante seria da seguinte forma:\n\n# find all values of x higher than zero\nprint(x[x &gt; 0])\n\nR&gt; item1 item2 \nR&gt;    10    14\n\n\nOs usos de regras de segmentação dos dados de acordo com algum critério é chamado de indexação lógica. Os objetos do tipo logical serão tratados mais profundamente em seção futura deste capítulo.\n\n\n6.1.3 Modificando e Removendo Elementos de um Vetor Numérico\nA modificação de um vetor numérico é muito simples. Basta indicar a posição dos elementos e os novos valores com o símbolo de assign (&lt;-):\n\n# set vector\nmy_x &lt;- 1:4\n\n# modify first element to 5\nmy_x[1] &lt;- 5\n\n# print result\nprint(my_x)\n\nR&gt; [1] 5 2 3 4\n\n\nEssa modificação também pode ser realizada em bloco:\n\n# set vector\nmy_x &lt;- 0:5\n\n# set the first three elements to 5\nmy_x[1:3] &lt;- 5\n\n# print result\nprint(my_x)\n\nR&gt; [1] 5 5 5 3 4 5\n\n\nO uso de condições para definir elementos é realizada pela indexação:\n\n# set vector\nmy_x &lt;- -5:5\n\n# set any value lower than 2 to 0\nmy_x[my_x&lt;2] &lt;- 0\n\n# print result\nprint(my_x)\n\nR&gt;  [1] 0 0 0 0 0 0 0 2 3 4 5\n\n\nA remoção de elementos é realizada com o uso de índices negativos:\n\n# create vector\nmy_x &lt;- -5:5\n\n# remove first and second element of my_x\nmy_x &lt;- my_x[-(1:2)]\n\n# show result\nprint(my_x)\n\nR&gt; [1] -3 -2 -1  0  1  2  3  4  5\n\n\nNote como o uso do índice negativo em my_x[-(1:2)] retorna o vetor original sem o primeiro e segundo elemento.\n\n\n6.1.4 Criando Grupos\nAlgumas situações de análise de dados requerem que grupos numéricos sejam identificados. Por exemplo, imagine um conjunto de idades de pessoas em determinada cidade. Uma possível análise seria dividir as idades em intervalos, e verificar o percentual de ocorrência dos valores em cada um destes. Esta análise numérica é bastante semelhante à construção e visualização de histogramas.\nA função cut() serve para criar grupos de intervalos a partir de um vetor numérico. Veja o exemplo a seguir, onde cria-se um vetor aleatório oriundo da distribuição Normal e cinco grupos a partir de intervalos definidos pelos dados.\n\n# set rnd vec\nmy_x &lt;- rnorm(10)\n\n# \"cut\" it into 5 pieces\nmy_cut &lt;- cut(x = my_x, breaks = 5)\nprint(my_cut)\n\nR&gt;  [1] (-1.57,-1.12]  (0.252,0.71]   (-1.12,-0.66] \nR&gt;  [4] (-0.204,0.252] (-0.66,-0.204] (-1.57,-1.12] \nR&gt;  [7] (0.252,0.71]   (-0.204,0.252] (0.252,0.71]  \nR&gt; [10] (-0.204,0.252]\nR&gt; 5 Levels: (-1.57,-1.12] (-1.12,-0.66] ... (0.252,0.71]\n\n\nObserve que os nomes dos elementos da variável my_cut são definidos pelos intervalos e o resultado é um objeto do tipo fator. Em seções futuras, iremos explicar melhor esse tipo de objeto e as suas propriedades.\nNo exemplo anterior, os intervalos para cada grupo foram definidos automaticamente. No uso da função cut() , também é possível definir quebras customizadas nos dados e nos nomes dos grupos. Veja a seguir:\n\n# set random vector\nmy_x &lt;- rnorm(10)\n\n# create groups with 5 breaks\nmy_cut &lt;- cut(x = my_x, breaks = 5)\n\n# print it!\nprint(my_cut)\n\nR&gt;  [1] (-1.3,-0.3]  (-0.3,0.697] (-0.3,0.697] (-2.3,-1.3] \nR&gt;  [5] (-0.3,0.697] (0.697,1.69] (0.697,1.69] (0.697,1.69]\nR&gt;  [9] (-1.3,-0.3]  (1.69,2.7]  \nR&gt; 5 Levels: (-2.3,-1.3] (-1.3,-0.3] ... (1.69,2.7]\n\n\nNote que os nomes dos elementos em my_cut foram definidos como intervalos e o resultado é um objeto do tipo fator. É possível também definir intervalos e nomes customizados para cada grupo com o uso dos argumentos labels e breaks:\n\n# create random vector\nmy_x &lt;- rnorm(10)\n\n# define breaks manually\nmy_breaks &lt;- c(min(my_x)-1, -1, 1, max(my_x)+1)\n\n# define labels manually\nmy_labels &lt;- c('Low','Normal', 'High')\n\n# create group from numerical vector\nmy_cut &lt;- cut(x = my_x, breaks = my_breaks, labels = my_labels)\n\n# print both!\nprint(my_x)\n\nR&gt;  [1]  0.5981759  1.6113647 -0.4373813  1.3526206  0.4705685\nR&gt;  [6]  0.4702481  0.3963088 -0.7304926  0.6531176  1.2279598\n\nprint(my_cut)\n\nR&gt;  [1] Normal High   Normal High   Normal Normal Normal Normal\nR&gt;  [9] Normal High  \nR&gt; Levels: Low Normal High\n\n\nComo podemos ver, os nomes dos grupos estão mais amigáveis para uma futura análise. Adicionalmente, uma função muito útil para contar o número de casos é table() :\n\n# print count\ntable(my_cut)\n\nR&gt; my_cut\nR&gt;    Low Normal   High \nR&gt;      0      7      3\n\n\n\n\n6.1.5 Outras Funções Úteis\nas.numeric() - Converte determinado objeto para numérico.\n\nmy_text &lt;- c('1', '2', '3')\nclass(my_text)\n\nR&gt; [1] \"character\"\n\nmy_x &lt;- as.numeric(my_text)\nprint(my_x)\n\nR&gt; [1] 1 2 3\n\nclass(my_x)\n\nR&gt; [1] \"numeric\"\n\n\nsum() - Soma os elementos de um vetor.\n\nmy_x &lt;- 1:50\nmy_sum &lt;- sum(my_x)\nprint(my_sum)\n\nR&gt; [1] 1275\n\n\nmax() - Retorna o máximo valor numérico do vetor.\n\nx &lt;- c(10, 14, 9, 2)\nmax_x &lt;- max(x)\nprint(max_x)\n\nR&gt; [1] 14\n\n\nmin() - Retorna o mínimo valor numérico do vetor.\n\nx &lt;- c(12, 15, 9, 2)\nmin_x &lt;- min(x)\nprint(min_x)\n\nR&gt; [1] 2\n\n\nwhich.max() - Retorna a posição do máximo valor numérico do vetor.\n\nx &lt;- c(100, 141, 9, 2)\nwhich.max_x &lt;- which.max(x)\n\ncat(paste('The position of the maximum value of x is ', which.max_x))\n\nR&gt; The position of the maximum value of x is  2\n\ncat(' and its value is ', x[which.max_x])\n\nR&gt;  and its value is  141\n\n\nwhich.min() - Retorna a posição do mínimo valor numérico do vetor.\n\nx &lt;- c(10, 14, 9, 2)\nwhich.min_x &lt;- which.min(x)\n\ncat(paste('The position of the minimum value of x is ',\n          which.min_x, ' and its value is ', x[which.min_x]))\n\nR&gt; The position of the minimum value of x is  4  and its value is  2\n\n\nsort() - Retorna uma versão ordenada de um vetor.\n\nx &lt;- runif(5)\n\nprint(sort(x, decreasing = FALSE))\n\nR&gt; [1] 0.1623069 0.8347800 0.8553657 0.9099027 0.9935257\n\nprint(sort(x, decreasing = TRUE))\n\nR&gt; [1] 0.9935257 0.9099027 0.8553657 0.8347800 0.1623069\n\n\ncumsum() - Soma os elementos de um vetor de forma cumulativa.\n\nmy_x &lt;- 1:25\nmy_cumsum &lt;- cumsum(my_x)\nprint(my_cumsum)\n\nR&gt;  [1]   1   3   6  10  15  21  28  36  45  55  66  78  91 105\nR&gt; [15] 120 136 153 171 190 210 231 253 276 300 325\n\n\nprod() - Realiza o produto de todos os elementos de um vetor.\n\nmy_x &lt;- 1:10\nmy_prod &lt;- prod(my_x)\nprint(my_prod)\n\nR&gt; [1] 3628800\n\n\ncumprod() - Calcula o produto cumulativo de todos os elementos de um vetor.\n\nmy_x &lt;- 1:10\nmy_prod &lt;- cumprod(my_x)\nprint(my_prod)\n\nR&gt;  [1]       1       2       6      24     120     720    5040\nR&gt;  [8]   40320  362880 3628800",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>As Classes Básicas de Objetos</span>"
    ]
  },
  {
    "objectID": "06-objetos-basicos.html#classe-de-caracteres-texto",
    "href": "06-objetos-basicos.html#classe-de-caracteres-texto",
    "title": "6  As Classes Básicas de Objetos",
    "section": "6.2 Classe de Caracteres (texto)",
    "text": "6.2 Classe de Caracteres (texto)\nA classe de caracteres, ou texto, serve para armazenar informações textuais. Um exemplo prático seria analisar os tweets de determinada personalidade ao longo do tempo. Este tipo de dado tem sido utilizado cada vez mais em pesquisa empírica (Gentzkow, Kelly, and Taddy 2017), resultando em uma diversidade de pacotes.\nO R possui vários recursos que facilitam a criação e manipulação de objetos de tipo texto. As funções básicas fornecidas com a instalação de R são abrangentes e adequadas para a maioria dos casos. No entanto, pacote {stringr} (Wickham 2023b) do universo {tidyverse} (Wickham 2023c) fornece muitas funções que expandem as funcionalidades básicas do R.\nUm aspecto positivo de {stringr} (Wickham 2023b) é que as funções começam com o nome str_ e possuem nomes informativos. Combinando isso com o recurso de preenchimento automático (autocomplete) pela tecla tab, fica fácil de localizar os nomes das funções do pacote. Seguindo a prioridade ao universo do {tidyverse} (Wickham 2023c), esta seção irá dar preferência ao uso das funções do pacote {stringr} (Wickham 2023b). As rotinas nativas de manipulação de texto serão apresentadas, porém de forma limitada.\n\n6.2.1 Criando um Objeto Simples de Caracteres\nTodo objeto de caracteres é criado através da encapsulação de um texto por aspas duplas (\" \") ou simples (' '). Para criar um vetor de caracteres com tickers de ações, podemos fazê-lo com o seguinte código:\n\nmy_assets &lt;- c('PETR3', 'VALE4', 'GGBR4')\nprint(my_assets)\n\nR&gt; [1] \"PETR3\" \"VALE4\" \"GGBR4\"\n\n\nConfirma-se a classe do objeto com a função class() :\n\nclass(my_assets)\n\nR&gt; [1] \"character\"\n\n\n\n\n6.2.2 Criando Objetos Estruturados de Texto\nEm muitos casos no uso do R, estaremos interessados em criar vetores de texto com algum tipo de estrutura própria. Por exemplo, o vetor c(\"text 1\", \"text 2\", ..., \"text 20\") possui um lógica de criação clara. Computacionalmente, podemos definir a sua estrutura como sendo a junção do texto text e um vetor de sequência, de 1 até 20.\nPara criar um vetor textual capaz de unir texto com número, utilizamos a função stringr::str_c() ou paste() . Veja o exemplo a seguir, onde replica-se o caso anterior com e sem espaço entre número e texto:\n\nlibrary(stringr)\n\n# create sequence\nmy_seq &lt;- 1:20\n\n# create character\nmy_text &lt;- 'text'\n\n# paste objects together (without space)\nmy_char &lt;- str_c(my_text, my_seq)\nprint(my_char)\n\nR&gt;  [1] \"text1\"  \"text2\"  \"text3\"  \"text4\"  \"text5\"  \"text6\" \nR&gt;  [7] \"text7\"  \"text8\"  \"text9\"  \"text10\" \"text11\" \"text12\"\nR&gt; [13] \"text13\" \"text14\" \"text15\" \"text16\" \"text17\" \"text18\"\nR&gt; [19] \"text19\" \"text20\"\n\n# paste objects together (with space)\nmy_char &lt;- str_c(my_text, my_seq, sep = ' ')\nprint(my_char)\n\nR&gt;  [1] \"text 1\"  \"text 2\"  \"text 3\"  \"text 4\"  \"text 5\" \nR&gt;  [6] \"text 6\"  \"text 7\"  \"text 8\"  \"text 9\"  \"text 10\"\nR&gt; [11] \"text 11\" \"text 12\" \"text 13\" \"text 14\" \"text 15\"\nR&gt; [16] \"text 16\" \"text 17\" \"text 18\" \"text 19\" \"text 20\"\n\n# paste objects together (with space)\nmy_char &lt;- paste(my_text, my_seq)\nprint(my_char)\n\nR&gt;  [1] \"text 1\"  \"text 2\"  \"text 3\"  \"text 4\"  \"text 5\" \nR&gt;  [6] \"text 6\"  \"text 7\"  \"text 8\"  \"text 9\"  \"text 10\"\nR&gt; [11] \"text 11\" \"text 12\" \"text 13\" \"text 14\" \"text 15\"\nR&gt; [16] \"text 16\" \"text 17\" \"text 18\" \"text 19\" \"text 20\"\n\n\nO mesmo procedimento também pode ser realizado com vetores de texto. Veja a seguir:\n\n# set character value\nmy_x &lt;- 'My name is'\n\n# set character vector\nmy_names &lt;- c('Marcelo', 'Ricardo', 'Tarcizio')\n\n# paste and print\nprint(str_c(my_x, my_names, sep = ' '))\n\nR&gt; [1] \"My name is Marcelo\"  \"My name is Ricardo\" \nR&gt; [3] \"My name is Tarcizio\"\n\n\nOutra possibilidade de construção de textos estruturados é a repetição do conteúdo de um objeto do tipo caractere. No caso de texto, utiliza-se a função stringr::str_dup() /strrep() para esse fim. Observe o exemplo a seguir:\n\nmy_char &lt;- str_dup(string = 'abc', times = 5)\nprint(my_char)\n\nR&gt; [1] \"abcabcabcabcabc\"\n\n\n\n\n6.2.3 Objetos Constantes de Texto\nO R também possibilita o acesso direto a todas as letras do alfabeto. Esses estão guardadas nos objetos reservados chamados letters e LETTERS:\n\n# print all letters in alphabet (no cap)\nprint(letters)\n\nR&gt;  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\"\nR&gt; [15] \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n\n# print all letters in alphabet (WITH CAP)\nprint(LETTERS)\n\nR&gt;  [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\"\nR&gt; [15] \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n\nObserve que em ambos os casos não é necessário criar os objetos. Por serem constantes embutidas automaticamente na área de trabalho do R pelo carregamento do pacote {base} (R Core Team 2023), elas já estão disponíveis para uso. Podemos sobrescrever o nome do objeto com outro conteúdo, porém isso não é aconselhável. Nunca se sabe onde esse objeto constante está sendo usado. Outros objetos de texto constantes no R incluem month.abb e month.name. Veja a seguir o seu conteúdo:\n\n# print abreviation and full names of months\nprint(month.abb)\n\nR&gt;  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\"\nR&gt; [10] \"Oct\" \"Nov\" \"Dec\"\n\nprint(month.name)\n\nR&gt;  [1] \"January\"   \"February\"  \"March\"     \"April\"    \nR&gt;  [5] \"May\"       \"June\"      \"July\"      \"August\"   \nR&gt;  [9] \"September\" \"October\"   \"November\"  \"December\"\n\n\n\n\n6.2.4 Mostrando e Formatando Textos no prompt\nComo já vimos, é possível mostrar o valor de uma variável na tela de duas formas, digitando o nome dela no prompt ou então utilizando a função print() . Explicando melhor, função print() é voltada para a apresentação de objetos e pode ser customizada. Por exemplo, caso tivéssemos um objeto de classe chamada MyTable que representasse um objeto tabular, poderíamos criar uma função chamada print.MyTable que irá mostrar uma tabela na tela com um formato especial tal como número de linhas, nomes das colunas, etc. A função print() , portanto, pode ser customizada para cada classe de objeto.\nPorém, existem outras funções específicas para apresentar texto (e não objetos) no prompt. A principal delas é message() . Essa toma como input um texto, processa-o para símbolos específicos e o apresenta na tela. Essa função é muito mais poderosa e personalizável do que print() .\nPor exemplo, caso quiséssemos mostrar na tela o texto 'O valor de x é igual a 2', poderíamos fazê-lo da seguinte forma:\n\n# set var\nx &lt;- 2\n\n# print with message()\nmessage('The value of x is', x)\n\nR&gt; The value of x is2\n\n\nFunção message() também funciona para vetores:\n\n# set vec\nx &lt;- 2:5\n\n# print with message()\nmessage('The values in x are: ', x)\n\nR&gt; The values in x are: 2345\n\n\nA customização da saída da tela é possível através de comandos específicos. Por exemplo, se quiséssemos quebrar a linha da tela, poderíamos fazê-lo através do uso do caractere reservado \\n:\n\n# set char\nmy_text &lt;- 'First line,\\nSecond Line,\\nThird Line'\n\n# print with new lines\nmessage(my_text)\n\nR&gt; First line,\nR&gt; Second Line,\nR&gt; Third Line\n\n\nObserve que o uso do print() não resultaria no mesmo efeito, uma vez que esse comando apresenta o texto como ele é, sem processar para efeitos específicos:\n\nprint(my_text)\n\nR&gt; [1] \"First line,\\nSecond Line,\\nThird Line\"\n\n\nOutro exemplo no uso de comandos específicos para texto é adicionar um espaçamento tab no texto apresentado com o símbolo \\t. Veja a seguir:\n\n# set char with \\t\nmy_text_1 &lt;- 'A and B'\nmy_text_2 &lt;- '\\tA and B'\nmy_text_3 &lt;- '\\t\\tA and B'\n\n# print with message()\nmessage(my_text_1)\n\nR&gt; A and B\n\nmessage(my_text_2)\n\nR&gt;  A and B\n\nmessage(my_text_3)\n\nR&gt;      A and B\n\n\nVale destacar que, na grande maioria dos casos de pesquisa, será necessário apenas o uso de \\n para formatar textos de saída. Outras maneiras de manipular a saída de texto no prompt com base em símbolos específicos são encontradas no manual oficial do R.\nParte do processo de apresentação de texto na tela é a customização do mesmo. Para isto, existem duas funções muito úteis: paste() e format() . A função paste() cola uma série de caracteres juntos. É uma função muito útil, a qual será utilizada intensamente para o resto dos exemplos deste livro. Observe o código a seguir:\n\n# set chars\nmy_text_1 &lt;- 'I am a text'\nmy_text_2 &lt;- 'very beautiful'\nmy_text_3 &lt;- 'and informative.'\n\n# using paste and message\nmessage(paste(my_text_1, my_text_2, my_text_3))\n\nR&gt; I am a text very beautiful and informative.\n\n\nO resultado anterior não está muito longe do que fizemos no exemplo com a função print() . Note, porém, que a função paste() adiciona um espaço entre cada texto. Caso não quiséssemos esse espaço, poderíamos usar a função paste0() :\n\n# using paste0\nmessage(paste0(my_text_1, my_text_2, my_text_3))\n\nR&gt; I am a textvery beautifuland informative.\n\n\n\n\n\n\n\n\nImportante\n\n\n\nUma alternativa a função message() é cat() (concatenate and print). Não é incomum encontrarmos códigos onde mensagens para o usuário são transmitidas via cat() e não message() . Como regra, dê preferência a message() pois esta é mais fácil de controlar. Por exemplo, caso o usuário quiser silenciar uma função, omitindo todas saídas da tela, bastaria usar o comando suppressMessages() .\n\n\nOutra possibilidade muito útil no uso do paste() é modificar o texto entre a junção dos itens a serem colados. Por exemplo, caso quiséssemos adicionar uma vírgula e espaço (,) entre cada item, poderíamos fazer isso através do uso do argumento sep, como a seguir:\n\n# using custom separator\nmessage(paste(my_text_1, my_text_2, my_text_3, sep = ', '))\n\nR&gt; I am a text, very beautiful, and informative.\n\n\nCaso tivéssemos um vetor atômico com os elementos da frase em um objeto apenas, poderíamos atingir o mesmo resultado utilizando paste() o argumento collapse:\n\n# using paste with collapse argument\nmy_text &lt;-c('Eu sou um texto', 'muito bonito', 'e charmoso.')\nmessage(paste(my_text, collapse = ', '))\n\nR&gt; Eu sou um texto, muito bonito, e charmoso.\n\n\nProsseguindo, o comando format() é utilizado para formatar números e datas. É especialmente útil quando formos montar tabelas e buscarmos apresentar os números de uma maneira visualmente atraente. Por definição, o R apresenta uma série de dígitos após a vírgula:\n\n# message without formatting\nmessage(1/3)\n\nR&gt; 0.333333333333333\n\n\nCaso quiséssemos apenas dois dígitos aparecendo na tela, utilizaríamos o seguinte código:\n\n# message with format and two digits\nmessage(format(1/3, digits=2))\n\nR&gt; 0.33\n\n\nTal como, também é possível mudar o símbolo de decimal:\n\n# message with format and two digits\nmessage(format(1/3, decimal.mark = ','))\n\nR&gt; 0,3333333\n\n\nTal flexibilidade é muito útil quando devemos reportar resultados respeitando algum formato local tal como o Brasileiro.\nUma alternativa recente e muito interessante para o comando paste() é stringr::str_c() e stringr::str_glue() . Enquanto a primeira é quase idêntica a paste0() , a segunda tem uma maneira peculiar de juntar objetos. Veja um exemplo a seguir:\n\nlibrary(stringr)\n\n# define some vars\nmy_name &lt;- 'Pedro'\nmy_age &lt;- 23\n\n# using base::paste0\nmy_str_1 &lt;- paste0('My name is ', my_name, ' and my age is ', my_age)\n\n# using stringr::str_c\nmy_str_2 &lt;- str_c('My name is ', my_name, ' and my age is ', my_age)\n\n# using stringr::str_glue\nmy_str_3 &lt;- str_glue('My name is {my_name} and my age is {my_age}')\n\nidentical(my_str_1, my_str_2)\n\nR&gt; [1] TRUE\n\nidentical(my_str_1, my_str_3)\n\nR&gt; [1] FALSE\n\nidentical(my_str_2, my_str_3)\n\nR&gt; [1] FALSE\n\n\nComo vemos, temos três alternativas para o mesmo resultado final. Note que stringr::str_glue() usa de chaves para definir as variáveis dentro do próprio texto. Esse é um formato muito interessante e prático para concatenar textos em um único objeto.\n\n\n6.2.5 Selecionando Pedaços de um Texto\nUm erro comum praticado por iniciantes é tentar selecionar pedaços de um texto através do uso de colchetes. Observe o código abaixo:\n\n# set char object\nmy_char &lt;- 'ABCDE'\n\n# print its second character: 'B' (WRONG - RESULT is NA)\nprint(my_char[2])\n\nR&gt; [1] NA\n\n\nO resultado NA indica que o segundo elemento de my_char não existe. Isso acontece porque o uso de colchetes refere-se ao acesso de elementos de um vetor atômico, e não de caracteres dentro de um texto maior. Observe o que acontece quando utilizamos my_char[1]:\n\nprint(my_char[1])\n\nR&gt; [1] \"ABCDE\"\n\n\nO resultado é simplesmente o texto ABCDE, que está localizado no primeiro item de my_char. Para selecionar pedaços de um texto, devemos utilizar a função específica stringr::str_sub() /substr() :\n\n# print third and fourth characters\nmy_substr &lt;- str_sub(string = my_char,\n                     start = 4,\n                     end = 4)\nprint(my_substr)\n\nR&gt; [1] \"D\"\n\n\nEsta função também funciona para vetores atômicos. Vamos assumir que você importou dados de texto e o conjunto de dados bruto contém um identificador de 3 dígitos de uma empresa, sempre na mesma posição do texto. Vamos simular a situação no R:\n\n# build char vec\nmy_char_vec &lt;- paste0(c('123','231','321'),\n                      ' - other ignorable text')\nprint(my_char_vec)\n\nR&gt; [1] \"123 - other ignorable text\"\nR&gt; [2] \"231 - other ignorable text\"\nR&gt; [3] \"321 - other ignorable text\"\n\n\nSó estamos interessados na informação das três primeiras letras de cada elemento em my_char_vec. Para selecioná-los, podemos usar as mesmas funções que antes.\n\n# get ids with stringr::str_sub\nids.vec &lt;- str_sub(my_char_vec, 1, 3)\nprint(ids.vec)\n\nR&gt; [1] \"123\" \"231\" \"321\"\n\n\n\n\n\n\n\n\nImportante\n\n\n\nOperações vetorizadas são comuns e esperadas no R. Quase tudo o que você pode fazer para um único elemento pode ser expandido para vetores. Isso facilita o desenvolvimento de rotinas pois pode-se facilmente realizar tarefas complicadas em uma série de elementos, em uma única linha de código.\n\n\n\n\n6.2.6 Localizando e Substituindo Pedaços de um Texto\nUma operação útil na manipulação de textos é a localização de letras e padrões específicos com funções stringr::str_locate() /regexpr() e stringr::str_locate_all() /gregexpr() . É importante destacar que estas funções utilizam de expressões do tipo regex - expressões regulares (Thompson 1968) - uma linguagem de computador específica para processar textos. Diversos símbolos são utilizados para estruturar, procurar e isolar padrões textuais.\nUsualmente, o caso mais comum em pesquisa é verificar a posição ou a existência de um texto menor dentro de um texto maior. Isto é, um padrão explícito e fácil de entender. Por isso, a localização e substituição de caracteres no próximo exemplo será do tipo fixo, sem o uso de regex. Tal informação pode ser passada às funções do pacote {stringr} (Wickham 2023b) através de outra função chamada stringr::fixed() .\nO exemplo a seguir mostra como encontrar o caractere D dentre uma série de caracteres.\n\nlibrary(stringr)\n\nmy_char &lt;- 'ABCDEF-ABCDEF-ABC'\npos = str_locate(string = my_char, pattern = fixed('D') )\nprint(pos)\n\nR&gt;      start end\nR&gt; [1,]     4   4\n\n\nObserve que a função stringr::str_locate() retorna apenas a primeira ocorrência de D. Para resgatar todas as ocorrências, devemos utilizar a função stringr::str_locate_all() :\n\n# set object\nmy_char &lt;- 'ABCDEF-ABCDEF-ABC'\n\n# find position of ALL 'D' using str_locate_all\npos = str_locate_all(string = my_char, pattern = fixed('D'))\nprint(pos)\n\nR&gt; [[1]]\nR&gt;      start end\nR&gt; [1,]     4   4\nR&gt; [2,]    11  11\n\n\nPara substituir caracteres em um texto, basta utilizar a função stringr::str_replace() ou sub() e stringr::str_locate_all() ou gsub() . Vale salientar que str_replace substitui a primeira ocorrência do caractere, enquanto stringr::str_locate_all() executa uma substituição global - isto é, aplica-se a todas as ocorrências. Veja a diferença a seguir:\n\n# set char object\nmy_char &lt;- 'ABCDEF-ABCDEF-ABC'\n\n# substitute the FIRST 'ABC' for 'XXX' with sub\nmy_char &lt;- sub(x = my_char,\n               pattern = 'ABC',\n               replacement = 'XXX')\nprint(my_char)\n\nR&gt; [1] \"XXXDEF-ABCDEF-ABC\"\n\n# substitute the FIRST 'ABC' for 'XXX' with str_replace\nmy_char &lt;- 'ABCDEF-ABCDEF-ABC'\nmy_char &lt;- str_replace(string = my_char,\n                       pattern = fixed('ABC'),\n                       replacement = 'XXX')\nprint(my_char)\n\nR&gt; [1] \"XXXDEF-ABCDEF-ABC\"\n\n\nE agora fazemos uma substituição global dos caracteres.\n\n# set char object\nmy_char &lt;- 'ABCDEF-ABCDEF-ABC'\n\n# substitute the FIRST 'ABC' for 'XXX' with str_replace\nmy_char &lt;- str_replace_all(string = my_char,\n                           pattern = 'ABC',\n                           replacement = 'XXX')\nprint(my_char)\n\nR&gt; [1] \"XXXDEF-XXXDEF-XXX\"\n\n\nMais uma vez, vale ressaltar que as operações de substituição também funcionam em vetores. Dê uma olhada no próximo exemplo.\n\n# set char object\nmy_char &lt;- c('ABCDEF','DBCFE','ABC')\n\n# create an example of vector\nmy_char_vec &lt;- str_c(sample(my_char, 5, replace = T),\n                     sample(my_char, 5, replace = T),\n                     sep = ' - ')\n\n# show it\nprint(my_char_vec)\n\nR&gt; [1] \"ABCDEF - ABC\"    \"ABCDEF - ABCDEF\" \"ABCDEF - ABC\"   \nR&gt; [4] \"ABCDEF - DBCFE\"  \"DBCFE - ABCDEF\"\n\n# substitute all occurrences of 'ABC'\nmy_char_vec &lt;- str_replace_all(string = my_char_vec,\n                               pattern = 'ABC',\n                               replacement = 'XXX')\n\n# print result\nprint(my_char_vec)\n\nR&gt; [1] \"XXXDEF - XXX\"    \"XXXDEF - XXXDEF\" \"XXXDEF - XXX\"   \nR&gt; [4] \"XXXDEF - DBCFE\"  \"DBCFE - XXXDEF\"\n\n\n\n\n6.2.7 Separando Textos\nEm algumas situações, principalmente no processamento de textos, é possível que se esteja interessado em quebrar um texto de acordo com algum separador. Por exemplo, o texto abc;bcd;adf apresenta informações demarcadas pelo símbolo ;. Para separar um texto em várias partes, utilizamos a função stringr::str_split() /strsplit() . Essas quebram o texto em diversas partes de acordo com algum caractere escolhido. Observe os exemplos a seguir:\n\n# set char\nmy_char &lt;- 'ABCXABCXBCD'\n\n# split it based on 'X' and using stringr::str_split\nsplit_char &lt;- str_split(my_char, 'X')\n\n# print result\nprint(split_char)\n\nR&gt; [[1]]\nR&gt; [1] \"ABC\" \"ABC\" \"BCD\"\n\n\nA saída dessa função é um objeto do tipo lista. Para acessar os elementos de uma lista, deve-se utilizar o operador [[ ]]. Por exemplo, para acessar o texto bcd da lista split_char, executa-se o seguinte código:\n\nprint(split_char[[1]][2])\n\nR&gt; [1] \"ABC\"\n\n\nPara visualizar um exemplo de dividir textos em vetores, veja o próximo código.\n\n# set char\nmy_char_vec &lt;- c('ABCDEF','DBCFE','ABFC','ACD')\n\n# split it based on 'B' and using stringr::strsplit\nsplit_char &lt;- str_split(my_char_vec, 'B')\n\n# print result\nprint(split_char)\n\nR&gt; [[1]]\nR&gt; [1] \"A\"    \"CDEF\"\nR&gt; \nR&gt; [[2]]\nR&gt; [1] \"D\"   \"CFE\"\nR&gt; \nR&gt; [[3]]\nR&gt; [1] \"A\"  \"FC\"\nR&gt; \nR&gt; [[4]]\nR&gt; [1] \"ACD\"\n\n\nObserve como, novamente, um objeto do tipo list é retornado. Cada elemento é correspondente ao processo de quebra de texto em my_char.\n\n\n6.2.8 Descobrindo o Número de Caracteres de um Texto\nPara descobrir o número de caracteres de um texto, utilizamos a função stringr::str_length() /nchar() . Ela também funciona para vetores atômicos de texto. Veja os exemplos mostrados a seguir:\n\n# set char\nmy_char &lt;- 'abcdef'\n\n# print number of characters using stringr::str_length\nprint(str_length(my_char))\n\nR&gt; [1] 6\n\n\nE agora um exemplo com vetores.\n\n#set char\nmy_char &lt;- c('a', 'ab', 'abc')\n\n# print number of characters using stringr::str_length\nprint(str_length(my_char))\n\nR&gt; [1] 1 2 3\n\n\n\n\n6.2.9 Gerando Combinações de Texto\nUm truque útil no R é usar as funções expand.grid() e tidyr::expand_grid() para criar todas as combinações possíveis de elementos em diferentes objetos. Isso é útil quando você quer criar um vetor de texto combinando todos os elementos possíveis de diferentes vetores. Por exemplo, se quisermos criar um vetor com todas as combinações entre dois vetores de texto, podemos escrever:\n\nlibrary(tidyverse)\n\n# set vectors\nmy_vec_1 &lt;- c('John ', 'Claire ', 'Adam ')\nmy_vec_2 &lt;- c('is fishing.', 'is working.')\n\n# create df with all combinations\nmy_df &lt;- tidyr::expand_grid(name = my_vec_1,\n                     verb = my_vec_2)\n\n# print df\nprint(my_df)\n\nR&gt; # A tibble: 6 × 2\nR&gt;   name      verb       \nR&gt;   &lt;chr&gt;     &lt;chr&gt;      \nR&gt; 1 \"John \"   is fishing.\nR&gt; 2 \"John \"   is working.\nR&gt; 3 \"Claire \" is fishing.\nR&gt; 4 \"Claire \" is working.\nR&gt; 5 \"Adam \"   is fishing.\nR&gt; 6 \"Adam \"   is working.\n\n# paste columns together in tibble\nmy_df &lt;- my_df |&gt;\n  mutate(phrase = paste0(name, verb) )\n\n# print result\nprint(my_df)\n\nR&gt; # A tibble: 6 × 3\nR&gt;   name      verb        phrase            \nR&gt;   &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;             \nR&gt; 1 \"John \"   is fishing. John is fishing.  \nR&gt; 2 \"John \"   is working. John is working.  \nR&gt; 3 \"Claire \" is fishing. Claire is fishing.\nR&gt; 4 \"Claire \" is working. Claire is working.\nR&gt; 5 \"Adam \"   is fishing. Adam is fishing.  \nR&gt; 6 \"Adam \"   is working. Adam is working.\n\n\nAqui, usamos a função tidyr::expand_grid() para criar um dataframe contendo todas as combinações possíveis de my_vec_1 e my_vec_2. Posteriormente, colamos o conteúdo das colunas do dataframe usando stringr::str_c() .\n\n\n6.2.10 Codificação de Objetos character\nPara o R, um string de texto é apenas uma sequência de bytes. A tradução de bytes para caracteres é realizada de acordo com uma estrutura de codificação. Em dados de textos oriundos de países de língua inglesa, a codificação de caracteres não é um problema pois os textos importados no R já possuem a codificação correta. Ao lidar com dados de texto em diferentes idiomas, tal como Português do Brasil, a codificação de caracteres é algo que você deve entender pois eventualmente precisará lidar com isso.\nVamos explorar um exemplo. Aqui, vamos importar dados de um arquivo de texto com a codificação 'ISO-8859-9' e verificar o resultado.\n\n# read text file\nmy_f &lt;- introR::data_path('CH07_FileWithLatinChar_Latin1.txt')\n\nmy_char &lt;- readr::read_lines(my_f)\n\n# print it\nprint(my_char)\n\nR&gt; [1] \"A casa \\xe9 bonita e tem muito espa\\xe7o\"\n\n\nO conteúdo original do arquivo é um texto em português. Como você pode ver, a saída de readr::read_lines() mostra todos os caracteres latinos com símbolos estranhos. Isso ocorre pois a codificação foi manualmente trocada no arquivo para 'ISO-8859-9', enquanto a função readr::read_lines() utiliza 'UTF-8' como padrão. A solução mais fácil e direta é modificar a codificação esperada do arquivo nas entradas de readr::read_lines() . Veja a seguir, onde importamos um arquivo com a codificação correta ('Latin1'):\n\nmy_char &lt;- readr::read_lines(my_f, \n                             locale = readr::locale(encoding='Latin1'))\n\n# print it\nprint(my_char)\n\nR&gt; [1] \"A casa é bonita e tem muito espaço\"\n\n\nOs caracteres latinos agora estão corretos pois a codificação em readr::read_lines() é a mesma do arquivo, 'Latin1'. Uma boa política neste tópico é sempre verificar a codificação de arquivos de texto importados e combiná-lo em R. A maioria das funções de importação tem uma opção para fazê-lo. Quando possível, sempre dê preferência para 'UTF-8'. Caso necessário, programas de edição de texto, tal como o notepad++, possuem ferramentas para verificar e trocar a codificação de um arquivo.\n\n\n6.2.11 Outras Funções Úteis\nstringr::str_to_lower() /tolower() - Converte um objeto de texto para letras minúsculas.\n\nprint(stringr::str_to_lower('ABC'))\n\nR&gt; [1] \"abc\"\n\n\nstringr::str_to_upper() /toupper() - Converte um texto em letras maiúsculas.\n\nprint(toupper('abc'))\n\nR&gt; [1] \"ABC\"\n\nprint(stringr::str_to_upper('abc'))\n\nR&gt; [1] \"ABC\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>As Classes Básicas de Objetos</span>"
    ]
  },
  {
    "objectID": "06-objetos-basicos.html#fatores",
    "href": "06-objetos-basicos.html#fatores",
    "title": "6  As Classes Básicas de Objetos",
    "section": "6.3 Fatores",
    "text": "6.3 Fatores\nA classe de fatores (factor() ) é utilizada para representar grupos ou categorias dentro de uma base de dados no formato tabular. Por exemplo, imagine um banco de informações com os gastos de diferentes pessoas ao longo de um ano. Nessa base de dados existe um item que define o gênero do indivíduo: masculino ou feminino (M ou F). Essa respectiva coluna pode ser importada e representada como texto, porém, no R, a melhor maneira de representá-la é através do objeto fator, uma vez que a mesma representa uma categoria.\nA classe de fatores oferece um significado especial para denotar grupos dentro dos dados. Essa organização é integrada aos pacotes e facilita muito a vida do usuário. Por exemplo, caso quiséssemos criar um gráfico para cada grupo dentro da nossa base de dados, poderíamos fazer o mesmo simplesmente indicando a existência de uma variável de fator para a função de criação da figura. Outra possibilidade é determinar se as diferentes médias de uma variável numérica são estatisticamente diferentes para os grupos dos nossos dados. Podemos também estimar um determinado modelo estatístico para cada grupo. Quando os dados de categorias são representados apropriadamente, o uso das funções do R torna-se mais fácil e eficiente.\n\n6.3.1 Criando Fatores\nA criação de fatores dá-se através da função factor() :\n\nmy_factor &lt;- factor(c('M', 'F', 'M', 'M', 'F'))\nprint(my_factor)\n\nR&gt; [1] M F M M F\nR&gt; Levels: F M\n\n\nObserve, no exemplo anterior, que a apresentação de fatores com a função print() mostra os seus elementos e também o item chamado Levels. Esse último identifica os possíveis grupos que abrangem o vetor - nesse caso apenas M e F. Se tivéssemos um número maior de grupos, o item Levels aumentaria.\nUm ponto importante na criação de fatores é que os Levels são inferidos através dos dados criados, e isso pode não corresponder à realidade. Por exemplo, observe o seguinte exemplo:\n\nmy_status &lt;- factor(c('Solteiro', 'Solteiro', 'Solteiro'))\nprint(my_status)\n\nR&gt; [1] Solteiro Solteiro Solteiro\nR&gt; Levels: Solteiro\n\n\nNota-se que, por ocasião, os dados mostram apenas uma categoria: Solteiro. Entretanto, sabe-se que outra categoria do tipo Casado é esperada. No caso de utilizarmos o objeto my_status da maneira que foi definida anteriormente, omitiremos a informação de outros gêneros, e isso pode ocasionar problemas no futuro tal como a criação de gráficos incompletos. Nessa situação, o correto é definir os Levels manualmente da seguinte maneira:\n\nmy_status &lt;- factor(c('Solteiro', 'Solteiro', 'Solteiro'),\n                    levels = c('Solteiro', 'Casado'))\nprint(my_status)\n\nR&gt; [1] Solteiro Solteiro Solteiro\nR&gt; Levels: Solteiro Casado\n\n\n\n\n6.3.2 Modificando Fatores\nUm ponto importante sobre os objetos do tipo fator é que seus Levels são imutáveis e não atualizam-se com a entrada de novos dados. Em outras palavras, não é possível modificar os valores dos Levels após a criação do objeto. Toda nova informação que não for compatível com os Levels do objeto será transformada em NA (Not available) e uma mensagem de warning irá aparecer na tela. Essa limitação pode parecer estranha a primeira vista porém, na prática, ela evita possíveis erros no código. Veja o exemplo a seguir:\n\n# set factor\nmy_factor &lt;- factor(c('a', 'b', 'a', 'b'))\n\n# change first element of a factor to 'c'\nmy_factor[1] &lt;- 'c'\n\nR&gt; Warning in `[&lt;-.factor`(`*tmp*`, 1, value = \"c\"): invalid\nR&gt; factor level, NA generated\n\n# print result\nprint(my_factor)\n\nR&gt; [1] &lt;NA&gt; b    a    b   \nR&gt; Levels: a b\n\n\nNesse caso, a maneira correta de proceder é primeiro transformar o objeto da classe fator para a classe caractere e depois realizar a conversão:\n\n# set factor\nmy_factor &lt;- factor(c('a', 'b', 'a', 'b'))\n\n# change factor to character\nmy_char &lt;- as.character(my_factor)\n\n# change first element\nmy_char[1] &lt;- 'c'\n\n# mutate it back to class factor\nmy_factor &lt;- factor(my_char)\n\n# show result\nprint(my_factor)\n\nR&gt; [1] c b a b\nR&gt; Levels: a b c\n\n\nUtilizando essas etapas temos o resultado desejado no vetor my_factor, com a definição de três Levels: a, b e c.\nO universo {tidyverse} (Wickham 2023c) também possui um pacote próprio para manipular fatores, o {forcats} (Wickham 2023a). Para o problema atual de modificação de fatores, podemos utilizar função forcats::fct_recode() . Veja um exemplo a seguir, onde trocamos as siglas dos fatores:\n\n# set factor\nmy_factor &lt;- factor(c('A', 'B', 'C', 'A', 'C', 'M', 'N'))\n\n# modify factors\nmy_factor &lt;- forcats::fct_recode(my_factor,\n                     'D' = 'A',\n                     'E' = 'B',\n                     'F' = 'C')\n\n# print result\nprint(my_factor)\n\nR&gt; [1] D E F D F M N\nR&gt; Levels: D E F M N\n\n\nObserve como o uso da função forcats::fct_recode() é intuitivo. Basta indicar o novo nome dos grupos com o operador de igualdade.\n\n\n6.3.3 Convertendo Fatores para Outras Classes\nOutro ponto importante no uso de fatores é a sua conversão para outras classes, especialmente a numérica. Quando convertemos um objeto de tipo fator para a classe caractere, o resultado é o esperado:\n\n# create factor\nmy_char &lt;-factor(c('a', 'b', 'c'))\n\n# convert and print\nprint(as.character(my_char))\n\nR&gt; [1] \"a\" \"b\" \"c\"\n\n\nPorém, quando fazemos o mesmo procedimento para a classe numérica, o que o R retorna é longe do esperado:\n\n# set factor\nmy_values &lt;- factor(5:10)\n\n# convert to numeric (WRONG)\nprint(as.numeric(my_values))\n\nR&gt; [1] 1 2 3 4 5 6\n\n\nEsse resultado pode ser explicado pelo fato de que, internamente, fatores são armazenados como índices, indo de 1 até o número total de Levels. Essa simplificação minimiza o uso da memória do computador. Quando pedimos ao R para transformar esses fatores em números, ele entende que buscamos o número do índice e não do valor. Para contornar o problema é fácil, basta transformar o objeto fator em caractere e, depois, em numérico, conforme mostrado a seguir:\n\n# converting factors to character and then to numeric\nprint(as.numeric(as.character(my_values)))\n\nR&gt; [1]  5  6  7  8  9 10\n\n\n\n\n\n\n\n\nCuidado\n\n\n\nTenha muito cuidado ao transformar fatores em números. Lembre-se sempre de que o retorno da conversão direta serão os índices dos levels e não os valores em si. Esse é um bug bem particular que pode ser difícil de identificar em um código mais complexo.\n\n\n\n\n6.3.4 Criando Tabelas de Contingência\nApós a criação de um fator, podemos calcular a ocorrência de cada fator com a função table() . Essa também é chamada de tabela de contingência. Em um caso simples, com apenas um fator, a função table() conta o número de ocorrências de cada categoria, como a seguir:\n\n# create factor\nmy_factor &lt;- factor(sample(c('Pref', 'Ord'),\n                           size = 20,\n                           replace = TRUE))\n\n# print contingency table\nprint(table(my_factor))\n\nR&gt; my_factor\nR&gt;  Ord Pref \nR&gt;    9   11\n\n\nUm caso mais avançado do uso de table() é utilizar mais de um fator para a criação da tabela. Veja o exemplo a seguir:\n\n# set factors\nmy_factor_1 &lt;- factor(sample(c('Pref', 'Ord'),\n                             size = 20,\n                             replace = TRUE))\n\nmy_factor_2 &lt;- factor(sample(paste('Grupo', 1:3),\n                             size = 20,\n                             replace = TRUE))\n\n# print contingency table with two factors\nprint(table(my_factor_1, my_factor_2))\n\nR&gt;            my_factor_2\nR&gt; my_factor_1 Grupo 1 Grupo 2 Grupo 3\nR&gt;        Ord        2       4       3\nR&gt;        Pref       3       4       4\n\n\nA tabela criada anteriormente mostra o número de ocorrências para cada combinação de fator. Essa é uma ferramenta descritiva simples, mas bastante informativa para a análise de grupos de dados.\n\n\n6.3.5 Outras Funções\nlevels() - Retorna os Levels de um objeto da classe fator.\n\nmy_factor &lt;- factor(c('A', 'A', 'B', 'C', 'B'))\nprint(levels(my_factor))\n\nR&gt; [1] \"A\" \"B\" \"C\"\n\n\nas.factor() - Transforma um objeto para a classe fator.\n\nmy_y &lt;- c('a','b', 'c', 'c', 'a')\nmy_factor &lt;- as.factor(my_y)\nprint(my_factor)\n\nR&gt; [1] a b c c a\nR&gt; Levels: a b c\n\n\nsplit() - Com base em um objeto de fator, cria uma lista com valores de outro objeto. Esse comando é útil para separar dados de grupos diferentes e aplicar alguma função com sapply() ou lapply.\n\nmy_factor &lt;- factor(c('A','B','C','C','C','B'))\nmy_x &lt;- 1:length(my_factor)\n\nmy_l &lt;- split(x = my_x, f = my_factor)\n\nprint(my_l)\n\nR&gt; $A\nR&gt; [1] 1\nR&gt; \nR&gt; $B\nR&gt; [1] 2 6\nR&gt; \nR&gt; $C\nR&gt; [1] 3 4 5",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>As Classes Básicas de Objetos</span>"
    ]
  },
  {
    "objectID": "06-objetos-basicos.html#valores-lógicos",
    "href": "06-objetos-basicos.html#valores-lógicos",
    "title": "6  As Classes Básicas de Objetos",
    "section": "6.4 Valores Lógicos",
    "text": "6.4 Valores Lógicos\nTestes lógicos em dados são centrais no uso do R. Em uma única linha de código podemos testar condições para uma grande quantidade de casos. Esse cálculo é muito utilizado para encontrar casos extremos nos dados (outliers) e também para separar diferentes amostras de acordo com algum critério.\n\n6.4.1 Criando Valores Lógicos\nEm uma sequência de 1 até 10, podemos verificar quais são os elementos maiores que 5 com o seguinte código:\n\n# set numerical\nmy_x &lt;- 1:10\n\n# print a logical test\nprint(my_x &gt; 5)\n\nR&gt;  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\nR&gt; [10]  TRUE\n\n# print position of elements from logical test\nprint(which(my_x &gt; 5))\n\nR&gt; [1]  6  7  8  9 10\n\n\nA função which() do exemplo anterior retorna os índices onde a condição é verdadeira (TRUE). O uso do which() é recomendado quando se quer saber a posição de elementos que satisfazem alguma condição.\nPara realizar testes de igualdade, basta utilizar o símbolo de igualdade duas vezes (==).\n\n# create char\nmy_char &lt;- rep(c('abc','bcd'), 5)\n\n# print its contents\nprint(my_char)\n\nR&gt;  [1] \"abc\" \"bcd\" \"abc\" \"bcd\" \"abc\" \"bcd\" \"abc\" \"bcd\" \"abc\"\nR&gt; [10] \"bcd\"\n\n# print logical test\nprint(my_char == 'abc')\n\nR&gt;  [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\nR&gt; [10] FALSE\n\n\nPara o teste de inigualdades, utilizamos o símbolo !=:\n\n# print inequality test\nprint(my_char != 'abc')\n\nR&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE\nR&gt; [10]  TRUE\n\n\nDestaca-se que também é possível testar condições múltiplas, isto é, a ocorrência simultânea de eventos. Utilizamos o operador & para esse propósito. Por exemplo: se quiséssemos verificar quais são os valores de uma sequência de 1 a 10 que são maiores que 4 e menores que 7, escreveríamos:\n\nmy_x &lt;- 1:10\n\n# print logical for values higher than 4 and lower than 7\nprint((my_x &gt; 4)&(my_x &lt; 7) )\n\nR&gt;  [1] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE\nR&gt; [10] FALSE\n\n# print the actual values\nidx &lt;- which( (my_x &gt; 4)&(my_x &lt; 7) )\nprint(my_x[idx])\n\nR&gt; [1] 5 6\n\n\nPara testar condições não simultâneas, isto é, ocorrências de um ou outro evento, utilizamos o operador |. Por exemplo: considerando a sequência anterior, acharíamos os valores maiores que 7 ou menores que 4 escrevendo:\n\n# location of elements higher than 7 or lower than 4\nidx &lt;- which( (my_x &gt; 7)|(my_x &lt; 4) )\n\n# print elements from previous condition\nprint(my_x[idx])\n\nR&gt; [1]  1  2  3  8  9 10\n\n\nObserve que, em ambos os casos de uso de testes lógicos, utilizamos parênteses para encapsular as condições lógicas. Poderíamos ter escrito idx &lt;- which( my_x &gt; 7|my_x &lt; 4 ), porém o uso do parênteses deixa o código mais claro ao isolar os testes de condições e sinalizar que o resultado da operação será um vetor lógico. Em alguns casos, porém, o uso do parênteses indica hierarquia na ordem das operações e portanto não pode ser ignorado.\nOutro uso interessante de objetos lógicos é o teste para saber se um item ou mais pertence a um vetor ou não. Para isso utilizamos o operador %in%. Por exemplo, imagine que tens os tickers de duas ações, c('ABC', 'DEF') e queres saber se é possível encontrar esses tickers na coluna de outra base de dados. Essa é uma operação semelhante ao uso do teste de igualdade, porém em notação vetorial. Veja um exemplo a seguir:\n\nlibrary(dplyr)\n# location of elements higher than 7 or lower than 4\nmy_tickers &lt;- c('ABC', 'DEF')\n\n# set df\nn_obs &lt;- 100\ndf_temp &lt;- tibble(tickers = sample(c('ABC', 'DEF', 'GHI', 'JKL'),\n                                   size = n_obs,\n                                   replace = TRUE),\n                  ret = rnorm(n_obs, sd = 0.05) )\n\n# find rows with selected tickers\nidx &lt;- df_temp$tickers %in% my_tickers\n\n# print elements from previous condition\nglimpse(df_temp[idx, ])\n\nR&gt; Rows: 43\nR&gt; Columns: 2\nR&gt; $ tickers &lt;chr&gt; \"ABC\", \"ABC\", \"ABC\", \"DEF\", \"DEF\", \"ABC\", …\nR&gt; $ ret     &lt;dbl&gt; 0.042864781, 0.017056405, 0.011198439, 0.0…\n\n\nO dataframe mostrado na tela possui dados apenas para ações em my_tickers.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>As Classes Básicas de Objetos</span>"
    ]
  },
  {
    "objectID": "06-objetos-basicos.html#sec-datas",
    "href": "06-objetos-basicos.html#sec-datas",
    "title": "6  As Classes Básicas de Objetos",
    "section": "6.5 Datas e Tempo",
    "text": "6.5 Datas e Tempo\nManipular datas e horários de forma correta, levando em conta mudanças decorridas de horário de verão, feriados locais, em diferentes zonas de tempo, não é uma tarefa fácil! Felizmente, o R fornece um grande suporte para qualquer tipo de operação com datas e tempo.\nNesta seção estudaremos as funções e classes nativas que representam e manipulam o tempo em R. Aqui, daremos prioridade as funções do pacote {lubridate} (Spinu, Grolemund, and Wickham 2023). Existem, no entanto, muitos pacotes que podem ajudar o usuário a processar objetos do tipo data e tempo. Caso alguma operação com data e tempo não for encontrada aqui, sugiro o estudo dos pacotes {chron} (James and Hornik 2023), {timeDate} (Wuertz et al. 2023) e {bizdays} (Freitas 2024).\nAntes de começarmos, vale relembrar que toda data no R segue o formato ISO 8601 (YYYY-MM-DD), onde YYYY é o ano em quatro números, MM é o mês e DD é o dia. Por exemplo, uma data em ISO 8601 é 2024-04-07. Deves familiarizar-se com esse formato pois toda importação de dados com formato de datas diferente desta notação exigirá conversão. Felizmente, essa operação é bastante simples de executar com o {lubridate} (Spinu, Grolemund, and Wickham 2023).\n\n6.5.1 Criando Datas Simples\nNo R, existem diversas classes que podem representar datas. A escolha entre uma classe de datas e outra baseia-se na necessidade da pesquisa. Em muitas situações não é necessário saber o horário, enquanto que em outras isso é extremamente pertinente pois os dados são coletados ao longo de um dia.\nA classe mais básica de datas é Date. Essa indica dia, mês e ano, apenas. No {lubridate} (Spinu, Grolemund, and Wickham 2023), criamos datas verificando o formato da data de entrada e as funções lubridate::ymd() (year-month-date), lubridate::dmy() (day-month-year) e lubridate::mdy() (month-day-year). Veja a seguir:\n\nlibrary(lubridate)\n\n# set Date object\nprint(ymd('2021-06-24'))\n\nR&gt; [1] \"2021-06-24\"\n\n# set Date object\nprint(dmy('24-06-2021'))\n\nR&gt; [1] \"2021-06-24\"\n\n# set Date object\nprint(mdy('06-24-2021'))\n\nR&gt; [1] \"2021-06-24\"\n\n\nNote que as funções retornam exatamente o mesmo objeto. A diferença no uso é somente pela forma que a data de entrada está estruturada com a posição do dia, mês e ano.\nUm benefício no uso das funções do pacote {lubridate} (Spinu, Grolemund, and Wickham 2023) é que as mesmas são inteligentes ao lidar com formatos diferentes. Observe no caso anterior que definimos os elementos das datas com o uso do traço (-) como separador e valores numéricos. Outros formatos também são automaticamente reconhecidos:\n\n# set Date object\nprint(ymd('2021/06/24'))\n\nR&gt; [1] \"2021-06-24\"\n\n# set Date object\nprint(ymd('2021&06&24'))\n\nR&gt; [1] \"2021-06-24\"\n\n# set Date object\nprint(ymd('2021 june 24'))\n\nR&gt; [1] \"2021-06-24\"\n\n# set Date object\nprint(dmy('24 of june 2021'))\n\nR&gt; [1] \"2021-06-24\"\n\n\nIsso é bastante útil pois o formato de datas no Brasil é dia/mês/ano (DD/MM/YYYY). Ao usar lubridate::dmy() para uma data brasileira, a conversão é correta:\n\n# set Date from dd/mm/yyyy\nmy_date &lt;- dmy('24/06/2021')\n\n# print result\nprint(my_date)\n\nR&gt; [1] \"2021-06-24\"\n\n\nJá no pacote {base} (R Core Team 2023), a função correspondente é as.Date() . O formato da data, porém, deve ser explicitamente definido com argumento format() , conforme mostrado a seguir:\n\n# set Date from dd/mm/yyyy with the definition of format\nmy_date &lt;- as.Date('24/06/2021', format = '%d/%m/%Y')\n\n# print result\nprint(my_date)\n\nR&gt; [1] \"2021-06-24\"\n\n\nOs símbolos utilizados na entrada format() , tal como %d e %Y, são indicadores de formato, os quais definem a forma em que a data a ser convertida está estruturada. Nesse caso, os símbolos %Y, %m e %d definem ano, mês e dia, respectivamente. Existem diversos outros símbolos que podem ser utilizados para processar datas em formatos específicos. Um panorama das principais codificações é apresentado a seguir:\n\n\n\nCódigo\nValor\nExemplo\n\n\n\n\n%d\ndia do mês (decimal)\n0\n\n\n%m\nmês (decimal)\n12\n\n\n%b\nmês (abreviado)\nAbr\n\n\n%B\nmês (nome completo)\nAbril\n\n\n%y\nano (2 dígitos)\n16\n\n\n%Y\nano (4 dígitos)\n2021\n\n\n\nOs símbolos anteriores permitem a criação de datas a partir de variados formatos. Observe como a utilização das funções do {lubridate} (Spinu, Grolemund, and Wickham 2023), em relação a {base} (R Core Team 2023), são mais simples e fáceis de utilizar, justificando a nossa escolha.\n\n\n6.5.2 Criando Sequências de Datas\nUm aspecto interessante no uso de objetos do tipo Date é que eles interagem com operações de adição de valores numéricos e com testes lógicos de comparação de datas. Por exemplo, caso quiséssemos adicionar dez dias à data my_date criada anteriormente, bastaria somar o valor 10 ao objeto:\n\n# create date\nmy_date &lt;- ymd('2021-06-24')\n\n# find next day\nmy_date_2 &lt;- my_date + 10\n\n# print result\nprint(my_date_2)\n\nR&gt; [1] \"2021-07-04\"\n\n\nA propriedade também funciona com vetores, o que deixa a criação de sequências de datas muito fácil. Nesse caso, o próprio R encarrega-se de verificar o número de dias em cada mês.\n\n# create a sequence of Dates\nmy_date_vec &lt;- my_date + 0:15\n\n# print it\nprint(my_date_vec)\n\nR&gt;  [1] \"2021-06-24\" \"2021-06-25\" \"2021-06-26\" \"2021-06-27\"\nR&gt;  [5] \"2021-06-28\" \"2021-06-29\" \"2021-06-30\" \"2021-07-01\"\nR&gt;  [9] \"2021-07-02\" \"2021-07-03\" \"2021-07-04\" \"2021-07-05\"\nR&gt; [13] \"2021-07-06\" \"2021-07-07\" \"2021-07-08\" \"2021-07-09\"\n\n\nUma maneira mais customizável de criar sequências de datas é utilizar a função seq() . Com ela, é possível definir intervalos diferentes de tempo e até mesmo o tamanho do vetor de saída. Caso quiséssemos uma sequência de datas de dois em dois dias, poderíamos utilizar o seguinte código:\n\n# set first and last Date\nmy_date_1 &lt;- ymd('2021-03-07')\nmy_date_2 &lt;- ymd('2021-03-20')\n\n# set sequence\nmy_date_date &lt;- seq(from = my_date_1,\n                    to = my_date_2,\n                    by = '2 days')\n\n# print result\nprint(my_date_date)\n\nR&gt; [1] \"2021-03-07\" \"2021-03-09\" \"2021-03-11\" \"2021-03-13\"\nR&gt; [5] \"2021-03-15\" \"2021-03-17\" \"2021-03-19\"\n\n\nCaso quiséssemos de duas em duas semanas, escreveríamos:\n\n# set first and last Date\nmy_date_1 &lt;- ymd('2021-03-07')\nmy_date_2 &lt;- ymd('2021-04-20')\n\n# set sequence\nmy_date_date &lt;- seq(from = my_date_1,\n                    to = my_date_2,\n                    by = '2 weeks')\n\n# print result\nprint(my_date_date)\n\nR&gt; [1] \"2021-03-07\" \"2021-03-21\" \"2021-04-04\" \"2021-04-18\"\n\n\nOutra forma de utilizar seq() é definir o tamanho desejado do objeto de saída. Por exemplo, caso quiséssemos um vetor de datas com 10 elementos, usaríamos:\n\n# set first and last Date\nmy_date_1 &lt;- ymd('2021-03-07')\nmy_date_2 &lt;- ymd('2021-10-20')\n\n# set sequence\nmy_date_vec &lt;- seq(from = my_date_1,\n                    to = my_date_2,\n                    length.out = 10)\n\n# print result\nprint(my_date_vec)\n\nR&gt;  [1] \"2021-03-07\" \"2021-04-01\" \"2021-04-26\" \"2021-05-21\"\nR&gt;  [5] \"2021-06-15\" \"2021-07-11\" \"2021-08-05\" \"2021-08-30\"\nR&gt;  [9] \"2021-09-24\" \"2021-10-20\"\n\n\nO intervalo entre as datas em my_date_vec é definido automaticamente pelo R.\n\n\n6.5.3 Operações com Datas\nÉ possível descobrir a diferença de dias entre datas simplesmente diminuindo uma data da outra:\n\n# set dates\nmy_date_1 &lt;- ymd('2015-06-24')\nmy_date_2 &lt;- ymd('2016-06-24')\n\n# calculate difference\ndiff_date &lt;- my_date_2 - my_date_1\n\n# print result\nprint(diff_date)\n\nR&gt; Time difference of 366 days\n\n\nA saída da operação de subtração é um objeto da classe diffdate, o qual possui a classe de lista como sua estrutura básica. Destaca-se que a notação de acesso aos elementos da classe diffdate é a mesma utilizada para listas. O valor numérico do número de dias está contido no primeiro elemento de diff_date:\n\n# print difference of days as numerical value\nprint(diff_date[[1]])\n\nR&gt; [1] 366\n\n\nPodemos testar se uma data é maior do que outra com o uso das operações de comparação:\n\n# set date and vector\nmy_date_1 &lt;- ymd('2016-06-20')\nmy_date_vec &lt;- ymd('2016-06-20') + seq(-5,5)\n\n# test which elements of my_date_vec are older than my_date_1\nmy_test &lt;- (my_date_vec &gt; my_date_1)\n\n# print result\nprint(my_test)\n\nR&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\nR&gt; [10]  TRUE  TRUE\n\n\nA operação anterior é bastante útil quando se está buscando filtrar um determinado período de tempo nos dados. Nesse caso, basta buscar nas datas o período específico em que estamos interessados e utilizar o objeto lógico da comparação para selecionar os elementos.\n\n\n6.5.4 Lidando com Data e Tempo\nO uso da classe Date é suficiente quando se está lidando apenas com datas. Em casos em que é necessário levar em consideração o horário, temos que utilizar um objeto do tipo datetime.\nNo pacote {base} (R Core Team 2023), uma das classes utilizadas para esse fim é a POSIXlt, a qual armazena o conteúdo de uma data na forma de uma lista. Outra classe que também é possível utilizar é a POSIXct, que armazena as datas como segundos contados a partir de 1970-01-01. Junto ao {lubridate} (Spinu, Grolemund, and Wickham 2023), a classe utilizada para representar data-tempo é POSIXct e portanto daremos prioridade a essa. Vale destacar que todos os exemplos apresentados aqui também podem ser replicados para objetos do tipo POSIXlt.\nO formato tempo/data também segue a norma ISO 8601, sendo representado como ano-mês-dia horas:minutos:segundos zonadetempo (YYYY-MM-DD HH:mm:SS TMZ). Veja o exemplo a seguir:\n\n# creating a POSIXct object\nmy_timedate &lt;- as.POSIXct('2024-01-01 16:00:00')\n\n# print result\nprint(my_timedate)\n\nR&gt; [1] \"2024-01-01 16:00:00 -03\"\n\n\nPacote {lubridate} (Spinu, Grolemund, and Wickham 2023) também oferece funções inteligentes para a criação de objetos do tipo data-tempo. Essas seguem a mesma linha de raciocínio que as funções de criar datas. Veja a seguir:\n\nlibrary(lubridate)\n\n# creating a POSIXlt object\nmy_timedate &lt;- ymd_hms('2021-01-01 16:00:00')\n\n# print it\nprint(my_timedate)\n\nR&gt; [1] \"2021-01-01 16:00:00 UTC\"\n\n\nDestaca-se que essa classe adiciona automaticamente o fuso horário. Caso seja necessário representar um fuso diferente, é possível fazê-lo com o argumento tz:\n\n# creating a POSIXlt object with custom timezone\nmy_timedate_tz &lt;- ymd_hms('2021-01-01 16:00:00',\n                          tz = 'GMT')\n\n# print it\nprint(my_timedate_tz)\n\nR&gt; [1] \"2021-01-01 16:00:00 GMT\"\n\n\nÉ importante ressaltar que, para o caso de objetos do tipo POSIXlt e POSIXct, as operações de soma e diminuição referem-se a segundos e não dias, como no caso do objeto da classe Date.\n\n# Adding values (seconds) to a POSIXlt object and printing it\nprint(my_timedate_tz + 30)\n\nR&gt; [1] \"2021-01-01 16:00:30 GMT\"\n\n\nAssim como para a classe Date, existem símbolos específicos para lidar com componentes de um objeto do tipo data/tempo. Isso permite a formatação customizada de datas. A seguir, apresentamos um quadro com os principais símbolos e os seus respectivos significados.\n\n\n\nCódigo\nValor\nExemplo\n\n\n\n\n%H\nHora (decimal, 24 horas)\n23\n\n\n%I\nHora (decimal, 12 horas)\n11\n\n\n%M\nMinuto (decimal, 0-59)\n12\n\n\n%p\nIndicador AM/PM\nAM\n\n\n%S\nSegundos (decimal, 0-59)\n50\n\n\n\nA seguir veremos como utilizar essa tabela para customizar datas.\n\n\n6.5.5 Personalizando o Formato de Datas\nA notação básica para representar datas e data/tempo no R pode não ser a ideal em algumas situações. No Brasil, por exemplo, indicar datas no formato YYYY-MM-DD pode gerar bastante confusão em um relatório formal. É recomendado, portanto, modificar a representação das datas para o formato esperado, isto é, DD/MM/YYYY.\nPara formatar uma data, utilizamos a função format() . Seu uso baseia-se nos símbolos de data e de horário apresentados anteriormente. A partir desses, pode-se criar qualquer customização. Veja o exemplo a seguir, onde apresenta-se a modificação de um vetor de datas para o formato brasileiro:\n\n# create vector of dates\nmy_dates &lt;- seq(from = ymd('2021-01-01'),\n                to = ymd('2021-01-15'),\n                by = '1 day')\n\n# change format\nmy_dates_br &lt;- format(my_dates, '%d/%m/%Y')\n\n# print result\nprint(my_dates_br)\n\nR&gt;  [1] \"01/01/2021\" \"02/01/2021\" \"03/01/2021\" \"04/01/2021\"\nR&gt;  [5] \"05/01/2021\" \"06/01/2021\" \"07/01/2021\" \"08/01/2021\"\nR&gt;  [9] \"09/01/2021\" \"10/01/2021\" \"11/01/2021\" \"12/01/2021\"\nR&gt; [13] \"13/01/2021\" \"14/01/2021\" \"15/01/2021\"\n\n\nO mesmo procedimento pode ser realizado para objetos do tipo data/tempo (POSIXct):\n\n# create vector of date-time\nmy_datetime &lt;- ymd_hms('2021-01-01 12:00:00') + seq(0,560,60)\n\n# change to Brazilian format\nmy_dates_br &lt;- format(my_datetime, '%d/%m/%Y %H:%M:%S')\n\n# print result\nprint(my_dates_br)\n\nR&gt;  [1] \"01/01/2021 12:00:00\" \"01/01/2021 12:01:00\"\nR&gt;  [3] \"01/01/2021 12:02:00\" \"01/01/2021 12:03:00\"\nR&gt;  [5] \"01/01/2021 12:04:00\" \"01/01/2021 12:05:00\"\nR&gt;  [7] \"01/01/2021 12:06:00\" \"01/01/2021 12:07:00\"\nR&gt;  [9] \"01/01/2021 12:08:00\" \"01/01/2021 12:09:00\"\n\n\nPode-se também customizar para formatos bem específicos. Veja a seguir:\n\n# set custom format\nmy_dates_custom &lt;- format(my_dates,\n                          'Year=%Y | Month=%m | Day=%d')\n\n# print result\nprint(my_dates_custom)\n\nR&gt;  [1] \"Year=2021 | Month=01 | Day=01\"\nR&gt;  [2] \"Year=2021 | Month=01 | Day=02\"\nR&gt;  [3] \"Year=2021 | Month=01 | Day=03\"\nR&gt;  [4] \"Year=2021 | Month=01 | Day=04\"\nR&gt;  [5] \"Year=2021 | Month=01 | Day=05\"\nR&gt;  [6] \"Year=2021 | Month=01 | Day=06\"\nR&gt;  [7] \"Year=2021 | Month=01 | Day=07\"\nR&gt;  [8] \"Year=2021 | Month=01 | Day=08\"\nR&gt;  [9] \"Year=2021 | Month=01 | Day=09\"\nR&gt; [10] \"Year=2021 | Month=01 | Day=10\"\nR&gt; [11] \"Year=2021 | Month=01 | Day=11\"\nR&gt; [12] \"Year=2021 | Month=01 | Day=12\"\nR&gt; [13] \"Year=2021 | Month=01 | Day=13\"\nR&gt; [14] \"Year=2021 | Month=01 | Day=14\"\nR&gt; [15] \"Year=2021 | Month=01 | Day=15\"\n\n\n\n\n6.5.6 Extraindo Elementos de uma Data\nPara extrair elementos de datas tal como o ano, mês, dia, hora, minuto e segundo, uma alternativa é utilizar função format() . Observe o próximo exemplo, onde recuperamos apenas as horas de um objeto POSIXct:\n\nlibrary(lubridate)\n\n# create vector of date-time\nmy_datetime &lt;- seq(from = ymd_hms('2021-01-01 12:00:00'),\n                   to = ymd_hms('2021-01-01 18:00:00'),\n                   by = '1 hour')\n\n# get hours from POSIXlt\nmy_hours &lt;- as.numeric(format(my_datetime, '%H'))\n\n# print result\nprint(my_hours)\n\nR&gt; [1] 12 13 14 15 16 17 18\n\n\nDa mesma forma, poderíamos utilizar os símbolos %M e %S para recuperar facilmente minutos e segundos de um vetor de objetos POSIXct.\n\n# create vector of date-time\nmy_datetime &lt;- seq(from = ymd_hms('2021-01-01 12:00:00'),\n                   to = ymd_hms('2021-01-01 18:00:00'),\n                   by = '15 min')\n\n# get minutes from POSIXlt\nmy_minutes &lt;- as.numeric(format(my_datetime, '%M'))\n\n# print result\nprint(my_minutes)\n\nR&gt;  [1]  0 15 30 45  0 15 30 45  0 15 30 45  0 15 30 45  0 15\nR&gt; [19] 30 45  0 15 30 45  0\n\n\nOutra forma é utilizar as funções do {lubridate} (Spinu, Grolemund, and Wickham 2023), tal como lubridate::hour() e lubridate::minute() :\n\n# get hours with lubridate\nprint(hour(my_datetime))\n\nR&gt;  [1] 12 12 12 12 13 13 13 13 14 14 14 14 15 15 15 15 16 16\nR&gt; [19] 16 16 17 17 17 17 18\n\n# get minutes with lubridate\nprint(minute(my_datetime))\n\nR&gt;  [1]  0 15 30 45  0 15 30 45  0 15 30 45  0 15 30 45  0 15\nR&gt; [19] 30 45  0 15 30 45  0\n\n\nOutras funções também estão disponíveis para os demais elementos de um objeto data-hora.\n\n\n6.5.7 Conhecendo o Horário e a Data Atual\nO R inclui várias funções que permitem o usuário utilizar no seu código o horário e data atual do sistema. Isso é bastante útil quando se está criando registros e é importante que a data e horário de execução do código seja conhecida futuramente.\nPara conhecer o dia atual, basta utilizarmos a função Sys.Date() ou lubridate::today() :\n\nlibrary(lubridate)\n\n# get today\nprint(Sys.Date())\n\nR&gt; [1] \"2024-04-07\"\n\n# print it\nprint(today())\n\nR&gt; [1] \"2024-04-07\"\n\n\nPara descobrir a data e horário, utilizamos a função Sys.time() ou lubridate::now() :\n\n# get time!\nprint(Sys.time())\n\nR&gt; [1] \"2024-04-07 09:34:53 -03\"\n\n# get time!\nprint(now())\n\nR&gt; [1] \"2024-04-07 09:34:53 -03\"\n\n\nCom base nessas, podemos escrever:\n\nlibrary(stringr)\n\n# example of log message\nmy_str &lt;- str_c('This code was executed in ', now())\n\n# print it\nprint(my_str)\n\nR&gt; [1] \"This code was executed in 2024-04-07 09:34:53.467121\"\n\n\n\n\n6.5.8 Outras Funções Úteis\nweekdays() - Retorna o dia da semana de uma ou várias datas.\n\n# set date vector\nmy_dates &lt;- seq(from = ymd('2021-01-01'),\n                to = ymd('2021-01-5'),\n                by = '1 day')\n\n# find corresponding weekdays\nmy_weekdays &lt;- weekdays(my_dates)\n\n# print it\nprint(my_weekdays)\n\nR&gt; [1] \"Friday\"   \"Saturday\" \"Sunday\"   \"Monday\"   \"Tuesday\"\n\n\nmonths() - Retorna o mês de uma ou várias datas.\n\n# create date vector\nmy_dates &lt;- seq(from = ymd('2021-01-01'),\n                to = ymd('2021-12-31'),\n                by = '1 month')\n\n# find months\nmy_months &lt;- months(my_dates)\n\n# print result\nprint(my_months)\n\nR&gt;  [1] \"January\"   \"February\"  \"March\"     \"April\"    \nR&gt;  [5] \"May\"       \"June\"      \"July\"      \"August\"   \nR&gt;  [9] \"September\" \"October\"   \"November\"  \"December\"\n\n\nquarters() - Retorna a localização de uma ou mais datas dentro dos quartis do ano.\n\n# get quartiles of the year\nmy_quarters &lt;- quarters(my_dates)\nprint(my_quarters)\n\nR&gt;  [1] \"Q1\" \"Q1\" \"Q1\" \"Q2\" \"Q2\" \"Q2\" \"Q3\" \"Q3\" \"Q3\" \"Q4\" \"Q4\"\nR&gt; [12] \"Q4\"\n\n\nOlsonNames() - Retorna um vetor com as zonas de tempo disponíveis no R. No total, são mais de 500 itens. Aqui, apresentamos apenas os primeiros cinco elementos.\n\n# get possible timezones\npossible_tz &lt;- OlsonNames()\n\n# print it\nprint(possible_tz[1:5])\n\nR&gt; [1] \"Africa/Abidjan\"     \"Africa/Accra\"      \nR&gt; [3] \"Africa/Addis_Ababa\" \"Africa/Algiers\"    \nR&gt; [5] \"Africa/Asmara\"\n\n\nSys.timezone() - Retorna a zona de tempo do sistema.\n\n# get current timezone\nprint(Sys.timezone())\n\nR&gt; [1] \"America/Sao_Paulo\"\n\n\ncut() - Retorna um fator a partir da categorização de uma classe de data e tempo.\n\n# set example date vector\nmy_dates &lt;- seq(from = ymd('2021-01-01'),\n                to = ymd('2021-03-01'),\n                by = '5 days')\n\n# group vector based on monthly breaks\nmy_month_cut &lt;- cut(x = my_dates,\n                    breaks = '1 month')\n\n# print result\nprint(my_month_cut)\n\nR&gt;  [1] 2021-01-01 2021-01-01 2021-01-01 2021-01-01 2021-01-01\nR&gt;  [6] 2021-01-01 2021-01-01 2021-02-01 2021-02-01 2021-02-01\nR&gt; [11] 2021-02-01 2021-02-01\nR&gt; Levels: 2021-01-01 2021-02-01\n\n\n\n# set example datetime vector\nmy_datetime &lt;- as.POSIXlt('2021-01-01 12:00:00') + seq(0,250,15)\n\n# set groups for each 30 seconds\nmy_cut &lt;- cut(x = my_datetime, breaks = '30 secs')\n\n# print result\nprint(my_cut)\n\nR&gt;  [1] 2021-01-01 12:00:00 2021-01-01 12:00:00\nR&gt;  [3] 2021-01-01 12:00:30 2021-01-01 12:00:30\nR&gt;  [5] 2021-01-01 12:01:00 2021-01-01 12:01:00\nR&gt;  [7] 2021-01-01 12:01:30 2021-01-01 12:01:30\nR&gt;  [9] 2021-01-01 12:02:00 2021-01-01 12:02:00\nR&gt; [11] 2021-01-01 12:02:30 2021-01-01 12:02:30\nR&gt; [13] 2021-01-01 12:03:00 2021-01-01 12:03:00\nR&gt; [15] 2021-01-01 12:03:30 2021-01-01 12:03:30\nR&gt; [17] 2021-01-01 12:04:00\nR&gt; 9 Levels: 2021-01-01 12:00:00 ... 2021-01-01 12:04:00",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>As Classes Básicas de Objetos</span>"
    ]
  },
  {
    "objectID": "06-objetos-basicos.html#dados-omissos---na-not-available",
    "href": "06-objetos-basicos.html#dados-omissos---na-not-available",
    "title": "6  As Classes Básicas de Objetos",
    "section": "6.6 Dados Omissos - NA (Not available)",
    "text": "6.6 Dados Omissos - NA (Not available)\nUma das principais inovações do R em relação a outras linguagens de programação é a representação de dados omissos através de objetos da classe NA (Not Available). A falta de dados pode ter inúmeros motivos, tal como a falha na coleta de informações ou simplesmente a não existência dos mesmos. Esses casos são tratados por meio da remoção ou da substituição dos dados omissos antes realizar uma análise mais profunda. A identificação desses casos, portanto, é de extrema importância.\n\n6.6.1 Definindo Valores NA\nPara definirmos os casos omissos nos dados, basta utilizar o símbolo NA:\n\n# a vector with NA\nmy_x &lt;- c(1, 2, NA, 4, 5)\n\n# print it\nprint(my_x)\n\nR&gt; [1]  1  2 NA  4  5\n\n\nVale destacar que a operação de qualquer valor NA com outro sempre resultará em NA.\n\n# example of NA interacting with other objects\nprint(my_x + 1)\n\nR&gt; [1]  2  3 NA  5  6\n\n\nIsso exige cuidado quando se está utilizando alguma função com cálculo recursivo, tal como cumsum() e cumprod() . Nesses casos, todo valor consecutivo ao NA será transformado em NA. Veja os exemplos a seguir com as duas funções:\n\n# set vector with NA\nmy_x &lt;- c(1:5, NA, 5:10)\n\n# print cumsum (NA after sixth element)\nprint(cumsum(my_x))\n\nR&gt;  [1]  1  3  6 10 15 NA NA NA NA NA NA NA\n\n# print cumprod (NA after sixth element)\nprint(cumprod(my_x))\n\nR&gt;  [1]   1   2   6  24 120  NA  NA  NA  NA  NA  NA  NA\n\n\n\n\n\n\n\n\nCuidado com NAs\n\n\n\nToda vez que utilizar as funções cumsum() e cumprod() , certifique-se de que não existe algum valor NA no vetor de entrada. Lembre-se de que todo NA é contagiante e o cálculo recursivo irá resultar em um vetor repleto de dados faltantes.\n\n\n\n\n6.6.2 Encontrando e Substituindo Valores NA\nPara encontrar os valores NA em um vetor, basta utilizar a função is.na() :\n\n# set vector with NA\nmy_x &lt;- c(1:2, NA, 4:10)\n\n# find location of NA\nidx_na &lt;- is.na(my_x)\nprint(idx_na)\n\nR&gt;  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\nR&gt; [10] FALSE\n\n\nPara substituí-los, use indexação com a saída de is.na() :\n\n# set vector\nmy_x &lt;- c(1, NA, 3:4, NA)\n\n# replace NA for 2\nmy_x[is.na(my_x)] &lt;- 2\n\n# print result\nprint(my_x)\n\nR&gt; [1] 1 2 3 4 2\n\n\nOutra maneira de limpar o objeto é utilizar a função na.omit() , que retorna o mesmo objeto mas sem os valores NA. Note, porém, que o tamanho do vetor irá mudar e o objeto será da classe omit, o que indica que o vetor resultante não inclui os NA e apresenta, também, a posição dos elementos NA encontrados.\n\n# set vector\nmy_char &lt;- c(letters[1:3], NA, letters[5:8])\n\n# print it\nprint(my_char)\n\nR&gt; [1] \"a\" \"b\" \"c\" NA  \"e\" \"f\" \"g\" \"h\"\n\n# use na.omit to remove NA\nmy_char &lt;- na.omit(my_char)\n\n# print result\nprint(my_char)\n\nR&gt; [1] \"a\" \"b\" \"c\" \"e\" \"f\" \"g\" \"h\"\nR&gt; attr(,\"na.action\")\nR&gt; [1] 4\nR&gt; attr(,\"class\")\nR&gt; [1] \"omit\"\n\n\nApesar do tipo de objeto ter sido trocado, devido ao uso de na.omit() , as propriedades básicas do vetor inicial se mantêm. Por exemplo: o uso de nchar() no objeto resultante é possível.\n\n# trying nchar on a na.omit object\nprint(nchar(my_char))\n\nR&gt; [1] 1 1 1 1 1 1 1\n\n\nPara outros objetos, porém, recomenda-se cautela quando no uso da função na.omit() .\n\n\n6.6.3 Outras Funções Úteis\ncomplete.cases() - Retorna um vetor lógico que indica se as linhas do objeto possuem apenas valores não omissos. Essa função é usada exclusivamente para dataframes e matrizes.\n\n# create matrix\nmy_mat &lt;- matrix(1:15, nrow = 5)\n\n# set an NA value\nmy_mat[2,2] &lt;- NA\n\n# print index with rows without NA\nprint(complete.cases(my_mat))\n\nR&gt; [1]  TRUE FALSE  TRUE  TRUE  TRUE",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>As Classes Básicas de Objetos</span>"
    ]
  },
  {
    "objectID": "06-objetos-basicos.html#exerc-classes-basicas",
    "href": "06-objetos-basicos.html#exerc-classes-basicas",
    "title": "6  As Classes Básicas de Objetos",
    "section": "6.7 Exercícios",
    "text": "6.7 Exercícios\n\nQ.1 - Considere os seguintes os vetores x e y:\n set.seed(7)\nx &lt;- sample (1:3, size = 5, replace = T)\ny &lt;- sample (1:3, size = 5, replace = T) \nQual é a soma dos elementos de um novo vetor resultante da multiplicação entre os elementos de x e y?\n\n41\n31\n55\n34\n48\n\n\nQ.2 - Caso realizássemos uma soma cumulativa de uma sequência entre 1 e 100, em qual elemento esta soma iria passar de 50?\n\n3\n1\n10\n7\n5\n\n\nQ.3 - Utilizando o R, crie uma sequência em objeto chamado seq_1 entre -15 e 10, onde o intervalo entre valores é sempre igual a 2. Qual o valor da soma dos elementos de seq_1?\n\n-39\n-27\n-17\n-52\n-91\n\n\nQ.4 - Defina outro objeto chamado seq_2 contendo uma sequência de tamanho 1000, com valores entre 0 e 100. Qual é o desvio padrão (função sd() ) dessa sequência?\n\n39.30614\n44.90486\n33.70742\n28.91085\n50.50359\n\n\nQ.5 - Deina dois vetores, um com a sequência entre 1 e 10, e outro como a sequência entre 1 e 5. Caso somássemos os elementos de ambos vetores, a operação funcionaria apesar do tamanho diferente dos vetores? Explique sua resposta. Caso funcionar, qual o maior valor do vetor resultante?\n\n28\n32\n21\n25\n18\n\n\nQ.6 - Vamos supor que, em certa data, você comprou 100 ações de uma empresa, a price_purchase reais por ação. Depois de algum tempo, você vendeu 30 ações por 18 reais cada e as 70 ações restantes foram vendidas por 22 reais em um dia posterior. Usando um script em R, estruture este problema financeiro criando objetos numéricos. Qual é o lucro bruto desta transação no mercado de ações?\n\nR$ 580\nR$ 1.658\nR$ 223\nR$ 389\nR$ 1.078\n\n\nQ.7 - Crie um vetor x de acordo com a fórmula a seguir, onde \\(i=1...100\\). Qual é o valor da soma dos elementos de x?\n\\[\nx_i=\\frac{-1^{i+1}}{2i-1}\n\\]\n\n0.3297478\n0.7828982\n0.9760899\n0.5317707\n1.758988\n\n\nQ.8 - Crie um vetor \\(z_i\\) de acordo com a fórmula a seguir onde \\(x_i=1...50\\) e \\(y_i=50...1\\). Qual é o valor da soma dos elementos de \\(z_i\\)? Dica: veja o funcionamento da função dplyr::lag.\n\\[\nz_i=\\frac{y_i - x_{i-1}}{y_{i-2}}\n\\]\n\n-23.15975\n-65.95709\n-10.09432\n-49.29059\n-36.22517\n\n\nQ.9 - Usando uma semente de valor 43 em set.seed(), crie um objeto chamado x com valores aleatórios da distribuição Normal com média igual a 10 e desvio padrão igual a 10. Usando função cut() , crie outro objeto que defina dois grupos com base em valores de x maiores que 15 e menores que 15. Qual a quantidade de observações no primeiro grupo?\n\n1047\n1188\n905\n684\n763\n\n\nQ.10 - Crie o seguinte objeto com o código a seguir:\n set.seed(15)\nmy_char &lt;- paste(sample(letters, 5000, replace = T), collapse = ’’) \nQual a quantidade de vezes que a letra 'x' é encontrada no objeto de texto resultante?\n\n297\n198\n264\n231\n174\n\n\nQ.11 - Baseado no objeto my_char criado anteriormente, caso dividíssemos o mesmo em diversos pedaços menores utilizando a letra \"b\", qual é o número de caracteres no maior pedaço encontrado?\n\n188\n125\n167\n146\n110\n\n\nQ.12 - No endereço https://www.gutenberg.org/ebooks/2264.txt.utf-8 é possível acessar um arquivo .txt contendo o texto integral do livro Pride and Prejudice de Jane Austen. Utilize funções download.file() e readr::read_lines() para importar o livro inteiro como um vetor de caracteres chamado my_book no R. Quantas linhas o objeto resultante possui?\n\n5146\n3761\n8907\n2596\n1737\n\n\nQ.13 - Junte o vetor de caracteres em my_book para um único valor (texto) em outro objeto chamado full_text usando função paste0(my_book, collapse = '\\n'). Utilizando este último e pacote {stringr} (Wickham 2023b), quantas vezes a palavra 'King' é repetida na totalidade do texto?\n\n55\n93\n70\n30\n163\n\n\nQ.14 - Para o objeto full_text criado anteriormente, utilize função stringr::str_split() para quebrar o texto inteiro em função de espaços em branco. Com base nesse, crie uma tabela de frequência. Qual a palavra mais utilizada no texto? Dica: Remova todos os casos de caracteres vazios ('').\n\nand\nto\nis\nwith\nthe\n\n\nQ.15 - Assumindo que uma pessoa nascida em 2000-05-12 irás viver for 100 anos, qual é o número de dias de aniversário que cairão em um final de semana (sábado ou domingo)? Dica: use operador %in% para checar uma condição múltipla nos dados.\n\n29\n11\n45\n21\n74\n\n\nQ.16 - Qual data e horário é localizado 10^{4} segundos após 2021-02-02 11:50:02?\n\n2021-02-02 12:44:52\n2021-02-02 10:23:31\n2021-02-02 10:29:10\n2021-02-02 14:36:42\n2021-02-02 10:48:06\n\n\n\n\n\nFreitas, Wilson. 2024. Bizdays: Business Days Calculations and Utilities. https://github.com/wilsonfreitas/R-bizdays.\n\n\nGentzkow, Matthew, Bryan T Kelly, and Matt Taddy. 2017. “Text as Data.” National Bureau of Economic Research.\n\n\nJames, David, and Kurt Hornik. 2023. Chron: Chronological Objects Which Can Handle Dates and Times. https://CRAN.R-project.org/package=chron.\n\n\nMcLeish, Don L. 2011. Monte Carlo Simulation and Finance. Vol. 276. John Wiley & Sons.\n\n\nR Core Team. 2023. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/.\n\n\nSpinu, Vitalie, Garrett Grolemund, and Hadley Wickham. 2023. Lubridate: Make Dealing with Dates a Little Easier. https://lubridate.tidyverse.org.\n\n\nThompson, Ken. 1968. “Programming Techniques: Regular Expression Search Algorithm.” Communications of the ACM 11 (6): 419–22.\n\n\nWickham, Hadley. 2023a. Forcats: Tools for Working with Categorical Variables (Factors). https://forcats.tidyverse.org/.\n\n\n———. 2023b. Stringr: Simple, Consistent Wrappers for Common String Operations. https://stringr.tidyverse.org.\n\n\n———. 2023c. Tidyverse: Easily Install and Load the Tidyverse. https://tidyverse.tidyverse.org.\n\n\nWuertz, Diethelm, Tobias Setz, Yohan Chalabi, and Georgi N. Boshnakov. 2023. timeDate: Rmetrics - Chronological and Calendar Objects. https://geobosh.github.io/timeDateDoc/.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>As Classes Básicas de Objetos</span>"
    ]
  },
  {
    "objectID": "07-objetos-armazenamento.html",
    "href": "07-objetos-armazenamento.html",
    "title": "7  As Classes de Armazenamento",
    "section": "",
    "text": "7.1 Dataframes\nTraduzindo para o português, dataframe significa “estrutura ou organização de dados”. Grosso modo, um objeto da classe dataframe nada mais é do que uma tabela com linhas e colunas. Sem dúvida, o dataframe é o principal objeto utilizado no trabalho com o R e o mais importante de se estudar. Dados externos são geralmente importados no formato de tabelas. É na manipulação de tabelas que gastará a maior parte do tempo realizando a sua análise. Internamente, um dataframe é um tipo especial de lista, onde cada coluna é um vetor atômico com o mesmo número de elementos. Podemos organizar em um dataframe uma coluna com dados de texto, e outra com números, por exemplo.\nNote que o formato tabular força a sincronização dos dados no sentido de linhas, isto é, cada caso de cada variável deve ser pareado com casos de outras variáveis. Apesar de simples, esse tipo de estruturação de dados é intuitiva e pode acomodar uma variedade de informações. Cada acréscimo de um pedaço novo de dados incrementa as linhas e cada novo tipo de informação, ou variável, incrementa as colunas da tabela.\nUm dos pontos positivos na utilização do dataframe para a acomodação de dados é que funções de diferentes pacotes irão funcionar a partir dessa classe de objetos. Por exemplo, o pacote de manipulação de dados {dplyr} (Wickham et al. 2023), assim como o pacote de criação de figuras ggplot2, funcionam a partir de um dataframe. Esse objeto, portanto, está no centro de uma série de funcionalidades do R e, sem dúvida, é uma classe de objeto extremamente importante para aprender a utilizar corretamente.\nO objeto dataframe é uma das classes nativas do R e vem implementado no pacote {base} (R Core Team 2023). Entretanto, o universe {tidyverse} (Wickham 2023) oferece sua própria versão de um dataframe, chamada tibble, a qual é utilizada sistematicamente em todos pacotes do {tidyverse} (Wickham 2023). A conversão de um dataframe para tibble é interna e automática. O tibble possui propriedades mais flexíveis que dataframes nativos, facilitando de forma significativa o seu uso. Seguindo a nossa preferência para o {tidyverse} (Wickham 2023), a partir de agora iremos utilizar tibbles como representantes de dataframes.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>As Classes de Armazenamento</span>"
    ]
  },
  {
    "objectID": "07-objetos-armazenamento.html#sec-dataframes",
    "href": "07-objetos-armazenamento.html#sec-dataframes",
    "title": "7  As Classes de Armazenamento",
    "section": "",
    "text": "7.1.1 Criando dataframes\nA criação de um dataframe do tipo tibble ocorre a partir da função dplyr::tibble() . Note que a criação de um dataframe nativo ocorre com a função data.frame() , enquanto a criação do tibble parte da função tibble::tibble() ou dplyr::tibble() . Para manter o código mais limpo, iremos dar preferência a dplyr::tibble() e utilizar o nome dataframe para se referir a um tibble. Veja o exemplo a seguir, onde criamos uma tabela correspondente a dados financeiros de diferentes ações.\n\n# set tickers\nticker &lt;- c(rep('ABEV3',4),\n            rep('BBAS3', 4),\n            rep('BBDC3', 4))\n\n# set dates\nref_date &lt;- as.Date(rep(c('2010-01-01', '2010-01-04',\n                          '2010-01-05', '2010-01-06'),\n                        3) )\n\n# set prices\nprice &lt;- c(736.67, 764.14, 768.63, 776.47,\n           59.4  , 59.8  , 59.2  , 59.28,\n           29.81 , 30.82 , 30.38 , 30.20)\n\n# create tibble/dataframe\nmy_df &lt;- tibble::tibble(ticker, ref_date , price)\n\n# print it\nprint(my_df)\n\nR&gt; # A tibble: 12 × 3\nR&gt;    ticker ref_date   price\nR&gt;    &lt;chr&gt;  &lt;date&gt;     &lt;dbl&gt;\nR&gt;  1 ABEV3  2010-01-01 737. \nR&gt;  2 ABEV3  2010-01-04 764. \nR&gt;  3 ABEV3  2010-01-05 769. \nR&gt;  4 ABEV3  2010-01-06 776. \nR&gt;  5 BBAS3  2010-01-01  59.4\nR&gt;  6 BBAS3  2010-01-04  59.8\nR&gt;  7 BBAS3  2010-01-05  59.2\nR&gt;  8 BBAS3  2010-01-06  59.3\nR&gt;  9 BBDC3  2010-01-01  29.8\nR&gt; 10 BBDC3  2010-01-04  30.8\nR&gt; 11 BBDC3  2010-01-05  30.4\nR&gt; 12 BBDC3  2010-01-06  30.2\n\n\nObserve que utilizamos a função rep() para replicar e facilitar a criação dos dados do dataframe anterior. Assim, não é necessário repetir os valores múltiplas vezes. Destaca-se que, no uso dos dataframes, podemos salvar todos os nossos dados em um único objeto, facilitando o acesso e a organização do código resultante.\n\n\n\n\n\n\nDica\n\n\n\nO conteúdo de dataframes também pode ser visualizado no próprio RStudio. Para isso, basta clicar no nome do objeto na aba environment, canto superior direito da tela. Após isso, um visualizador aparecerá na tela principal do programa. Essa operação é nada mais que uma chamada a função View() . Portanto, poderíamos visualizar o dataframe anterior executando o comando View(my_df).\n\n\n\n\n7.1.2 Inspecionando um dataframe\nApós a criação do dataframe, o segundo passo é conhecer o seu conteúdo. Particularmente, é importante tomar conhecimento dos seguintes itens, em ordem de importância:\n\nNúmero de linhas e colunas\n\nO número de linhas e colunas da tabela resultante indicam se a operação de importação foi executada corretamente. Caso os valores forem diferentes do esperado, deve-se checar o arquivo de importação dos dados e se as opções de importação foram corretamente especificadas.\n\nNomes das colunas\n\nÉ importante que a tabela importada tenha nomes que façam sentido e que sejam fáceis de acessar. Portanto, o segundo passo na inspeção de um dataframe é analisar os nomes das colunas e seus respectivos conteúdos. Confirme que cada coluna realmente apresenta um nome intuitivo e relacionado ao problema.\n\nClasses das colunas\n\nCada coluna de um dataframe tem sua própria classe. É de suma importância que as classes dos dados estejam corretamente especificadas. Caso contrário, operações futuras podem resultar em um erro. Por exemplo, caso um vetor de valores numéricos seja importado com a classe de texto (character), qualquer operação matemática nesse vetor irá resultar em um erro no R.\n\nExistência de dados omissos (NA)\n\nDevemos também verificar o número de valores NA (not available) nas diferentes colunas. Sempre que você encontrar uma grande proporção de valores NA na tabela importada, você deve descobrir o que está acontecendo e se a informação está sendo importada corretamente. Conforme mencionado na Section 6.6.2, os valores NA são contagiosos e transformarão qualquer objeto que interagir com um NA, também se tornará um NA.\n\n\nUma das funções mais recomendadas para se familiarizar com um dataframe é dplyr::glimpse() . Essa mostra na tela o nome e a classe das colunas, além do número de linhas/colunas. Abusamos dessa função nos capítulos anteriores. Veja um exemplo simples a seguir:\n\n# check content of my_df\ndplyr::glimpse(my_df)\n\nR&gt; Rows: 12\nR&gt; Columns: 3\nR&gt; $ ticker   &lt;chr&gt; \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS…\nR&gt; $ ref_date &lt;date&gt; 2010-01-01, 2010-01-04, 2010-01-05, 2010…\nR&gt; $ price    &lt;dbl&gt; 736.67, 764.14, 768.63, 776.47, 59.40, 59…\n\n\nEm muitas situações, o uso de dplyr::glimpse() é suficiente para entender se o processo de importação de dados ocorreu de forma satisfatória. Porém, uma análise mais profunda é entender qual a variação de cada coluna nos dados importados. Aqui entra o papel da função summary() :\n\n# check variation my_df\nsummary(my_df)\n\nR&gt;     ticker             ref_date              price       \nR&gt;  Length:12          Min.   :2010-01-01   Min.   : 29.81  \nR&gt;  Class :character   1st Qu.:2010-01-03   1st Qu.: 30.71  \nR&gt;  Mode  :character   Median :2010-01-04   Median : 59.34  \nR&gt;                     Mean   :2010-01-04   Mean   :283.73  \nR&gt;                     3rd Qu.:2010-01-05   3rd Qu.:743.54  \nR&gt;                     Max.   :2010-01-06   Max.   :776.47\n\n\nNote que summary() interpreta cada coluna de forma diferente. Para o primeiro caso, coluna ticker, mostra apenas o tamanho do vetor. No caso de datas e valores numéricos, essa apresenta o máximo, mínimo, mediana e quartis. Por exemplo, uma observação extrema (outlier) poderia ser facilmente identificada na análise da saída textual de summary() .\nUma alternativa moderna para summary() é skimr::skim() , que fornece mais detalhes sobre os dados:\n\n# Check content of my_df\nskimr::skim(my_df)\n\nVocê não só obtém as classes das colunas, mas também mais informações sobre as diferentes classes de dados:\n\nPara a coluna tickers, você obtém o número de casos ausentes, valores únicos e mais;\nPara a coluna dates, você obtém o mínimo e o máximo de dados, bem como o número de datas disponíveis;\nPara colunas de valores numéricos, você obtém média, desvio padrão e quantis e mais;\n\nEmbora não seja suficiente, uma simples chamada a skimr::skim() pode fornecer uma grande quantidade de informações sobre os dados sendo importados.\n\n\n\n\n\n\nO hábito de inspeção\n\n\n\nToda vez que se deparar com um novo dataframe no R, pegue o hábito de verificar o seu conteúdo com funções dplyr::glimpse() e skimr::skim() . Assim, poderá perceber problemas de importação e/ou conteúdo dos arquivos lidos. Com experiência irás perceber que muitos erros futuros em código podem ser sanados por uma simples inspeção das tabelas importadas.\n\n\n\n\n7.1.3 Operador de pipeline\nO operador de pipeline, ou sequenciamento em tradução livre, é uma ferramenta fundamental na análise de dados com R. Resumidamente, ele permite que operações de dados sejam realizadas sequencialmente e de forma modular, aumentando a legibilidade e a facilidade de manutenção do código resultante. O operador é amplamente utilizado no pacote {tidyverse} (Wickham 2023) e foi proposto pela primeira vez no pacote r cite_pkg(“magrittr”) com o símbolo %&gt;%. Recentemente, na versão 4.1 do R, lançada em 18 de maio de 2021, um novo operador pipe (nativo) foi introduzido (|&gt;), com grande aprovação por parte da comunidade.\nPara explicar melhor o seu uso e benefício, imagine uma situação onde temos três funções para aplicar nos dados salvos em um dataframe. Cada função depende da saída de outra função, isto é, estamos manipulando os dados por etapas. Usando o operador de pipeline, podemos escrever o procedimento de manipulação dataframe com o seguinte código:\n\nmy_tab &lt;- my_df |&gt;\n  fct1(arg1) |&gt;\n  fct2(arg2) |&gt;\n  fct3(arg3)\n\nUsamos símbolo |&gt; no final de cada linha para vincular as operações. As funções fct* são operações realizadas em cada etapa. O resultado de cada linha é passado para a próxima função de forma sequencial. Assim, não há necessidade de criar objetos intermediários. Veja a seguir duas formas alternativas de realizar a mesma operação sem o operador de pipeline:\n\n# version 1\nmy_tab &lt;- fct3(fct2(fct1(my_df,\n                         arg1),\n                    arg2),\n               arg1)\n\n# version 2\ntemp1 &lt;- fct1(my_df, arg1)\ntemp2 &lt;- fct2(temp1, arg2)\nmy_tab &lt;- fct3(temp1, arg3)\n\nObserve como as alternativas formam um código com estrutura estranha e passível a erros. Provavelmente não deves ter notado, mas ambos os códigos possuem erros de digitação. Para o primeiro, o último arg1 deveria ser arg3 e, no segundo, a função fct3 está usando o dataframe temp1 e não temp2. Este exemplo deixa claro como o uso de pipelines torna o código mais elegante e legível. A partir de agora iremos utilizar o operador |&gt; de forma extensiva.\n\n\n7.1.4 Acessando Colunas\nUm objeto do tipo dataframe utiliza-se de diversos comandos e símbolos que também são usados em matrizes e listas. Para descobrir os nomes das colunas de um dataframe, temos duas funções: names() ou colnames() :\n\n# check names of df\nnames(my_df)\n\nR&gt; [1] \"ticker\"   \"ref_date\" \"price\"\n\ncolnames(my_df)\n\nR&gt; [1] \"ticker\"   \"ref_date\" \"price\"\n\n\nAmbas também podem ser usadas para modificar os nomes das colunas:\n\n# set temp df\ntemp_df &lt;- my_df\n\n# check names\nnames(temp_df)\n\nR&gt; [1] \"ticker\"   \"ref_date\" \"price\"\n\n# change names\nnames(temp_df) &lt;- paste0('Col', 1:ncol(temp_df))\n\n# check names\nnames(temp_df)\n\nR&gt; [1] \"Col1\" \"Col2\" \"Col3\"\n\n\nDestaca-se que a forma de usar names() é bastante distinta das demais funções do R. Nesse caso, utilizamos a função ao lado esquerdo do símbolo de assign (&lt;-). Internamente, o que estamos fazendo é definindo um atributo do objeto temp_df, o nome de suas colunas.\nPara acessar uma determinada coluna, podemos utilizar o nome da mesma de diversas formas:\n\n# isolate columns of df\nmy_ticker &lt;- my_df$ticker\nmy_prices &lt;- my_df[['price']]\n\n# print contents\nprint(my_ticker)\n\nR&gt;  [1] \"ABEV3\" \"ABEV3\" \"ABEV3\" \"ABEV3\" \"BBAS3\" \"BBAS3\" \"BBAS3\"\nR&gt;  [8] \"BBAS3\" \"BBDC3\" \"BBDC3\" \"BBDC3\" \"BBDC3\"\n\nprint(my_prices)\n\nR&gt;  [1] 736.67 764.14 768.63 776.47  59.40  59.80  59.20  59.28\nR&gt;  [9]  29.81  30.82  30.38  30.20\n\n\n\n\n\n\n\n\nCuidado!\n\n\n\nToda vez que estiver acessando colunas de um dataframe, o resultado é um vetor atômico com os dados da coluna. Isso é importante saber pois as propriedades do objeto se modificam.\n\n\nNote o uso do duplo colchetes ([[]]) para selecionar colunas. Vale apontar que, no R, um objeto da classe dataframe é representado internamente como uma lista, onde cada elemento é uma coluna. Isso é importante saber, pois alguns comandos de listas também funcionam para dataframes. Um exemplo é o uso de duplo colchetes ([[]]) para selecionar colunas por posição:\n\nprint(my_df[[2]])\n\nR&gt;  [1] \"2010-01-01\" \"2010-01-04\" \"2010-01-05\" \"2010-01-06\"\nR&gt;  [5] \"2010-01-01\" \"2010-01-04\" \"2010-01-05\" \"2010-01-06\"\nR&gt;  [9] \"2010-01-01\" \"2010-01-04\" \"2010-01-05\" \"2010-01-06\"\n\n\nPara acessar linhas e colunas específicas de um dataframe, basta utilizar colchetes simples:\n\nprint(my_df[1:5,2])\n\nR&gt; # A tibble: 5 × 1\nR&gt;   ref_date  \nR&gt;   &lt;date&gt;    \nR&gt; 1 2010-01-01\nR&gt; 2 2010-01-04\nR&gt; 3 2010-01-05\nR&gt; 4 2010-01-06\nR&gt; 5 2010-01-01\n\n\n\nprint(my_df[1:5,c(1,2)])\n\nR&gt; # A tibble: 5 × 2\nR&gt;   ticker ref_date  \nR&gt;   &lt;chr&gt;  &lt;date&gt;    \nR&gt; 1 ABEV3  2010-01-01\nR&gt; 2 ABEV3  2010-01-04\nR&gt; 3 ABEV3  2010-01-05\nR&gt; 4 ABEV3  2010-01-06\nR&gt; 5 BBAS3  2010-01-01\n\n\n\nprint(my_df[1:5, ])\n\nR&gt; # A tibble: 5 × 3\nR&gt;   ticker ref_date   price\nR&gt;   &lt;chr&gt;  &lt;date&gt;     &lt;dbl&gt;\nR&gt; 1 ABEV3  2010-01-01 737. \nR&gt; 2 ABEV3  2010-01-04 764. \nR&gt; 3 ABEV3  2010-01-05 769. \nR&gt; 4 ABEV3  2010-01-06 776. \nR&gt; 5 BBAS3  2010-01-01  59.4\n\n\nEssa seleção de colunas também pode ser realizada utilizando o nome das mesmas da seguinte forma:\n\nprint(my_df[1:3, c('ticker','price')])\n\nR&gt; # A tibble: 3 × 2\nR&gt;   ticker price\nR&gt;   &lt;chr&gt;  &lt;dbl&gt;\nR&gt; 1 ABEV3   737.\nR&gt; 2 ABEV3   764.\nR&gt; 3 ABEV3   769.\n\n\nou, pelo operador de pipeline e a função dplyr::select() :\n\nlibrary(dplyr)\n\nmy.temp &lt;- my_df |&gt;\n  select(ticker, price) |&gt;\n  glimpse()\n\nR&gt; Rows: 12\nR&gt; Columns: 2\nR&gt; $ ticker &lt;chr&gt; \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS3\"…\nR&gt; $ price  &lt;dbl&gt; 736.67, 764.14, 768.63, 776.47, 59.40, 59.8…\n\n\n\n\n7.1.5 Modificando um dataframe\nPara criar novas colunas em um dataframe, basta utilizar a função dplyr::mutate() . Aqui iremos abusar do operador de pipeline (|&gt;) para sequenciar as operações:\n\nlibrary(dplyr)\n\n# add columns with mutate\nmy_df &lt;- my_df |&gt;\n  mutate(ret = price/lag(price) -1,\n         my_seq1 = 1:nrow(my_df),\n         my_seq2 =  my_seq1 +9) |&gt;\n  glimpse()\n\nR&gt; Rows: 12\nR&gt; Columns: 6\nR&gt; $ ticker   &lt;chr&gt; \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS…\nR&gt; $ ref_date &lt;date&gt; 2010-01-01, 2010-01-04, 2010-01-05, 2010…\nR&gt; $ price    &lt;dbl&gt; 736.67, 764.14, 768.63, 776.47, 59.40, 59…\nR&gt; $ ret      &lt;dbl&gt; NA, 0.037289424, 0.005875887, 0.010199966…\nR&gt; $ my_seq1  &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nR&gt; $ my_seq2  &lt;dbl&gt; 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2…\n\n\nNote que precisamos indicar o dataframe de origem dos dados, nesse caso o objeto my_df, e as colunas são definidas como argumentos em dplyr::mutate() . Observe também que usamos a coluna price na construção de ret, o retorno aritmético dos preços. Um caso especial é a construção de my_seq2 com base em my_seq1, isto é, antes mesmo dela ser explicitamente calculada já é possível utilizar a nova coluna para criar outra. Vale salientar que a nova coluna deve ter exatamente o mesmo número de elementos que as demais. Caso contrário, o R retorna uma mensagem de erro.\nA maneira mais tradicional, e comumente encontrada em código, para criar novas colunas é utilizar o símbolo $:\n\n# add new column with base R\nmy_df$my_seq3 &lt;- 1:nrow(my_df)\n\n# check it\nglimpse(my_df)\n\nR&gt; Rows: 12\nR&gt; Columns: 7\nR&gt; $ ticker   &lt;chr&gt; \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS…\nR&gt; $ ref_date &lt;date&gt; 2010-01-01, 2010-01-04, 2010-01-05, 2010…\nR&gt; $ price    &lt;dbl&gt; 736.67, 764.14, 768.63, 776.47, 59.40, 59…\nR&gt; $ ret      &lt;dbl&gt; NA, 0.037289424, 0.005875887, 0.010199966…\nR&gt; $ my_seq1  &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nR&gt; $ my_seq2  &lt;dbl&gt; 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2…\nR&gt; $ my_seq3  &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n\n\nPortanto, o operador $ vale tanto para acessar quanto para criar novas colunas.\nPara remover colunas de um dataframe, basta usar dplyr::select() com operador negativo para o nome das colunas indesejadas:\n\n# removing columns\nmy_df_temp &lt;- my_df |&gt;\n  select(-my_seq1, -my_seq2, -my_seq3) |&gt;\n  glimpse()\n\nR&gt; Rows: 12\nR&gt; Columns: 4\nR&gt; $ ticker   &lt;chr&gt; \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS…\nR&gt; $ ref_date &lt;date&gt; 2010-01-01, 2010-01-04, 2010-01-05, 2010…\nR&gt; $ price    &lt;dbl&gt; 736.67, 764.14, 768.63, 776.47, 59.40, 59…\nR&gt; $ ret      &lt;dbl&gt; NA, 0.037289424, 0.005875887, 0.010199966…\n\n\nNo uso de funções nativas do R, a maneira tradicional de remover colunas é alocar o valor nulo (NULL):\n\n# set temp df\ntemp_df &lt;- my_df\n\n# remove cols\ntemp_df$price &lt;- NULL\ntemp_df$ref_date  &lt;- NULL\n\n# check it\nglimpse(temp_df)\n\nR&gt; Rows: 12\nR&gt; Columns: 5\nR&gt; $ ticker  &lt;chr&gt; \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS3…\nR&gt; $ ret     &lt;dbl&gt; NA, 0.037289424, 0.005875887, 0.010199966,…\nR&gt; $ my_seq1 &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nR&gt; $ my_seq2 &lt;dbl&gt; 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20…\nR&gt; $ my_seq3 &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n\n\n\n\n7.1.6 Filtrando um dataframe\nUma operação bastante comum no R é filtrar linhas de uma tabela de acordo com uma ou mais condições. Por exemplo, caso quiséssemos apenas os dados da ação ABEV3, poderíamos utilizar a função dplyr::filter() para filtrar a tabela:\n\nlibrary(dplyr)\n\n# filter df for single stock\nmy_df_temp &lt;- my_df |&gt;\n  filter(ticker == 'ABEV3') |&gt;\n  glimpse()\n\nR&gt; Rows: 4\nR&gt; Columns: 7\nR&gt; $ ticker   &lt;chr&gt; \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\"\nR&gt; $ ref_date &lt;date&gt; 2010-01-01, 2010-01-04, 2010-01-05, 2010-…\nR&gt; $ price    &lt;dbl&gt; 736.67, 764.14, 768.63, 776.47\nR&gt; $ ret      &lt;dbl&gt; NA, 0.037289424, 0.005875887, 0.010199966\nR&gt; $ my_seq1  &lt;int&gt; 1, 2, 3, 4\nR&gt; $ my_seq2  &lt;dbl&gt; 10, 11, 12, 13\nR&gt; $ my_seq3  &lt;int&gt; 1, 2, 3, 4\n\n\nA função também aceita mais de uma condição. Veja a seguir onde filtramos os dados para 'ABEV3' em datas após ou iguais a '2010-01-05':\n\nlibrary(dplyr)\n# filter df for single stock and date\nmy_df_temp &lt;- my_df |&gt;\n  filter(ticker == 'ABEV3',\n         ref_date &gt;= as.Date('2010-01-05')) |&gt;\n  glimpse()\n\nR&gt; Rows: 2\nR&gt; Columns: 7\nR&gt; $ ticker   &lt;chr&gt; \"ABEV3\", \"ABEV3\"\nR&gt; $ ref_date &lt;date&gt; 2010-01-05, 2010-01-06\nR&gt; $ price    &lt;dbl&gt; 768.63, 776.47\nR&gt; $ ret      &lt;dbl&gt; 0.005875887, 0.010199966\nR&gt; $ my_seq1  &lt;int&gt; 3, 4\nR&gt; $ my_seq2  &lt;dbl&gt; 12, 13\nR&gt; $ my_seq3  &lt;int&gt; 3, 4\n\n\nAqui utilizamos o símbolo == para testar uma igualdade. Iremos estudar mais profundamente a classe de testes lógicos no capítulo Chapter 6.\n\n\n7.1.7 Ordenando um dataframe\nApós a criação ou importação de um dataframe, pode-se ordenar seus componentes de acordo com os valores de alguma coluna. Um caso bastante comum em que é necessário realizar uma ordenação explícita é quando importamos dados financeiros em que as datas não estão em ordem crescente. Na grande maioria das situações, dados temporais devem estar ordenados de acordo com a antiguidade, isto é, dados mais recentes são alocados na última linha da tabela. Essa operação é realizada através do uso da função order() ou dplyr::arrange() .\nComo exemplo, considere a criação de um dataframe com os valores a seguir:\n\n# set df\nmy_df &lt;- tibble::tibble(col1 = c(4,1,2),\n                        col2 = c(1,1,3),\n                        col3 = c('a','b','c'))\n\n# print it\nprint(my_df)\n\nR&gt; # A tibble: 3 × 3\nR&gt;    col1  col2 col3 \nR&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1     4     1 a    \nR&gt; 2     1     1 b    \nR&gt; 3     2     3 c\n\n\nA função order() retorna os índices relativos à ordenação dos valores dados como entrada. Para o caso da primeira coluna de my_df, os índices dos elementos formadores do novo vetor, com seus valores ordenados em forma crescente, são:\n\nidx &lt;- order(my_df$col1)\nprint(idx)\n\nR&gt; [1] 2 3 1\n\n\nPortanto, ao utilizar a saída da função order() como indexador do dataframe, acaba-se ordenando o mesmo de acordo com os valores da coluna col1. Veja a seguir:\n\nmy_df_2 &lt;- my_df[order(my_df$col1), ]\nprint(my_df_2)\n\nR&gt; # A tibble: 3 × 3\nR&gt;    col1  col2 col3 \nR&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1     1     1 b    \nR&gt; 2     2     3 c    \nR&gt; 3     4     1 a\n\n\nEssa operação de ordenamento também pode ser realizada levando em conta mais de uma coluna. Veja o exemplo a seguir, onde se ordena o dataframe pelas colunas col2 e col1.\n\nidx &lt;- order(my_df$col2, my_df$col1)\nmy_df_3 &lt;- my_df[idx, ]\n\nprint(my_df_3)\n\nR&gt; # A tibble: 3 × 3\nR&gt;    col1  col2 col3 \nR&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1     1     1 b    \nR&gt; 2     4     1 a    \nR&gt; 3     2     3 c\n\n\nNo {tidyverse} (Wickham 2023), a forma de ordenar dataframes é pelo uso da função dplyr::arrange() . No caso de ordenamento decrescente, encapsulamos o nome das colunas com desc:\n\n# sort ascending, by col1 and col2\nmy_df &lt;- my_df |&gt;\n  dplyr::arrange(col1, col2) |&gt;\n  print()\n\nR&gt; # A tibble: 3 × 3\nR&gt;    col1  col2 col3 \nR&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1     1     1 b    \nR&gt; 2     2     3 c    \nR&gt; 3     4     1 a\n\n# sort descending, col1 and col2\nmy_df &lt;- my_df |&gt;\n  dplyr::arrange(desc(col1), desc(col2)) |&gt;\n  print()\n\nR&gt; # A tibble: 3 × 3\nR&gt;    col1  col2 col3 \nR&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1     4     1 a    \nR&gt; 2     2     3 c    \nR&gt; 3     1     1 b\n\n\nO resultado prático no uso de dplyr::arrange() é o mesmo de order() . Um dos seus benefícios é a possibilidade de encadeamento de operações através do uso do pipeline.\n\n\n7.1.8 Combinando e Agregando dataframes\nEm muitas situações de análise de dados, tabelas de diferentes arquivos são importadas no R e, antes de analisar os dados, precisamos combinar as informações em um único objeto. Nos casos mais simples, onde as tabelas a serem agregadas possuem o mesmo formato, nós as juntamos de acordo com as linhas, verticalmente, ou colunas, horizontalmente. Para esse fim, temos as funções dplyr::bind_rows() e dplyr::bind_cols() no tidyverse e rbind() e cbind() nas funções nativas do R.\n\nlibrary(dplyr)\n\n# set dfs\nmy_df_1 &lt;- tibble(col1 = 1:5,\n                  col2 = rep('a', 5))\n\nmy_df_2 &lt;- tibble(col1 = 6:10,\n                  col2 = rep('b', 5),\n                  col3 = rep('c', 5))\n\n# bind by row\nmy_df &lt;- bind_rows(my_df_1, my_df_2) |&gt;\n  glimpse()\n\nR&gt; Rows: 10\nR&gt; Columns: 3\nR&gt; $ col1 &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\nR&gt; $ col2 &lt;chr&gt; \"a\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"b\", …\nR&gt; $ col3 &lt;chr&gt; NA, NA, NA, NA, NA, \"c\", \"c\", \"c\", \"c\", \"c\"\n\n\nNote que, no exemplo anterior, os nomes das colunas são os mesmos. De fato, a função dplyr::bind_rows() procura os nomes iguais em ambos os objetos para fazer a junção dos dataframes corretamente. As colunas que não ocorrem em ambos objetos, tal como col3 no exemplo, saem como NA no objeto final. Já para o caso de dplyr::bind_cols() , os nomes das colunas devem ser diferentes, porém o número de linhas deve ser o mesmo.\n\n# set dfs\nmy_df_1 &lt;- tibble(col1 = 1:5, col2 = rep('a', 5))\nmy_df_2 &lt;- tibble(col3 = 6:10, col4 = rep('b', 5))\n\n# bind by column\nmy_df &lt;- bind_cols(my_df_1, my_df_2) |&gt;\n  glimpse()\n\nR&gt; Rows: 5\nR&gt; Columns: 4\nR&gt; $ col1 &lt;int&gt; 1, 2, 3, 4, 5\nR&gt; $ col2 &lt;chr&gt; \"a\", \"a\", \"a\", \"a\", \"a\"\nR&gt; $ col3 &lt;int&gt; 6, 7, 8, 9, 10\nR&gt; $ col4 &lt;chr&gt; \"b\", \"b\", \"b\", \"b\", \"b\"\n\n\nPara casos mais complexos, onde a junção deve ser realizada de acordo com algum índice tal como uma data, é possível juntar dataframes diferentes com o uso das funções da família dplyr::join* tal como dplyr::inner_join() , dplyr::left_join() , dplyr::right_join() , entre outras. A descrição de todas elas não cabe aqui. Iremos descrever apenas o caso mais provável, dplyr::inner_join() . Essa combina os dados, mantendo apenas os casos onde existe o índice em ambos.\n\n# set df\nmy_df_1 &lt;- dplyr::tibble(date = as.Date('2016-01-01')+0:10,\n                  x = 1:11)\n\nmy_df_2 &lt;- dplyr::tibble(date = as.Date('2016-01-05')+0:10,\n                  y = seq(20,30, length.out = 11))\n\nNote que os dataframes criados possuem uma coluna em comum, date. A partir desta coluna que agregamos as tabelas com dplyr::inner_join() :\n\n# aggregate tables\nmy_df &lt;- dplyr::inner_join(my_df_1, my_df_2)\n\nR&gt; Joining with `by = join_by(date)`\n\nglimpse(my_df)\n\nR&gt; Rows: 7\nR&gt; Columns: 3\nR&gt; $ date &lt;date&gt; 2016-01-05, 2016-01-06, 2016-01-07, 2016-01-…\nR&gt; $ x    &lt;int&gt; 5, 6, 7, 8, 9, 10, 11\nR&gt; $ y    &lt;dbl&gt; 20, 21, 22, 23, 24, 25, 26\n\n\nO R automaticamente verifica a existência de colunas com mesmo nome nos dataframes e realiza a junção por essas. Caso quiséssemos juntar dataframes onde os nomes das colunas para utilizar o índice não são iguais, temos duas soluções: modificar os nomes das colunas ou então utilizar argumento by em dplyr::inner_join() . Veja a seguir:\n\n# set df\nmy_df_3 &lt;- dplyr::tibble(ref_date = as.Date('2016-01-01')+0:10,\n                  x = 1:11)\n\nmy_df_4 &lt;- dplyr::tibble(my_date = as.Date('2016-01-05')+0:10,\n                  y = seq(20,30, length.out = 11))\n\n# join by my_df_3$ref_date and my_df_4$my_date\nmy_df &lt;- dplyr::inner_join(my_df_3, my_df_4,\n                    by = c('ref_date' = 'my_date'))\n\nglimpse(my_df)\n\nR&gt; Rows: 7\nR&gt; Columns: 3\nR&gt; $ ref_date &lt;date&gt; 2016-01-05, 2016-01-06, 2016-01-07, 2016…\nR&gt; $ x        &lt;int&gt; 5, 6, 7, 8, 9, 10, 11\nR&gt; $ y        &lt;dbl&gt; 20, 21, 22, 23, 24, 25, 26\n\n\nPara o caso de uso da função nativa de agregação de dataframes, merge() , temos que indicar explicitamente o nome da coluna com argumento by:\n\n# aggregation with base R\nmy_df &lt;- merge(my_df_1, my_df_2, by = 'date')\n\nglimpse(my_df)\n\nR&gt; Rows: 7\nR&gt; Columns: 3\nR&gt; $ date &lt;date&gt; 2016-01-05, 2016-01-06, 2016-01-07, 2016-01-…\nR&gt; $ x    &lt;int&gt; 5, 6, 7, 8, 9, 10, 11\nR&gt; $ y    &lt;dbl&gt; 20, 21, 22, 23, 24, 25, 26\n\n\nNote que, nesse caso, o dataframe resultante manteve apenas as informações compartilhadas entre ambos os objetos, isto é, aquelas linhas onde as datas em date eram iguais. Esse é o mesmo resultado quando no uso do dplyr::inner_join() .\nAs demais funções de agregação de tabelas – dplyr::left_join() , dplyr::right_join() e dplyr::full_join() – funcionam de forma muito semelhante a dplyr::inner_join() , exceto na escolha da saída. Por exemplo, dplyr::full_join() retorna todos os casos/linhas entre tabela 1 e 2, incluindo aqueles onde não tem o índice compartilhado. Para estes casos, a coluna do índice sairá como NA. Veja o exemplo a seguir:\n\n# set df\nmy_df_5 &lt;- dplyr::tibble(ref_date = as.Date('2016-01-01')+0:10,\n                  x = 1:11)\n\nmy_df_6 &lt;- dplyr::tibble(ref_date = as.Date('2016-01-05')+0:10,\n                  y = seq(20,30, length.out = 11))\n\n# combine with full_join\nmy_df &lt;- dplyr::full_join(my_df_5, my_df_6)\n\nR&gt; Joining with `by = join_by(ref_date)`\n\n# print it\nprint(my_df)\n\nR&gt; # A tibble: 15 × 3\nR&gt;    ref_date       x     y\nR&gt;    &lt;date&gt;     &lt;int&gt; &lt;dbl&gt;\nR&gt;  1 2016-01-01     1    NA\nR&gt;  2 2016-01-02     2    NA\nR&gt;  3 2016-01-03     3    NA\nR&gt;  4 2016-01-04     4    NA\nR&gt;  5 2016-01-05     5    20\nR&gt;  6 2016-01-06     6    21\nR&gt;  7 2016-01-07     7    22\nR&gt;  8 2016-01-08     8    23\nR&gt;  9 2016-01-09     9    24\nR&gt; 10 2016-01-10    10    25\nR&gt; 11 2016-01-11    11    26\nR&gt; 12 2016-01-12    NA    27\nR&gt; 13 2016-01-13    NA    28\nR&gt; 14 2016-01-14    NA    29\nR&gt; 15 2016-01-15    NA    30\n\n\n\n\n7.1.9 Extensões ao dataframe\nUm dos grandes benefícios no uso do R é a existência de pacotes para lidar com os problemas específicos dos usuários. Enquanto um objeto tabular do tipo tibble é suficiente para a maioria dos casos, existem benefícios no uso de uma classe alternativa. Ao longo do tempo, diversas soluções foram disponibilizadas por desenvolvedores.\nPor exemplo, é muito comum trabalharmos com dados exclusivamente numéricos que são indexados ao tempo. Isto é, situações onde cada informação pertence a um índice temporal - um objeto da classe data/tempo. As linhas dessa tabela representam um ponto no tempo, enquanto as colunas indicam variáveis numéricas de interesse. Nesse caso, faria sentido representarmos os nossos dados como objetos do tipo {xts} (Ryan and Ulrich 2024). O grande benefício dessa opção é que a agregação e a manipulação de variáveis em função do tempo é muito fácil. Por exemplo, podemos transformar dados de frequência diária para a frequência semanal com apenas uma linha de comando. Além disso, diversas outras funções reconhecem automaticamente que os dados são indexados ao tempo. Um exemplo é a criação de uma figura com esses dados. Neste caso, o eixo horizontal da figura é automaticamente organizado com as datas.\nVeja um caso a seguir, onde carregamos os dados anteriores como um objeto {xts} (Ryan and Ulrich 2024):\n\nlibrary(xts)\n\nR&gt; Loading required package: zoo\n\n\nR&gt; \nR&gt; Attaching package: 'zoo'\n\n\nR&gt; The following objects are masked from 'package:base':\nR&gt; \nR&gt;     as.Date, as.Date.numeric\n\n\nR&gt; \nR&gt; ######################### Warning from 'xts' package ##########################\nR&gt; #                                                                             #\nR&gt; # The dplyr lag() function breaks how base R's lag() function is supposed to  #\nR&gt; # work, which breaks lag(my_xts). Calls to lag(my_xts) that you type or       #\nR&gt; # source() into this session won't work correctly.                            #\nR&gt; #                                                                             #\nR&gt; # Use stats::lag() to make sure you're not using dplyr::lag(), or you can add #\nR&gt; # conflictRules('dplyr', exclude = 'lag') to your .Rprofile to stop           #\nR&gt; # dplyr from breaking base R's lag() function.                                #\nR&gt; #                                                                             #\nR&gt; # Code in packages is not affected. It's protected by R's namespace mechanism #\nR&gt; # Set `options(xts.warn_dplyr_breaks_lag = FALSE)` to suppress this warning.  #\nR&gt; #                                                                             #\nR&gt; ###############################################################################\n\n\nR&gt; \nR&gt; Attaching package: 'xts'\n\n\nR&gt; The following objects are masked from 'package:dplyr':\nR&gt; \nR&gt;     first, last\n\n# set data\nticker &lt;- c('ABEV3', 'BBAS3','BBDC3')\n\ndate &lt;- as.Date(c('2010-01-01', '2010-01-04',\n                  '2010-01-05', '2010-01-06'))\n\nprice_ABEV3 &lt;- c(736.67, 764.14, 768.63, 776.47)\nprice_BBAS3 &lt;- c(59.4, 59.8, 59.2, 59.28)\nprice_BBDC3 &lt;- c(29.81, 30.82, 30.38, 30.20)\n\n# build matrix\nmy_mat &lt;- matrix(c(price_BBDC3, price_BBAS3, price_ABEV3),\n                 nrow = length(date) )\n\n# set xts object\nmy_xts &lt;- xts(my_mat,\n              order.by = date)\n\n# set correct colnames\ncolnames(my_xts) &lt;- ticker\n\n# check it!\nprint(my_xts)\n\nR&gt;            ABEV3 BBAS3  BBDC3\nR&gt; 2010-01-01 29.81 59.40 736.67\nR&gt; 2010-01-04 30.82 59.80 764.14\nR&gt; 2010-01-05 30.38 59.20 768.63\nR&gt; 2010-01-06 30.20 59.28 776.47\n\n\nO código anterior pode dar a impressão de que o objeto my_xts é semelhante a um dataframe, porém, não se engane. Por estar indexado a um vetor de tempo, objeto my_xts pode ser utilizado para uma série de procedimentos temporais, tal como uma agregação por período temporal. Veja o exemplo a seguir, onde agregamos duas variáveis de tempo através do cálculo de uma média a cada semana.\n\nN &lt;- 500\n\nmy_mat &lt;- matrix(c(seq(1, N), seq(N, 1)), nrow=N)\n\nmy_xts &lt;- xts(my_mat, order.by = as.Date('2016-01-01')+1:N)\n\nmy_xts.weekly.mean &lt;- apply.weekly(my_xts, mean)\n\nR&gt; NOTE: `apply.weekly(..., FUN = mean)` operates by column, unlike other math\nR&gt;   functions (e.g. median, sum, var, sd). Please use `FUN = colMeans` instead,\nR&gt;   and use `FUN = function(x) mean(x)` to take the mean of all columns. Set\nR&gt;   `options(xts.message.period.apply.mean = FALSE)` to suppress this message.\n\nprint(head(my_xts.weekly.mean))\n\nR&gt;             X.1   X.2\nR&gt; 2016-01-03  1.5 499.5\nR&gt; 2016-01-10  6.0 495.0\nR&gt; 2016-01-17 13.0 488.0\nR&gt; 2016-01-24 20.0 481.0\nR&gt; 2016-01-31 27.0 474.0\nR&gt; 2016-02-07 34.0 467.0\n\n\nEm Finanças e Economia, as agregações com objetos {xts} (Ryan and Ulrich 2024) são extremamente úteis quando se trabalha com dados em frequências de tempo diferentes. Por exemplo, é muito comum que se agregue dados de transação no mercado financeiro em alta frequência para intervalos maiores. Assim, dados que ocorrem a cada segundo são agregados para serem representados de 15 em 15 minutos. Esse tipo de procedimento é facilmente realizado no R através da correta representação dos dados como objetos {xts} (Ryan and Ulrich 2024). Existem diversas outras funcionalidades desse pacote. Encorajo os usuários a ler o manual e aprender o que pode ser feito.\nIndo além, existem diversos outros tipos de dataframes customizados. Por exemplo, o dataframe proposto pelo pacote {data.table} (Barrett et al. 2024) prioriza o tempo de operação nos dados e o uso de uma notação compacta para acesso e processamento. O {tibbletime} (Vaughan and Dancho 2023) é uma versão orientada pelo tempo para tibbles. Caso o usuário esteja necessitando realizar operações de agregação de tempo, o uso deste pacote é fortemente recomendado.\n\n\n7.1.10 Outras Funções Úteis\nhead() - Retorna os primeiros n elementos de um dataframe.\n\nmy_df &lt;- tibble(col1 = 1:5000, col2 = rep('a', 5000))\nhead(my_df, 5)\n\nR&gt; # A tibble: 5 × 2\nR&gt;    col1 col2 \nR&gt;   &lt;int&gt; &lt;chr&gt;\nR&gt; 1     1 a    \nR&gt; 2     2 a    \nR&gt; 3     3 a    \nR&gt; 4     4 a    \nR&gt; 5     5 a\n\n\ntail() - Retorna os últimos n elementos de um dataframe.\n\ntail(my_df, 5)\n\nR&gt; # A tibble: 5 × 2\nR&gt;    col1 col2 \nR&gt;   &lt;int&gt; &lt;chr&gt;\nR&gt; 1  4996 a    \nR&gt; 2  4997 a    \nR&gt; 3  4998 a    \nR&gt; 4  4999 a    \nR&gt; 5  5000 a\n\n\ncomplete.cases() - Retorna um vetor lógico que testa se as linhas contêm apenas valores existentes e nenhum NA.\n\nmy_x &lt;- c(1:5, NA, 10)\nmy_y &lt;- c(5:10, NA)\nmy_df &lt;- tibble(my_x, my_y)\n\nprint(my_df)\n\nR&gt; # A tibble: 7 × 2\nR&gt;    my_x  my_y\nR&gt;   &lt;dbl&gt; &lt;int&gt;\nR&gt; 1     1     5\nR&gt; 2     2     6\nR&gt; 3     3     7\nR&gt; 4     4     8\nR&gt; 5     5     9\nR&gt; 6    NA    10\nR&gt; 7    10    NA\n\nprint(complete.cases(my_df))\n\nR&gt; [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n\nprint(which(!complete.cases(my_df)))\n\nR&gt; [1] 6 7\n\n\nna.omit() - Retorna um dataframe sem as linhas onde valores NA são encontrados.\n\nprint(na.omit(my_df))\n\nR&gt; # A tibble: 5 × 2\nR&gt;    my_x  my_y\nR&gt;   &lt;dbl&gt; &lt;int&gt;\nR&gt; 1     1     5\nR&gt; 2     2     6\nR&gt; 3     3     7\nR&gt; 4     4     8\nR&gt; 5     5     9\n\n\nunique() - Retorna um dataframe onde todas as linhas duplicadas são eliminadas e somente os casos únicos são mantidos.\n\nmy_df &lt;- tibble(col1 = c(1,1,2,3,3,4,5),\n                col2 = c('A','A','A','C','C','B','D'))\n\nprint(my_df)\n\nR&gt; # A tibble: 7 × 2\nR&gt;    col1 col2 \nR&gt;   &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1     1 A    \nR&gt; 2     1 A    \nR&gt; 3     2 A    \nR&gt; 4     3 C    \nR&gt; 5     3 C    \nR&gt; 6     4 B    \nR&gt; 7     5 D\n\nprint(unique(my_df))\n\nR&gt; # A tibble: 5 × 2\nR&gt;    col1 col2 \nR&gt;   &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1     1 A    \nR&gt; 2     2 A    \nR&gt; 3     3 C    \nR&gt; 4     4 B    \nR&gt; 5     5 D",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>As Classes de Armazenamento</span>"
    ]
  },
  {
    "objectID": "07-objetos-armazenamento.html#sec-listas",
    "href": "07-objetos-armazenamento.html#sec-listas",
    "title": "7  As Classes de Armazenamento",
    "section": "7.2 Listas",
    "text": "7.2 Listas\nUma lista (list) é uma classe de objeto extremamente flexível e já tivemos contato com ela nos capítulos anteriores. Ao contrário de vetores atômicos, a lista não apresenta restrição alguma em relação aos tipos de elementos nela contidos. Podemos agrupar valores numéricos com caracteres, fatores com datas e até mesmo listas dentro de listas. Quando agrupamos vetores, também não é necessário que os mesmos tenham um número igual de elementos. Além disso, podemos dar um nome a cada elemento. Essas propriedades fazem da lista o objeto mais flexível para o armazenamento e estruturação de dados no R. Não é acidental o fato de que listas são muito utilizadas como retorno de funções.\n\n7.2.1 Criando Listas\nUma lista pode ser criada através do comando list() , seguido por seus elementos separados por vírgula:\n\nlibrary(dplyr)\n\n# create list\nmy_l &lt;- list(c(1, 2, 3),\n             c('a', 'b'),\n             factor('A', 'B', 'C'),\n             tibble(col1 = 1:5))\n\n# use base::print\nprint(my_l)\n\nR&gt; [[1]]\nR&gt; [1] 1 2 3\nR&gt; \nR&gt; [[2]]\nR&gt; [1] \"a\" \"b\"\nR&gt; \nR&gt; [[3]]\nR&gt; [1] &lt;NA&gt;\nR&gt; Levels: C\nR&gt; \nR&gt; [[4]]\nR&gt; # A tibble: 5 × 1\nR&gt;    col1\nR&gt;   &lt;int&gt;\nR&gt; 1     1\nR&gt; 2     2\nR&gt; 3     3\nR&gt; 4     4\nR&gt; 5     5\n\n# use dplyr::glimpse\nglimpse(my_l)\n\nR&gt; List of 4\nR&gt;  $ : num [1:3] 1 2 3\nR&gt;  $ : chr [1:2] \"a\" \"b\"\nR&gt;  $ : Factor w/ 1 level \"C\": NA\nR&gt;  $ : tibble [5 × 1] (S3: tbl_df/tbl/data.frame)\nR&gt;   ..$ col1: int [1:5] 1 2 3 4 5\n\n\nNote que juntamos no mesmo objeto um vetor atômico numérico, outro de texto, um fator e um tibble. A apresentação de listas com o comando print() é diferente dos casos anteriores. Os elementos são separados verticalmente e os seus índices aparecem com duplo colchete ([[ ]]). Conforme será explicado logo a seguir, é dessa forma que os elementos de uma lista são armazenados e acessados.\nAssim como para os demais tipos de objeto, os elementos de uma lista também podem ter nomes, o que facilita o entendimento e a interpretação das informações do problema em análise. Por exemplo, considere o caso de uma base de dados com informações sobre determinada ação negociada na bolsa. Nesse caso, podemos definir uma lista como:\n\n# set named list\nmy_named_l &lt;- list(ticker = 'TICK4',\n                   market = 'Bovespa',\n                   df_prices = tibble(P = c(1,1.5,2,2.3),\n                                      ref_date = Sys.Date()+0:3))\n\n# check content\nglimpse(my_named_l)\n\nR&gt; List of 3\nR&gt;  $ ticker   : chr \"TICK4\"\nR&gt;  $ market   : chr \"Bovespa\"\nR&gt;  $ df_prices: tibble [4 × 2] (S3: tbl_df/tbl/data.frame)\nR&gt;   ..$ P       : num [1:4] 1 1.5 2 2.3\nR&gt;   ..$ ref_date: Date[1:4], format: \"2024-04-07\" ...\n\n\n\n\n\n\n\n\nUse nomes em listas e dataframes!\n\n\n\nComo regra geral no uso do R, sempre dê preferência ao acesso de elementos através de seus nomes, seja em listas, vetores ou dataframes. Isso evita erros, pois, ao modificar os dados e adicionar algum outro objeto na lista, é possível que o ordenamento interno mude e, portanto, a posição de determinado objeto pode acabar sendo modificada.\n\n\n\n\n7.2.2 Acessando os Elementos de uma Lista\nOs elementos de uma lista podem ser acessados através do uso de duplo colchete ([[ ]]), tal como em:\n\n# accessing elements from list\nprint(my_named_l[[2]])\n\nR&gt; [1] \"Bovespa\"\n\nprint(my_named_l[[3]])\n\nR&gt; # A tibble: 4 × 2\nR&gt;       P ref_date  \nR&gt;   &lt;dbl&gt; &lt;date&gt;    \nR&gt; 1   1   2024-04-07\nR&gt; 2   1.5 2024-04-08\nR&gt; 3   2   2024-04-09\nR&gt; 4   2.3 2024-04-10\n\n\nTambém é possível acessar os elementos com um colchete simples ([ ]), porém, tome cuidado com essa operação, pois o resultado não vai ser o objeto em si, mas uma outra lista. Esse é um equívoco muito fácil de passar despercebido, resultando em erros no código. Veja a seguir:\n\n# set list\nmy_l &lt;- list('a',\n             c(1,2,3),\n             factor('a','b'))\n\n# check classes\nclass(my_l[[2]])\n\nR&gt; [1] \"numeric\"\n\nclass(my_l[2])\n\nR&gt; [1] \"list\"\n\n\nCaso tentarmos somar um elemento a my_l[2], teremos uma mensagem de erro:\n\nmy_l[2] + 1\n\nR&gt; Error in my_l[2] + 1: non-numeric argument to binary operator\n\n\nEsse erro ocorre devido ao fato de que uma lista não tem operador de soma. Para corrigir, basta utilizar o duplo colchete, tal como em my_l[[2]]+1. O acesso a elementos de uma lista com colchete simples somente é útil quando estamos procurando uma sublista dentro de uma lista maior. No exemplo anterior, caso quiséssemos obter o primeiro e o segundo elemento da lista my_l, usaríamos:\n\n# set new list\nmy_new_l &lt;- my_l[c(1,2)]\n\n# check contents\nprint(my_new_l)\n\nR&gt; [[1]]\nR&gt; [1] \"a\"\nR&gt; \nR&gt; [[2]]\nR&gt; [1] 1 2 3\n\nclass(my_new_l)\n\nR&gt; [1] \"list\"\n\n\nNo caso de listas com elementos nomeados, os mesmos podem ser acessados por seu nome através do uso do símbolo $ tal como em my_named_l$df_prices ou [['nome']], tal como em my_named_l[['df_prices']]. Em geral, essa é uma forma mais eficiente e recomendada de interagir com os elementos de uma lista.\n\n\n\n\n\n\nDica\n\n\n\nSaiba que a ferramenta de autocomplete do RStudio também funciona para listas. Para usar, digite o nome da lista seguido de $ e aperte tab. Uma caixa de diálogo com todos os elementos disponíveis na lista irá aparecer. A partir disso, basta selecionar apertando enter.\n\n\nVeja os exemplos a seguir, onde são apresentadas as diferentes formas de se acessar uma lista.\n\n# different ways to access a list\nmy_named_l$ticker\nmy_named_l$price\nmy_named_l[['ticker']]\nmy_named_l[['price']]\n\nVale salientar que também é possível acessar diretamente os elementos de um vetor que esteja dentro de uma lista através de colchetes encadeados. Veja a seguir:\n\n# accessing elements of a vector in a list\nmy_l &lt;- list(c(1,2,3),\n             c('a', 'b'))\n\nprint(my_l[[1]][2])\n\nR&gt; [1] 2\n\nprint(my_l[[2]][1])\n\nR&gt; [1] \"a\"\n\n\nTal operação é bastante útil quando interessa apenas um elemento dentro de um objeto maior criado por alguma função.\n\n\n7.2.3 Adicionando e Removendo Elementos de uma Lista\nA remoção, adição e substituição de elementos de uma lista também são procedimentos fáceis. Para adicionar ou substituir, basta definir um novo objeto na posição desejada da lista:\n\n# set list\nmy_l &lt;- list('a', 1, 3)\ndplyr::glimpse(my_l)\n\nR&gt; List of 3\nR&gt;  $ : chr \"a\"\nR&gt;  $ : num 1\nR&gt;  $ : num 3\n\n# add new elements to list\nmy_l[[4]] &lt;- c(1:5)\nmy_l[[2]] &lt;- c('b')\n\n# print result\ndplyr::glimpse(my_l)\n\nR&gt; List of 4\nR&gt;  $ : chr \"a\"\nR&gt;  $ : chr \"b\"\nR&gt;  $ : num 3\nR&gt;  $ : int [1:5] 1 2 3 4 5\n\n\nA operação também é possível com o uso de nomes e operador $:\n\n# set list\nmy_l &lt;- list(elem1 = 'a', name1=5)\n\n# set new element\nmy_l$name2 &lt;- 10\ndplyr::glimpse(my_l)\n\nR&gt; List of 3\nR&gt;  $ elem1: chr \"a\"\nR&gt;  $ name1: num 5\nR&gt;  $ name2: num 10\n\n\nPara remover elementos de uma lista, basta definir o elemento para o símbolo reservado NULL (nulo):\n\n# set list\nmy_l &lt;- list(text = 'b', num1 = 2, num2 = 4)\ndplyr::glimpse(my_l)\n\nR&gt; List of 3\nR&gt;  $ text: chr \"b\"\nR&gt;  $ num1: num 2\nR&gt;  $ num2: num 4\n\n# remove elements\nmy_l[[3]] &lt;- NULL\ndplyr::glimpse(my_l)\n\nR&gt; List of 2\nR&gt;  $ text: chr \"b\"\nR&gt;  $ num1: num 2\n\nmy_l$num1 &lt;- NULL\ndplyr::glimpse(my_l)\n\nR&gt; List of 1\nR&gt;  $ text: chr \"b\"\n\n\nOutra maneira de retirar elementos de uma lista é utilizando um índice negativo para os elementos indesejados. Observe a seguir, onde eliminamos o segundo elemento de uma lista:\n\n# set list\nmy_l &lt;- list(a = 1, b = 'texto')\n\n# remove second element\ndplyr::glimpse(my_l[[-2]])\n\nR&gt;  num 1\n\n\nAssim como no caso de vetores atômicos, essa remoção também pode ser realizada por condições lógicas. Veja a seguir:\n\n# set list\nmy_l &lt;- list(1, 2, 3, 4)\n\n# remove elements by condition\nmy_l[my_l &gt; 2] &lt;- NULL\ndplyr::glimpse(my_l)\n\nR&gt; List of 2\nR&gt;  $ : num 1\nR&gt;  $ : num 2\n\n\nPorém, note que esse atalho só funciona porque todos os elementos de my_l são numéricos.\n\n\n7.2.4 Processando os Elementos de uma Lista\nUm ponto importante a ser destacado a respeito de listas é que os seus elementos podem ser processados e manipulados individualmente através de funções específicas. Este é um tópico particular de programação com o R, mas que vale a apresentação aqui.\nPor exemplo, imagine uma lista com vetores numéricos de diferentes tamanhos, tal como a seguir:\n\n# set list\nmy_l_num &lt;- list(c(1, 2, 3),\n                 seq(1:50),\n                 seq(-5, 5, by = 0.5))\n\nCaso quiséssemos calcular a média de cada elemento de my_l_num e apresentar o resultado na tela como um vetor, poderíamos fazer isso através de um procedimento simples, processando cada elemento individualmente:\n\n# calculate mean of vectors\nmean_1 &lt;- mean(my_l_num[[1]])\nmean_2 &lt;- mean(my_l_num[[2]])\nmean_3 &lt;- mean(my_l_num[[3]])\n\n# print it\nprint(c(mean_1, mean_2, mean_3))\n\nR&gt; [1]  2.0 25.5  0.0\n\n\nO código anterior funciona, porém não é recomendado devido sua falta de escalabilidade. Isto é, caso aumentássemos o volume de dados ou objetos, o código não funcionaria corretamente. Se, por exemplo, tivéssemos um quarto elemento em my_l_num e quiséssemos manter essa estrutura do código, teríamos que adicionar uma nova linha mean_4 &lt;- mean(my_l_num[[4]]) e modificar o comando de saída na tela para print(c(mean_1, mean_2, mean_3, mean_4)).\nUma maneira mais fácil, elegante e inteligente seria utilizar a função sapply() . Nela, basta indicar o nome do objeto de tipo lista e a função que queremos utilizar para processar cada elemento. Internamente, os cálculos são realizados automaticamente. Veja a seguir:\n\n# using sapply\nmy_mean &lt;- sapply(my_l_num, mean)\n\n# print result\nprint(my_mean)\n\nR&gt; [1]  2.0 25.5  0.0\n\n\nO uso da função sapply() é preferível por ser mais compacto e eficiente do que a alternativa – a criação de mean_1, mean_2 e mean_3. Note que o primeiro código, com médias individuais, só funciona para uma lista com três elementos. A função sapply() , ao contrário, funcionaria da mesma forma em listas de qualquer tamanho. Caso tivéssemos mais elementos, nenhuma modificação seria necessária no código anterior, o que o torna extensível a chegada de novos dados.\nEssa visão e implementação de código voltado a procedimentos genéricos é um dos lemas para tornar o uso do R mais eficiente. A regra é simples: sempre escreva códigos que sejam adaptáveis a chegada de novos dados. Em inglês, isso é chamado de regra DRY (don’t repeat yourself). Caso você esteja repetindo códigos e abusando do control + c/control + v, como no exemplo anterior, certamente existe uma solução mais elegante e flexível que poderia ser utilizada. No R, existem diversas outras funções da família apply para esse objetivo.\n\n\n7.2.5 Outras Funções Úteis\nunlist() - Retorna os elementos de uma lista em um único vetor atômico.\n\nmy_named_l &lt;- list(ticker = 'XXXX4',\n                   price = c(1,1.5,2,3),\n                   market = 'Bovespa')\nmy_unlisted &lt;- unlist(my_named_l)\nprint(my_unlisted)\n\nR&gt;    ticker    price1    price2    price3    price4    market \nR&gt;   \"XXXX4\"       \"1\"     \"1.5\"       \"2\"       \"3\" \"Bovespa\"\n\nclass(my_unlisted)\n\nR&gt; [1] \"character\"\n\n\nas.list() - Converte um objeto para uma lista, tornando cada elemento um elemento da lista.\n\nmy_x &lt;- 10:13\nmy_x_as_list &lt;- as.list(my_x)\nprint(my_x_as_list)\n\nR&gt; [[1]]\nR&gt; [1] 10\nR&gt; \nR&gt; [[2]]\nR&gt; [1] 11\nR&gt; \nR&gt; [[3]]\nR&gt; [1] 12\nR&gt; \nR&gt; [[4]]\nR&gt; [1] 13\n\n\nnames() - Retorna ou define os nomes dos elementos de uma lista. Assim como para o caso de nomear elementos de um vetor atômico, usa-se a função names() alocada ao lado esquerdo do símbolo &lt;-.\n\nmy_l &lt;- list(value1 = 1, value2 = 2, value3 = 3)\nprint(names(my_l))\n\nR&gt; [1] \"value1\" \"value2\" \"value3\"\n\nmy_l &lt;- list(1,2,3)\nnames(my_l) &lt;- c('num1', 'num2', 'num3')\nprint(my_l)\n\nR&gt; $num1\nR&gt; [1] 1\nR&gt; \nR&gt; $num2\nR&gt; [1] 2\nR&gt; \nR&gt; $num3\nR&gt; [1] 3",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>As Classes de Armazenamento</span>"
    ]
  },
  {
    "objectID": "07-objetos-armazenamento.html#exercícios",
    "href": "07-objetos-armazenamento.html#exercícios",
    "title": "7  As Classes de Armazenamento",
    "section": "7.3 Exercícios",
    "text": "7.3 Exercícios\n\nQ.1 - Usando a função dplyr::tibble() , crie um dataframe chamado my_df, o qual possui uma coluna chamada x contendo uma sequência de -100 a 100, e outra coluna chamada y com o valor da coluna x somado por 5. Quantos valores na coluna x são maiores que 10 e menores que 25?\n\n7\n5\n14\n2\n10\n\n\nQ.2 - Crie uma nova coluna no objeto my_df chamada cumsum_x, contendo a soma cumulativa de x (função cumsum() ). Nesta nova coluna, quantos valores são maiores que -3500?\n\n29\n63\n46\n12\n89\n\n\nQ.3 - Use a função dplyr::filter() e o operador de pipeline para filtrar my_df, mantendo apenas as linhas onde o valor da coluna y é maior que 0. Qual é o número de linhas na tabela resultante?\n\n158\n137\n116\n105\n178\n\n\nQ.4 - Caso não o tenha feito, repita os exercícios 1, 2 e 3 utilizando as funções do {tidyverse} (Wickham 2023) e o operador de pipeline.\n\nQ.5 - Use o pacote {yfR} (Perlin 2023) para baixar dados de ações do Google (GOOG), de 2015-01-01 a 2017-10-28. Se o investidor tivesse comprado 1500 USD em ações do Google no primeiro dia dos dados e mantivesse o investimento até hoje, qual seria o valor da sua carteira?\n\nR$ 2.320,84\nR$ 2.921,25\nR$ 554,57\nR$ 1.143,32\nR$ 1.732,08\n\n\n\n\n\nBarrett, Tyson, Matt Dowle, Arun Srinivasan, Jan Gorecki, Michael Chirico, and Toby Hocking. 2024. Data.table: Extension of ‘Data.frame‘. https://r-datatable.com.\n\n\nPerlin, Marcelo. 2023. yfR: Downloads and Organizes Financial Data from Yahoo Finance. https://github.com/ropensci/yfR.\n\n\nR Core Team. 2023. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/.\n\n\nRyan, Jeffrey A., and Joshua M. Ulrich. 2024. Xts: eXtensible Time Series. https://joshuaulrich.github.io/xts/.\n\n\nVaughan, Davis, and Matt Dancho. 2023. Tibbletime: Time Aware Tibbles. https://github.com/business-science/tibbletime.\n\n\nWickham, Hadley. 2023. Tidyverse: Easily Install and Load the Tidyverse. https://tidyverse.tidyverse.org.\n\n\nWickham, Hadley, Romain François, Lionel Henry, Kirill Müller, and Davis Vaughan. 2023. Dplyr: A Grammar of Data Manipulation. https://dplyr.tidyverse.org.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>As Classes de Armazenamento</span>"
    ]
  },
  {
    "objectID": "08-importacao-exportacao-dados.html",
    "href": "08-importacao-exportacao-dados.html",
    "title": "8  Importação e Exportação de Dados",
    "section": "",
    "text": "8.1 Primeiros passos\nA primeira lição na importação de dados para o R é que o local do arquivo deve ser indicado explicitamente no código. Este endereço é passado para a função que irá ler o arquivo. Veja a definição a seguir:\nmy_file &lt;- 'C:/Data/MyData.csv'\nNote o uso de barras (/) para designar o diretório do arquivo. Referências relativas também funcionam, tal como em:\nmy_file &lt;- 'Data/MyData.csv'\nNeste caso, assume-se que na pasta atual de trabalho existe um diretório chamado Data e, dentro desse, um arquivo denominado MyData.csv. Se o endereço do arquivo é simplesmente o seu nome, assume-se que o mesmo encontra-se na raiz da pasta de trabalho. Para verificar o endereço atual de trabalho, utilize a função getwd() .\nUm ponto importante aqui é que os dados serão importados e exportados no R como objetos do tipo dataframe (veja Section 7.1). Isto é, uma tabela contida em um arquivo Excel ou .csv se transformará em um objeto do tipo dataframe no ambiente de trabalho do R. Quando exportarmos dados, o formato mais comum é esse mesmo tipo de objeto. Quando realizando a importação, é de fundamental importância que os dados sejam representados na classe correta. Uma vasta quantidade de erros podem ser evitados pela simples checagem das classes das colunas no dataframe resultante do processo de importação.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Importação e Exportação de Dados</span>"
    ]
  },
  {
    "objectID": "08-importacao-exportacao-dados.html#primeiros-passos",
    "href": "08-importacao-exportacao-dados.html#primeiros-passos",
    "title": "8  Importação e Exportação de Dados",
    "section": "",
    "text": "Use o autocomplete para achar o caminho de arquivos!\n\n\n\nAqui novamente reforço o uso do tab e autocomplete do RStudio. É muito mais fácil e prático encontrar arquivos do disco rígido do computador usando a navegação via tab do que copiar e colar o endereço do seu explorador de arquivos. Para usar, abra aspas no RStudio, coloque o cursor do mouse entre as aspas e aperte tab.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Importação e Exportação de Dados</span>"
    ]
  },
  {
    "objectID": "08-importacao-exportacao-dados.html#arquivos-csv",
    "href": "08-importacao-exportacao-dados.html#arquivos-csv",
    "title": "8  Importação e Exportação de Dados",
    "section": "8.2 Arquivos csv",
    "text": "8.2 Arquivos csv\nConsidere o arquivo de dados no formato csv chamado 'CH04_ibovespa.csv', pertencente ao repositório do livro. Vamos copiar o mesmo para a pasta “Meus Documentos” com o uso do tilda (~):\n\n# get location of file\nmy_f &lt;- introR::data_path('CH04_ibovespa.csv')\n\n# copy to ~\nfs::file_copy(my_f, '~' )\n\n\n\nR&gt; [1] TRUE\n\n\nCaso seja a primeira vez trabalhando com arquivos do tipo .csv, sugiro usar o explorador de arquivos do Windows e abrir CH04_ibovespa.csv com qualquer editor de texto instalado, tal como o Notepad (veja Figure 8.1). Observe que as primeiras linhas do arquivo definem os nomes das colunas: ref_date e price_close. Conforme notação internacional, as linhas são definidas pela quebra do texto e as colunas pelo uso da vírgula (,).\n\n\n\n\n\n\n\n\nFigure 8.1: Exemplo de arquivo .csv no Notepad\n\n\n\n\n\n\n\n\n\n\n\nO Formato Brasileiro\n\n\n\nQuando trabalhando com dados brasileiros, a notação internacional pode gerar uma confusão desnecessária. Dados locais tendem a usar a vírgula para indicar valores decimais em números, assim como também datas no formato dia/mês/ano. Abaixo apresenta-se algumas regras de formatação de números e códigos para o caso brasileiro.\nDecimal: O decimal no R é definido pelo ponto (.), tal como em 2.5 e não vírgula, como em 2,5. Esse é o padrão internacional, e a diferença para a notação brasileira gera muita confusão. Em nenhuma situação deve-se utilizar a vírgula como separador de casas decimais. Mesmo quando estiver exportando dados, sempre dê prioridade para o formato internacional.\nCaracteres latinos: Devido ao seu padrão internacional, o R apresenta problemas para entender caracteres latinos, tal como cedilha e acentos. Caso possa evitar, não utilize esses tipos de caracteres no código para nomeação de variáveis ou arquivos. Nos objetos de classe texto (character), é possível utilizá-los desde que a codificação do objeto esteja correta (UTF-8 ou Latin1). Assim, recomenda-se que o código do R seja escrito na língua inglesa.\nFormato das datas: Datas no R são formatadas de acordo com a norma ISO 8601, seguindo o padrão YYYY-MM-DD, onde YYYY é o ano em quatro números, MM é o mês e DD é o dia. Por exemplo, uma data em ISO 8601 é 2024-04-07. No Brasil, as datas são formatadas como DD/MM/YYYY. Reforçando a regra, sempre dê preferência ao padrão internacional. Vale salientar que a conversão entre um formato e outro é bastante fácil e foi mostrada na Section 6.5.\n\n\nO conteúdo de CH04_ibovespa.csv é bastante conservador e não será difícil importar o seu conteúdo. Porém, saiba que muitas vezes o arquivo .csv vem com informações extras de cabeçalho – o chamado metadata – ou diferentes formatações que exigem adaptações. Como sugestão para evitar problemas, antes de prosseguir para a importação de dados em um arquivo .csv, abra o arquivo em um editor de texto qualquer e siga os seguintes passos:\n\nVerifique a existência de texto antes dos dados e a necessidade de ignorar algumas linhas iniciais. A maioria dos arquivos .csv não contém cabeçalho, porém deves sempre checar. No R, a função de leitura de arquivos .csv possui uma opção para ignorar um definido número de linhas antes de começar a leitura do arquivo;\nVerifique a existência ou não dos nomes das colunas na primeira linha com os dados. Em caso negativo, verifique com o autor qual o nome (e significado) das colunas;\nVerifique qual o símbolo de separador de colunas. Comumente, seguindo notação internacional, será a vírgula, porém nunca se tem certeza sem checar;\nPara dados numéricos, verifique o símbolo de decimal, o qual deve ser o ponto (.) tal como em 2.5. Caso necessário, podes ajustar o símbolo na própria função de leitura;\nVerifique a codificação do arquivo de texto. Normalmente é UTF-8, Latin1 (ISO-8859) ou windows1252. Esses são formatos amplos e devem ser suficientes para a maioria dos idiomas. Sempre que você encontrar símbolos estranhos nas colunas de texto do dataframe resultante, o problema é devido a uma diferença na codificação entre o arquivo e o R. Os usuários do Windows podem verificar a codificação de um arquivo de texto abrindo-o no software Notepad++. As informações sobre a codificação estarão disponíveis no canto inferior direito do editor. No entanto, você precisa estar ciente de que o Notepad++ não faz parte da instalação do Windows e pode ser necessário instalá-lo em seu computador. Os usuários de Linux e Mac podem encontrar as mesmas informações em qualquer software editor de texto avançado, como o Kate e o vscode.\n\n\n\n\n\n\n\nNão modifique dados brutos!\n\n\n\nSempre que você encontrar uma estrutura de texto inesperada em um arquivo .csv, use os argumentos da função de leitura csv para importar as informações corretamente. Repetindo, nunca modifique dados brutos do arquivo a ser importado. Use o código para lidar com diferentes estruturas de arquivos em formato csv. Pode parecer mais trabalhoso, mas essa política vai economizar muito tempo no futuro, pois, em algumas semanas, você provavelmente esquecerá como limpou manualmente aquele arquivo csv utilizado em pesquisa passada. Com o uso de código para a adaptação da importação de dados, sempre que você precisar atualizar o arquivo de dados, o código irá resolver todos os problemas, automatizando o processo.\n\n\n\n8.2.1 Importação de Dados\nO R possui uma função nativa chamada read.csv() para importar dados de arquivos .csv. Porém, esse é um dos muitos casos em que a alternativa do {tidyverse} (Wickham 2023) – readr::read_csv() – é mais eficiente e mais fácil de trabalhar. Resumindo, readr::read_csv() lê arquivos mais rapidamente que read.csv() , além de usar regras mais inteligentes para definir as classes das colunas importadas.\n\n# set file to read\nmy_f &lt;- introR::data_path('CH04_ibovespa.csv')\n\n# read data\nmy_df_ibov &lt;- readr::read_csv(my_f)\n\nO conteúdo do arquivo importado é convertido para um objeto do tipo dataframe no R. Conforme mencionado em Section 7.1, cada coluna de um dataframe tem uma classe. Podemos verificar as classes de my_df_ibov usando a função dplyr::glimpse() :\n\n# check content\ndplyr::glimpse(my_df_ibov)\n\nR&gt; Rows: 3,215\nR&gt; Columns: 2\nR&gt; $ ref_date    &lt;date&gt; 2010-01-04, 2010-01-05, 2010-01-06, 2…\nR&gt; $ price_close &lt;dbl&gt; 70045, 70240, 70729, 70451, 70263, 704…\n\n\nObserve que a coluna de datas (ref_date) foi importada como um vetor Date e os preços de fechamento como numéricos (dbl, precisão dupla). Isso é exatamente o que esperávamos. Internamente, a função readr::read_csv() identifica as classes das colunas de acordo com seu conteúdo.\nObserve também como o código anterior apresentou a mensagem de título Column specification. Essa mensagem mostra como a função identifica as classes das colunas lendo as primeiras 1000 linhas do arquivo. Regras inteligentes tentam prever a classe com base no conteúdo importado. Para definir manualmente as classes das colunas, podemos utilizar as funções readr::cols() e readr::col_*:\n\nlibrary(readr)\n\n# set cols from readr import message\nmy_cols &lt;- cols(\n  price_close = col_double(),\n  ref_date = col_date(format = \"\")\n)\n\n# read file with readr::read_csv\nmy_df_ibov &lt;- read_csv(my_f,\n                       col_types = my_cols)\n\nComo um exercício, vamos importar os mesmos dados, porém usando a classe character (texto) para colunas ref_date:\n\n# set cols from readr import message\nmy_cols &lt;- cols(\n  price_close = col_double(),\n  ref_date = col_character()\n)\n\n# read file with readr::read_csv\nmy_df_ibov &lt;- read_csv(my_f,\n                       col_types = my_cols)\n\n# check content\nglimpse(my_df_ibov)\n\nR&gt; Rows: 3,215\nR&gt; Columns: 2\nR&gt; $ ref_date    &lt;chr&gt; \"2010-01-04\", \"2010-01-05\", \"2010-01-0…\nR&gt; $ price_close &lt;dbl&gt; 70045, 70240, 70729, 70451, 70263, 704…\n\n\nComo esperado, a coluna de datas – ref_date – agora foi importada como texto. Assim, o uso de readr::read_csv() pode ser resumido em duas etapas: 1) leia o arquivo sem argumentos em readr::read_csv() ; 2) copie o texto das classes de coluna padrão da mensagem de saída e adicione como entrada col_types. O conjunto de passos anterior é suficiente para a grande maioria dos casos. O uso da mensagem com as classes das colunas é particularmente útil quando o arquivo importado tem várias colunas e a definição manual de cada classe exige muita digitação.\nUma alternativa mais prática no uso do readr::read_csv() é confiar na heurística da função e usar a definição padrão das colunas automaticamente. Para isto, basta definir a entrada col_types como a função readr::cols() , sem argumento. Veja a seguir:\n\n# read file with readr::read_csv\nmy_df_ibov &lt;- read_csv(my_f,\n                       col_types = cols())\n\n\n8.2.1.1 Um caso anormal\nAgora, vamos estudar um caso anormal de arquivo .csv. No pacote do livro temos um arquivo chamado CH04_funky-csv-file.csv onde:\n\no cabeçalho possui texto com informações dos dados;\no arquivo usará a vírgula como decimal;\no texto do arquivo conterá caracteres latinos.\n\nAs primeiras 10 linhas dos arquivos contém o seguinte conteúdo:\n\n\nR&gt; Example of funky file:\nR&gt; - columns separated by \";\"\nR&gt; - decimal points as \",\"\nR&gt; \nR&gt; Data build in 2022-12-28\nR&gt; Origin: www.funkysite.com.br\nR&gt; \nR&gt; ID;Race;Age;Sex;Hour;IQ;Height;Died\nR&gt; 001;White;80;Male;00:00:00;92;68;FALSE\nR&gt; 002;Hispanic;25;Female;00:00:00;99;68;TRUE\n\n\nNote a existência do cabeçalho até linha de número 7 e as colunas sendo separadas pela símbolo de semi-vírgula (“;”).\nAo importar os dados com opções padrões (e erradas), teremos o resultado a seguir:\n\ndf_funky &lt;- readr::read_csv(my_f, \n                     col_types = readr::cols())\n\ndplyr::glimpse(df_funky)\n\nR&gt; Rows: 2\nR&gt; Columns: 1\nR&gt; $ `Example of funky file:` &lt;chr&gt; \"- columns separated by \\…\n\n\nClaramente a importação deu errado, com a emissão de diversas mensagens de warning. Para resolver, utilizamos o seguinte código, estruturando todas as particularidades do arquivo:\n\ndf_not_funky &lt;- readr::read_delim(file = my_f, \n                           skip = 7, # how many lines do skip\n                           delim = ';', # column separator\n                           col_types = readr::cols(), # column types\n                           locale = readr::locale(decimal_mark = ',')# locale\n)\n\ndplyr::glimpse(df_not_funky)\n\nR&gt; Rows: 100\nR&gt; Columns: 8\nR&gt; $ ID     &lt;chr&gt; \"001\", \"002\", \"003\", \"004\", \"005\", \"006\", \"…\nR&gt; $ Race   &lt;chr&gt; \"White\", \"Hispanic\", \"Asian\", \"White\", \"Whi…\nR&gt; $ Age    &lt;dbl&gt; 80, 25, 25, 64, 76, 89, 33, 61, 23, 59, 80,…\nR&gt; $ Sex    &lt;chr&gt; \"Male\", \"Female\", \"Male\", \"Male\", \"Female\",…\nR&gt; $ Hour   &lt;time&gt; 00:00:00, 00:00:00, 00:00:00, 00:00:00, 00…\nR&gt; $ IQ     &lt;dbl&gt; 92, 99, 98, 105, 109, 84, 109, 109, 99, 126…\nR&gt; $ Height &lt;dbl&gt; 68, 68, 69, 69, 67, 73, 65, 72, 70, 66, 63,…\nR&gt; $ Died   &lt;lgl&gt; FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE…\n\n\nVeja que agora os dados foram corretamente importados, com as classes corretas das colunas. Para isso, usamos a função alternativa readr::read_delim() . O pacote {readr} (Wickham, Hester, and Bryan 2024) também possui várias outras funções para situações específicas de importação. Caso a função readr::read_csv() não resolva o seu problema na leitura de algum arquivo de dados estruturado em texto, certamente outra função desse pacote resolverá.\n\n\n\n8.2.2 Exportação de Dados\nPara exportar tabelas em um arquivo .csv, basta utilizar a função readr::write_csv() . No próximo exemplo iremos criar dados artificiais, salvar em um dataframe e exportar para um arquivo .csv temporário. Veja a seguir:\n\nlibrary(readr)\n\n# set number of observations\nN &lt;- 100\n\n# create dataframe with random data\nmy_df &lt;- data.frame(y = runif(N),\n                    z = rep('a', N))\n\n# write to file\nf_out &lt;- tempfile(fileext = '.csv')\nwrite_csv(x = my_df, file = f_out)\n\nNo exemplo anterior, salvamos o dataframe chamado my_df para o arquivo filedf60702fa783.csv, localizado na pasta temporária do computador. Podemos verificar o arquivo importando o seu conteúdo:\n\nmy_df &lt;- read_csv(f_out,\n                  col_types = cols(y = col_double(),\n                                   z = col_character() ) )\nprint(head(my_df))\n\nR&gt; # A tibble: 6 × 2\nR&gt;        y z    \nR&gt;    &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1 0.320  a    \nR&gt; 2 0.0185 a    \nR&gt; 3 0.694  a    \nR&gt; 4 0.264  a    \nR&gt; 5 0.238  a    \nR&gt; 6 0.794  a\n\n\nO resultado está conforme o esperado, um dataframe com duas colunas, a primeira com números e a segunda com texto.\nNote que toda exportação com função readr::write_csv() irá ser formatada, por padrão, com a notação internacional. Caso quiser algo diferentes, verifique as opções disponíveis na função readr::write_delim() , a qual é muito mais flexível.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Importação e Exportação de Dados</span>"
    ]
  },
  {
    "objectID": "08-importacao-exportacao-dados.html#arquivos-excel-xls-e-xlsx",
    "href": "08-importacao-exportacao-dados.html#arquivos-excel-xls-e-xlsx",
    "title": "8  Importação e Exportação de Dados",
    "section": "8.3 Arquivos Excel (xls e xlsx)",
    "text": "8.3 Arquivos Excel (xls e xlsx)\nEm Finanças e Economia, é bastante comum encontrarmos dados salvos em arquivos do tipo Microsoft Excel, com extensão .xls (antiga) ou .xlsx (moderna). Apesar de não ser um formato de armazenamento de dados eficiente, esse é um programa de planilhas bastante popular devido às suas funcionalidades. É muito comum que informações sejam armazenadas e distribuídas dessa forma. Por exemplo, dados históricos do Tesouro Direto são disponibilizados como arquivos .xls no site do tesouro nacional. A CVM (Comissão de Valores Mobiliários) e ANBIMA (Associação Brasileira das Entidades dos Mercados Financeiro e de Capitais) também tem preferência por esse tipo de formato em alguns dados publicados em seu site.\nA desvantagem de usar arquivos do Excel para armazenar dados é sua baixa portabilidade e o maior tempo necessário para leitura e gravação. Isso pode não ser um problema para tabelas pequenas, mas ao lidar com um grande volume de dados, o uso de arquivos Excel é frustrante e não aconselhável. Se possível, evite o uso de arquivos do Excel em seu ciclo de trabalho.\n\n8.3.1 Importação de Dados\nO R não possui uma função nativa para importar dados do Excel e, portanto, deve-se instalar e utilizar certos pacotes para realizar essa operação. Existem diversas opções, porém, os principais pacotes são, em ordem de importância, {readxl} (Wickham and Bryan 2023), {xlsx} (Dragulescu and Arendt 2020), {tidyxl} (Garmonsway 2023) e {XLConnect} (Mirai Solutions GmbH 2024).\nApesar de os pacotes anteriores terem objetivos semelhantes, cada um tem suas peculiaridades. Caso a leitura de arquivos do Excel seja algo importante no seu trabalho, aconselho-o fortemente a estudar as diferenças entre esses pacotes. Por exemplo, pacote {tidyxl} (Garmonsway 2023) permite a leitura de dados não-estruturados de um arquivo Excel, enquanto {XLConnect} (Mirai Solutions GmbH 2024) possibilita a abertura de uma conexão ativa entre o R e o Excel, onde o usuário pode transmitir dados entre um e o outro, formatar células, criar gráficos no Excel e muito mais. Nesta seção, daremos prioridade para funções do pacote {readxl} (Wickham and Bryan 2023), o qual é um dos mais fáceis e diretos de se utilizar.\nImagine agora a existência de um arquivo chamado CH04_ibovespa-Excel.xlsx que contenha os mesmos dados do Ibovespa que importamos na seção anterior. A importação das informações contidas nesse arquivo para o R será realizada através da função readxl::read_excel() :\n\nlibrary(readxl)\nlibrary(dplyr)\n\n# set file\nmy_f &lt;- introR::data_path(\"CH04_ibovespa-Excel.xlsx\")\n\n# read xlsx into dataframe\nmy_df &lt;- read_excel(my_f, sheet = 'Sheet1')\n\n# glimpse contents\nglimpse(my_df)\n\nR&gt; Rows: 3,215\nR&gt; Columns: 2\nR&gt; $ ref_date    &lt;dttm&gt; 2010-01-04, 2010-01-05, 2010-01-06, 2…\nR&gt; $ price_close &lt;dbl&gt; 70045, 70240, 70729, 70451, 70263, 704…\n\n\nObserve que, nesse caso, as datas já foram importadas com a formatação correta na classe dttm (datetime). Essa é uma vantagem ao utilizar arquivos do Excel: a classe dos dados do arquivo original é levada em conta no momento da importação. O lado negativo desse formato é a baixa portabilidade dos dados e o maior tempo necessário para a execução da importação. Como regra geral, dados importados do Excel apresentarão um tempo de carregamento mais alto do que dados importados de arquivos .csv.\n\n\n8.3.2 Exportação de Dados\nA exportação para arquivo Excel também é fácil. Assim como para a importação, não existe uma função nativa do R que execute esse procedimento. Para tal tarefa, temos pacotes {xlsx} (Dragulescu and Arendt 2020) e {writexl} (Ooms 2024). Para fins de ilustração de uso, vamos utilizar o pacote {writexl} (Ooms 2024)\n\n# set number of rows\nN &lt;- 50\n\n# create random dataframe\nmy_df &lt;- data.frame(y = seq(1,N),\n                    z = rep('a',N))\n\n# write to xlsx\nf_out &lt;- fs::file_temp(ext = '.xlsx')\n\nwritexl::write_xlsx(x = my_df, path = f_out)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Importação e Exportação de Dados</span>"
    ]
  },
  {
    "objectID": "08-importacao-exportacao-dados.html#formato-.rdata-e-.rds",
    "href": "08-importacao-exportacao-dados.html#formato-.rdata-e-.rds",
    "title": "8  Importação e Exportação de Dados",
    "section": "8.4 Formato .RData e .rds",
    "text": "8.4 Formato .RData e .rds\nO R possui dois formatos nativos para salvar objetos de sua área de trabalho para um arquivo local com extensão RData ou rds. O grande benefício, em ambos os casos, é que o arquivo resultante é compacto e o seu acesso é muito rápido. A desvantagem é que os dados perdem portabilidade para outros programas. A diferença entre um formato e outro é que arquivos RData podem salvar mais de um objeto, enquanto o formato .rds salva apenas um. Na prática, porém, essa não é uma restrição forte. No R existe um objeto do tipo lista que incorpora outros. Portanto, caso salvarmos uma lista em um arquivo .rds, podemos gravar no disco quantos objetos forem necessários.\n\n8.4.1 Importação de Dados\nPara carregar os dados de um aquivo RData, utilizamos a função load() :\n\n# set a object\nmy_x &lt;- 1:100\n\n# set temp name of RData file\nmy_file &lt;- introR::data_path('CH04_example-Rdata.RData')\n\n# load it\nload(file = my_file)\n\nO arquivo CH04_example-Rdata.RData possui dois objetos, my_x e my_y, os quais se tornam disponíveis na área de trabalho depois da chamada de load() .\nO processo de importação para arquivos .rds é muito semelhante. A diferença é no uso da função readr::read_rds() :\n\n# set file path\nmy_file &lt;- introR::data_path('CH04_example-rds.rds')\n\n# load content into workspace\nmy_x &lt;- readr::read_rds(file = my_file)\n\nComparando o código entre o uso de arquivos .RData e .rds, note que um benefício no uso de .rds é a explícita definição do objeto na área de trabalho. Isto é, o conteúdo de my_file em readr::read_rds() é explicitamente salvo em my_x. Quando usamos a função load() , no código não fica claro qual o nome do objeto que foi importado. Isso é particularmente inconveniente quando é necessário modificar o nome do objeto importado.\n\n\n\n\n\n\nUse formato rds\n\n\n\nComo sugestão, dê preferência ao uso do formato .rds, o qual deve resultar em códigos mais transparentes. A diferença de velocidade de acesso e gravação entre um e outro é mínima. O benefício de importar vários objetos em um mesmo arquivo com o formato RData torna-se irrelevante quando no uso de objetos do tipo lista (veja Section 7.2), os quais podem incorporar outros objetos no seu conteúdo.\n\n\n\n\n8.4.2 Exportação de Dados\nPara criar um novo arquivo RData, utilizamos a função save() :\n\n# set vars\nmy_x &lt;- 1:100\nmy_y &lt;- 1:100\n\n# write to RData\nmy_file &lt;- fs::file_temp(ext = '.RData')\nsave(list = c('my_x', 'my_y'),\n     file = my_file)\n\nPodemos verificar a existência do arquivo::\n\nfs::file_exists(my_file)\n\nR&gt; /tmp/Rtmp5YLLCq/filedf6036bf7e8.RData \nR&gt;                                  TRUE\n\n\nObserve que o arquivo filedf6036bf7e8.RData está disponível na pasta temporária.\nJá para arquivos .rds, salvamos o objeto com função readr::write_rds() :\n\n# set data and file\nmy_x &lt;- 1:100\nmy_file &lt;- fs::file_temp(ext = \".rds\")\n\n# save as .rds\nreadr::write_rds(my_x, my_file)\n\n# read it\nmy_x2 &lt;- readr::read_rds(my_file)\n\n# test equality\nprint(identical(my_x, my_x2))\n\nR&gt; [1] TRUE\n\n\nO comando identical() testa a igualdade entre os objetos e, como esperado, verificamos que my_x e my_x2 são exatamente iguais.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Importação e Exportação de Dados</span>"
    ]
  },
  {
    "objectID": "08-importacao-exportacao-dados.html#arquivos-fst",
    "href": "08-importacao-exportacao-dados.html#arquivos-fst",
    "title": "8  Importação e Exportação de Dados",
    "section": "8.5 Arquivos fst",
    "text": "8.5 Arquivos fst\nPacote {fst} (Klik 2022) foi especialmente desenhado para possibilitar a gravação e leitura de dados tabulares de forma rápida e com mínimo uso do espaço no disco. O uso deste formato é particularmente benéfico quando se está trabalhando com volumosas bases de dados em computadores potentes. O grande truque do formato fst é usar todos núcleos do computador para importar e exportar dados, enquanto todos os demais formatos se utilizam de apenas um. Como logo veremos, o ganho em velocidade é bastante significativo.\n\n8.5.1 Importação de Dados\nO uso do formato fst é bastante simples. Utilizamos a função fst::read_fst() para ler arquivos:\n\nlibrary(fst)\n\nmy_file &lt;- introR::data_path('CH04_example-fst.fst')\nmy_df &lt;- read_fst(my_file)\n\ndplyr::glimpse(my_df)\n\nR&gt; Rows: 100\nR&gt; Columns: 8\nR&gt; $ ID     &lt;chr&gt; \"001\", \"002\", \"003\", \"004\", \"005\", \"006\", \"…\nR&gt; $ Race   &lt;fct&gt; Black, White, Hispanic, Black, White, White…\nR&gt; $ Age    &lt;int&gt; 33, 35, 23, 87, 65, 51, 58, 67, 22, 52, 52,…\nR&gt; $ Sex    &lt;fct&gt; Male, Female, Male, Female, Male, Male, Fem…\nR&gt; $ Hour   &lt;dbl&gt; 0.00000000, 0.00000000, 0.00000000, 0.00000…\nR&gt; $ IQ     &lt;dbl&gt; 108, 108, 85, 106, 92, 92, 88, 100, 86, 80,…\nR&gt; $ Height &lt;dbl&gt; 72, 63, 77, 72, 71, 74, 64, 69, 63, 72, 70,…\nR&gt; $ Died   &lt;lgl&gt; FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE…\n\n\nAssim como para os demais casos, os dados estão disponíveis na área de trabalho após a importação.\n\n\n8.5.2 Exportação de Dados\nUtilizamos a função fst::write_fst() para gravar arquivos no formato fst, :\n\nlibrary(fst)\n\n# create dataframe\nN &lt;- 1000\nmy_file &lt;- fs::file_temp(ext = '.fst')\nmy_df &lt;- data.frame(x = runif(N))\n\n# write to fst\nwrite_fst(x = my_df, path = my_file)\n\n\n\n8.5.3 Testando o Tempo de Execução do Formato fst\nComo um teste do potencial do pacote {fst} (Klik 2022), a seguir vamos cronometrar o tempo de leitura e gravação entre fst e rds para um dataframe com grande quantidade de dados: 5,000,000 linhas e 2 colunas. Iremos reportar também o tamanho do arquivo resultante.\n\nlibrary(fst)\n\n# set number of rows\nN &lt;- 5000000\n\n# create random dfs\nmy_df &lt;- data.frame(y = seq(1,N),\n                    z = rep('a',N))\n\n# set files\nmy_file_rds &lt;- fs::file_temp(ext = \".rds\")\nmy_file_fst &lt;- fs::file_temp(ext = \".fst\")\n\n# test write\ntime_write_rds &lt;- system.time(readr::write_rds(my_df, my_file_rds ))\ntime_write_fst &lt;- system.time(fst::write_fst(my_df, my_file_fst ))\n\n# test read\ntime_read_rds &lt;- system.time(readr::read_rds(my_file_rds))\ntime_read_fst &lt;- system.time(fst::read_fst(my_file_fst))\n\n# test file size (MB)\nfile_size_rds &lt;- file.size(my_file_rds)/1000000\nfile_size_fst &lt;- file.size(my_file_fst)/1000000\n\nApós a execução, vamos verificar o resultado:\n\n# results\nmy_formats &lt;- c('.rds', '.fst')\nresults_read &lt;- c(time_read_rds[3], time_read_fst[3])\nresults_write&lt;- c(time_write_rds[3], time_write_fst[3])\nresults_file_size &lt;- c(file_size_rds , file_size_fst)\n\n# print text\nmy_text &lt;- paste0('\\nTime to WRITE dataframe with ',\n                  my_formats, ': ',\n                  results_write, ' seconds', collapse = '')\nmessage(my_text)\n\nR&gt; \nR&gt; Time to WRITE dataframe with .rds: 0.609 seconds\nR&gt; Time to WRITE dataframe with .fst: 0.093 seconds\n\nmy_text &lt;- paste0('\\nTime to READ dataframe with ',\n                  my_formats, ': ',\n                  results_read, ' seconds', collapse = '')\nmessage(my_text)\n\nR&gt; \nR&gt; Time to READ dataframe with .rds: 0.761 seconds\nR&gt; Time to READ dataframe with .fst: 0.106 seconds\n\nmy_text &lt;- paste0('\\nResulting FILE SIZE for ',\n                  my_formats, ': ',\n                  results_file_size, ' MBs', collapse = '')\nmessage(my_text)\n\nR&gt; \nR&gt; Resulting FILE SIZE for .rds: 65.000177 MBs\nR&gt; Resulting FILE SIZE for .fst: 14.791938 MBs\n\n\nA diferença é gritante! O formato fst não somente lê e grava com mais rapidez mas o arquivo resultante também é menor. Porém, saiba que os resultados anteriores foram compilados em um computador com 16 núcleos. É possível que a diferença de tempo para um computador mais modesto não seja tão significativa.\n\n\n\n\n\n\nUse formato fst para banco de dados volumosos\n\n\n\nDevido ao uso de todos os núcleos do computador, o formato fst é altamente recomendado quando estiver trabalhando com dados volumosos em um computador potente. Não somente os arquivos resultantes serão menores, mas o processo de gravação e leitura será consideravelmente mais rápido.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Importação e Exportação de Dados</span>"
    ]
  },
  {
    "objectID": "08-importacao-exportacao-dados.html#dados-não-estruturados-e-outros-formatos",
    "href": "08-importacao-exportacao-dados.html#dados-não-estruturados-e-outros-formatos",
    "title": "8  Importação e Exportação de Dados",
    "section": "8.6 Dados Não-Estruturados e Outros Formatos",
    "text": "8.6 Dados Não-Estruturados e Outros Formatos\nOs pacotes e formatos anteriores são suficientes para resolver o problema de importação de dados na grande maioria das situações. Apesar disso, vale destacar que o R possui outras funções específicas para diferentes formatos. Isso inclui arquivos exportados de outros softwares, tal como SPSS, Matlab, entre vários outros. Se esse for o seu caso, sugiro um estudo aprofundado do pacote {foreign} (R Core Team 2023).\nEm alguns casos nos deparamos com dados armazenados de uma forma não estruturada, tal como um texto qualquer. Pode-se importar o conteúdo de um arquivo de texto linha por linha através da função readr::read_lines() . Veja o exemplo a seguir, onde importamos o conteúdo inteiro do livro Pride and Prejudice:\n\n# set file to read\nmy_f &lt;- introR::data_path('CH04_price-and-prejudice.txt')\n\n# read file line by line\nmy_txt &lt;- readr::read_lines(my_f)\n\n# print 50 characters of first fifteen lines\nprint(stringr::str_sub(string = my_txt[1:15], \n              start = 1, \n              end = 50))\n\nR&gt;  [1] \"                            [Illustration:\"        \nR&gt;  [2] \"\"                                                  \nR&gt;  [3] \"                             GEORGE ALLEN\"         \nR&gt;  [4] \"                               PUBLISHER\"          \nR&gt;  [5] \"\"                                                  \nR&gt;  [6] \"                        156 CHARING CROSS ROAD\"    \nR&gt;  [7] \"                                LONDON\"            \nR&gt;  [8] \"\"                                                  \nR&gt;  [9] \"                             RUSKIN HOUSE\"         \nR&gt; [10] \"                                   ]\"              \nR&gt; [11] \"\"                                                  \nR&gt; [12] \"                            [Illustration:\"        \nR&gt; [13] \"\"                                                  \nR&gt; [14] \"               _Reading Jane’s Letters._      _Cha\"\nR&gt; [15] \"                                   ]\"\n\n\nNeste exemplo, arquivo CH04_price-and-prejudice.txt contém todo o conteúdo do livro Pride and Prejudice de Jane Austen, disponível gratuitamente pelo projeto Gutenberg. Importamos todo o conteúdo do arquivo como um vetor de texto denominado my_txt.\n\n8.6.1 Exportando de Dados Não-Estruturados\nEm algumas situações, é necessário exportar algum tipo de texto para um arquivo. Por exemplo: quando se precisa salvar o registro de um procedimento em um arquivo de texto; ou quando se precisa gravar informações em um formato específico não suportado pelo R. Esse procedimento é bastante simples. Junto à função readr::write_lines() , basta indicar um arquivo de texto para a saída com o argumento file. Veja a seguir:\n\n# set file\nmy_f &lt;- fs::file_temp(ext = '.txt')\n\n# set some string\nmy_text &lt;- paste0('Today is ', Sys.Date(), '\\n', \n                  'Tomorrow is ', Sys.Date()+1)\n\n# save string to file\nreadr::write_lines(x = my_text, file = my_f, append = FALSE)\n\nNo exemplo, criamos um objeto de texto com uma mensagem sobre a data atual e gravamos a saída no arquivo temporário filedf6056dd718a.txt. Podemos checar o resultado com a função readr::read_lines() :\n\nprint(readr::read_lines(my_f))\n\nR&gt; [1] \"Today is 2024-04-07\"    \"Tomorrow is 2024-04-08\"",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Importação e Exportação de Dados</span>"
    ]
  },
  {
    "objectID": "08-importacao-exportacao-dados.html#selecionando-o-formato",
    "href": "08-importacao-exportacao-dados.html#selecionando-o-formato",
    "title": "8  Importação e Exportação de Dados",
    "section": "8.7 Selecionando o Formato",
    "text": "8.7 Selecionando o Formato\nApós entendermos a forma de salvar e carregar dados de arquivos locais em diferentes formatos, é importante discutirmos sobre a escolha do formato. O usuário deve levar em conta três pontos nessa decisão:\n\nvelocidade de importação e exportação;\ntamanho do arquivo resultante;\ncompatibilidade com outros programas e sistemas.\n\nNa grande maioria das situações, o uso de arquivos csv satisfaz esses quesitos. Ele nada mais é do que um arquivo de texto que pode ser aberto, visualizado e importado em qualquer programa. Desse modo, fica muito fácil compartilhar dados compatíveis com outros usuários. Além disso, o tamanho de arquivos csv geralmente não é exagerado em computadores modernos. Caso necessário, podes compactar o arquivo .csv usando o programa 7zip, o qual irá diminuir consideravelmente o tamanho do arquivo. Por esses motivos, o uso de arquivos csv para importações e exportações é preferível na grande maioria das situações.\nExistem casos, porém, onde a velocidade de importação e exportação pode fazer diferença. Caso abrir mão de portabilidade não faça diferença ao projeto, o formato rds é ótimo e prático. Se este não foi suficiente, então a melhor alternativa é partir para o fst, o qual usa maior parte do hardware do computador para importar os dados. Como sugestão, caso puder, apenas evite o formato do Excel, o qual é o menos eficiente de todos.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Importação e Exportação de Dados</span>"
    ]
  },
  {
    "objectID": "08-importacao-exportacao-dados.html#importacao-pacotes",
    "href": "08-importacao-exportacao-dados.html#importacao-pacotes",
    "title": "8  Importação e Exportação de Dados",
    "section": "8.8 Importação de dados via Pacotes",
    "text": "8.8 Importação de dados via Pacotes\nUma das grandes vantagens de se utilizar o R é a quantidade de dados que podem ser importados através da internet, seja via download de arquivos ou APIs oficiais. Isso é especialmente prático pois uma base de dados pode ser atualizada através de um simples comando, evitando o tedioso trabalho de coleta manual. Ao usarmos pacotes para importar dados, esta etapa da pesquisa se torna reproduzível e mais rápida, facilitando o compartilhamento e futura execução do nosso código. O uso de pacotes para a importação de dados externos é uma tendência muito forte no uso do R, e é importante que entenda o processo funciona.\nAbaixo segue uma lista e descrição de pacotes importante na área de finanças e economia, os quais uso fortemente no meu dia a dia como professor e pesquisador. Mesmo que você não seja da área, poderás retirar ótimas lições aqui sobre como realizar a importação dos dados da internet.\n\n{yfR} (Perlin 2023b)\n\nImporta dados de preços diários de ações e índices do Yahoo Finance.\n\n{GetTDData} (Perlin 2023a)\n\nImporta dados de títulos de dívida pública do Brasil diretamente do site do Tesouro Direto.\n\n{rb3} (Freitas and Perlin 2023)\n\nImporta diversos dados diretos do site da B3, incluindo preços de transação, curvas de juros históricas e muito mais.\n\n{GetBCBData} (Perlin 2022)\n\nImporta dados do grande repositório de séries temporais do Banco Central do Brasil, local obrigatório para qualquer economista que trabalha com dados.\n\n{GetDFPData2} (Perlin and Kirch 2023)\n\nImporta dados do sistema DFP – Demonstrativos Financeiros Padronizados – de empresas negociadas na B3, a bolsa Brasileira. O repositório inclui documentos financeiros tal como o balanço patrimonial, demonstrativos de resultados, entre vários outros.\n\n{GetFREData} (Perlin and Kirch 2022)\n\nImporta dados do sistema FRE – Formulário de Referência – da bolsa Brasileira. Esta inclui diversos eventos e informações corporativas tal como composição do conselho e diretoria, remuneração dos conselheiros, entre outras.\n\n\nCada um dos pacotes anteriores possui um tutorial de introdução em suas páginas do github. Por exemplo, pacote {yfR} (Perlin 2023b) possui um tutorial em https://docs.ropensci.org/yfR/. Lá encontrarás uma descrição completa do pacotes, assim como códigos reproduzíveis no seu computador, basta copiar e colar na sua sessão do R. Esse é um padrão comum entres os pacotes. Assim, para aprender mais sobre cada um, basta ir no respectivo site do github.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Importação e Exportação de Dados</span>"
    ]
  },
  {
    "objectID": "08-importacao-exportacao-dados.html#exercícios",
    "href": "08-importacao-exportacao-dados.html#exercícios",
    "title": "8  Importação e Exportação de Dados",
    "section": "8.9 Exercícios",
    "text": "8.9 Exercícios\n\nQ.1 - Use função introR::data_path para acessar o arquivo SP500.csv no repositório de dados do livro. Importe o conteúdo do arquivo no R com função readr::read_csv() . Quantas linhas existem no dataframe resultante?\n\nQ.2 - No link https://eeecon.uibk.ac.at/~zeileis/grunfeld/Grunfeld.csv você encontrará um arquivo .csv para os dados Grunfeld. Esta é uma tabela particularmente famosa devido ao seu uso como dados de referência em modelos econométricos do tipo painel. Usando função readr::read_csv() , leia este arquivo usando o link direto como entrada em readr::read_csv() . Quantas colunas você encontra no dataframe resultante?\n\nQ.3 - No pacote do livro existe um arquivo de dados chamado CH04_another-funky-csv-file.csv. Este possui um formato particularmente bizarro para os dados. Abra o mesmo em um editor de texto e procure entender como as colunas são separadas e qual o símbolo para o decimal. Após isso, veja as entradas da função read.table e importe a tabela na sessão do R. Caso somarmos o número de linhas com o número de colunas da tabela importada, qual o resultado?\n\nQ.4 - Use função introR::data_path para acessar o arquivo CH04_example-tsv.tsv no repositório de dados do livro. Note que as colunas dos dados estão separadas pelo símbolo de tabulação ('\\t'). Após ler o manual do readr::read_delim, importe as informações deste arquivo para o seu computador. Quantas linhas o arquivo contém?\n\nQ.5 - Crie um dataframe com duas colunas contendo números aleatórios da distribuição Normal. Exporte o dataframe resultante para cada um dos cinco formatos: csv, rds, xlsx, fst. Qual dos formatos ocupou maior espaço na memória do computador? Dica: file.size calcula o tamanho de arquivos dentro do próprio R.\n\nQ.6 - Melhore o código anterior com a mensuração do tempo de execução necessário para gravar os dados nos diferentes formatos. Qual formato teve a gravação mais rápida? Dica: use função system.time ou pacote tictoc para calcular os tempos de execução.\n\nQ.7 - Para o código anterior, redefina o valor de my_N para 1000000. Esta mudança modifica as respostas das duas últimas perguntas?\n\n\n\n\nDragulescu, Adrian, and Cole Arendt. 2020. Xlsx: Read, Write, Format Excel 2007 and Excel 97/2000/XP/2003 Files. https://github.com/colearendt/xlsx.\n\n\nFreitas, Wilson, and Marcelo Perlin. 2023. Rb3: Download and Parse Public Data Released by B3 Exchange. https://github.com/ropensci/rb3.\n\n\nGarmonsway, Duncan. 2023. Tidyxl: Read Untidy Excel Files. https://github.com/nacnudus/tidyxl.\n\n\nKlik, Mark. 2022. Fst: Lightning Fast Serialization of Data Frames. http://www.fstpackage.org.\n\n\nMirai Solutions GmbH. 2024. XLConnect: Excel Connector for r. https://mirai-solutions.ch https://github.com/miraisolutions/xlconnect.\n\n\nOoms, Jeroen. 2024. Writexl: Export Data Frames to Excel Xlsx Format. https://docs.ropensci.org/writexl/.\n\n\nPerlin, Marcelo. 2022. GetBCBData: Imports Datasets from BCB (Central Bank of Brazil) Using Its Official API. https://github.com/msperlin/GetBCBData/.\n\n\n———. 2023a. GetTDData: Get Data for Brazilian Bonds (Tesouro Direto). https://github.com/msperlin/GetTDData/.\n\n\n———. 2023b. yfR: Downloads and Organizes Financial Data from Yahoo Finance. https://github.com/ropensci/yfR.\n\n\nPerlin, Marcelo, and Guilherme Kirch. 2022. GetFREData: Reading FRE Corporate Data of Public Traded Companies from B3. https://github.com/msperlin/GetFREData/.\n\n\n———. 2023. GetDFPData2: Reading Annual and Quarterly Financial Reports from B3. https://github.com/msperlin/GetDFPData2/.\n\n\nR Core Team. 2023. Foreign: Read Data Stored by Minitab, s, SAS, SPSS, Stata, Systat, Weka, dBase, ... https://svn.r-project.org/R-packages/trunk/foreign/.\n\n\nWickham, Hadley. 2023. Tidyverse: Easily Install and Load the Tidyverse. https://tidyverse.tidyverse.org.\n\n\nWickham, Hadley, and Jennifer Bryan. 2023. Readxl: Read Excel Files. https://readxl.tidyverse.org.\n\n\nWickham, Hadley, Jim Hester, and Jennifer Bryan. 2024. Readr: Read Rectangular Text Data. https://readr.tidyverse.org.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Importação e Exportação de Dados</span>"
    ]
  },
  {
    "objectID": "99-references.html",
    "href": "99-references.html",
    "title": "Referências Bibliográficas",
    "section": "",
    "text": "Allaire, JJ, and Christophe Dervieux. 2024. Quarto: R Interface to\nQuarto Markdown Publishing System. https://github.com/quarto-dev/quarto-r.\n\n\nAllaire, JJ, Yihui Xie, Christophe Dervieux, Jonathan McPherson, Javier\nLuraschi, Kevin Ushey, Aron Atkins, et al. 2024. Rmarkdown: Dynamic\nDocuments for r. https://github.com/rstudio/rmarkdown.\n\n\nBarrett, Tyson, Matt Dowle, Arun Srinivasan, Jan Gorecki, Michael\nChirico, and Toby Hocking. 2024. Data.table: Extension of\n‘Data.frame‘. https://r-datatable.com.\n\n\nDragulescu, Adrian, and Cole Arendt. 2020. Xlsx: Read, Write, Format\nExcel 2007 and Excel 97/2000/XP/2003 Files. https://github.com/colearendt/xlsx.\n\n\nFreitas, Wilson. 2024. Bizdays: Business Days Calculations and\nUtilities. https://github.com/wilsonfreitas/R-bizdays.\n\n\nFreitas, Wilson, and Marcelo Perlin. 2023. Rb3: Download and Parse\nPublic Data Released by B3 Exchange. https://github.com/ropensci/rb3.\n\n\nGarmonsway, Duncan. 2023. Tidyxl: Read Untidy Excel Files. https://github.com/nacnudus/tidyxl.\n\n\nGentzkow, Matthew, Bryan T Kelly, and Matt Taddy. 2017. “Text as\nData.” National Bureau of Economic Research.\n\n\nHester, Jim, and Jennifer Bryan. 2022. Glue: Interpreted String\nLiterals. https://github.com/tidyverse/glue.\n\n\nHester, Jim, Hadley Wickham, and Gábor Csárdi. 2023. Fs:\nCross-Platform File System Operations Based on Libuv. https://fs.r-lib.org.\n\n\nIannone, Richard, Joe Cheng, Barret Schloerke, Ellis Hughes, Alexandra\nLauer, and JooYoung Seo. 2024. Gt: Easily Create Presentation-Ready\nDisplay Tables. https://gt.rstudio.com.\n\n\nJames, David, and Kurt Hornik. 2023. Chron: Chronological Objects\nWhich Can Handle Dates and Times. https://CRAN.R-project.org/package=chron.\n\n\nKlik, Mark. 2022. Fst: Lightning Fast Serialization of Data\nFrames. http://www.fstpackage.org.\n\n\nMcLeish, Don L. 2011. Monte Carlo Simulation and Finance. Vol.\n276. John Wiley & Sons.\n\n\nMirai Solutions GmbH. 2024. XLConnect: Excel Connector for r.\nhttps://mirai-solutions.ch\nhttps://github.com/miraisolutions/xlconnect.\n\n\nMüller, Kirill, and Hadley Wickham. 2023. Tibble: Simple Data\nFrames. https://tibble.tidyverse.org/.\n\n\nOoms, Jeroen. 2024. Writexl: Export Data Frames to Excel Xlsx\nFormat. https://docs.ropensci.org/writexl/.\n\n\nPerlin, Marcelo. 2022. GetBCBData: Imports Datasets from BCB\n(Central Bank of Brazil) Using Its Official API. https://github.com/msperlin/GetBCBData/.\n\n\n———. 2023a. GetTDData: Get Data for Brazilian Bonds (Tesouro\nDireto). https://github.com/msperlin/GetTDData/.\n\n\n———. 2023b. yfR: Downloads and Organizes Financial Data from Yahoo\nFinance. https://github.com/ropensci/yfR.\n\n\nPerlin, Marcelo, and Guilherme Kirch. 2022. GetFREData: Reading FRE\nCorporate Data of Public Traded Companies from B3. https://github.com/msperlin/GetFREData/.\n\n\n———. 2023. GetDFPData2: Reading Annual and Quarterly Financial\nReports from B3. https://github.com/msperlin/GetDFPData2/.\n\n\nR Core Team. 2023a. Foreign: Read Data Stored by Minitab, s, SAS,\nSPSS, Stata, Systat, Weka, dBase, ... https://svn.r-project.org/R-packages/trunk/foreign/.\n\n\n———. 2023c. R: A Language and Environment for Statistical\nComputing. Vienna, Austria: R Foundation for Statistical Computing.\nhttps://www.R-project.org/.\n\n\n———. 2023b. R: A Language and Environment for Statistical\nComputing. Vienna, Austria: R Foundation for Statistical Computing.\nhttps://www.R-project.org/.\n\n\nRyan, Jeffrey A., and Joshua M. Ulrich. 2024a. Quantmod:\nQuantitative Financial Modelling Framework. https://www.quantmod.com/.\n\n\n———. 2024b. Xts: eXtensible Time Series. https://joshuaulrich.github.io/xts/.\n\n\nSpinu, Vitalie, Garrett Grolemund, and Hadley Wickham. 2023.\nLubridate: Make Dealing with Dates a Little Easier. https://lubridate.tidyverse.org.\n\n\nTeetor, Paul. 2011. R Cookbook: Proven Recipes for Data Analysis,\nStatistics, and Graphics. \" O’Reilly Media, Inc.\".\n\n\nThompson, Ken. 1968. “Programming Techniques: Regular Expression\nSearch Algorithm.” Communications of the ACM 11 (6):\n419–22.\n\n\nUshey, Kevin, JJ Allaire, and Yuan Tang. 2024. Reticulate: Interface\nto Python. https://rstudio.github.io/reticulate/.\n\n\nUshey, Kevin, and Hadley Wickham. 2024. Renv: Project\nEnvironments. https://rstudio.github.io/renv/.\n\n\nVaughan, Davis, and Matt Dancho. 2023. Tibbletime: Time Aware\nTibbles. https://github.com/business-science/tibbletime.\n\n\nWickham, Hadley. 2019. Advanced r. CRC press.\n\n\n———. 2023a. Conflicted: An Alternative Conflict Resolution\nStrategy. https://conflicted.r-lib.org/.\n\n\n———. 2023b. Forcats: Tools for Working with Categorical Variables\n(Factors). https://forcats.tidyverse.org/.\n\n\n———. 2023c. Stringr: Simple, Consistent Wrappers for Common String\nOperations. https://stringr.tidyverse.org.\n\n\n———. 2023d. Tidyverse: Easily Install and Load the Tidyverse.\nhttps://tidyverse.tidyverse.org.\n\n\nWickham, Hadley, and Jennifer Bryan. 2023. Readxl: Read Excel\nFiles. https://readxl.tidyverse.org.\n\n\nWickham, Hadley, Winston Chang, Lionel Henry, Thomas Lin Pedersen,\nKohske Takahashi, Claus Wilke, Kara Woo, Hiroaki Yutani, Dewey\nDunnington, and Teun van den Brand. 2024. Ggplot2: Create Elegant\nData Visualisations Using the Grammar of Graphics. https://ggplot2.tidyverse.org.\n\n\nWickham, Hadley, Romain François, Lionel Henry, Kirill Müller, and Davis\nVaughan. 2023. Dplyr: A Grammar of Data Manipulation. https://dplyr.tidyverse.org.\n\n\nWickham, Hadley, and Lionel Henry. 2023. Purrr: Functional\nProgramming Tools. https://purrr.tidyverse.org/.\n\n\nWickham, Hadley, Jim Hester, and Jennifer Bryan. 2024. Readr: Read\nRectangular Text Data. https://readr.tidyverse.org.\n\n\nWickham, Hadley, Jim Hester, Winston Chang, and Jennifer Bryan. 2022.\nDevtools: Tools to Make Developing r Packages Easier. https://devtools.r-lib.org/.\n\n\nWickham, Hadley, Davis Vaughan, and Maximilian Girlich. 2024. Tidyr:\nTidy Messy Data. https://tidyr.tidyverse.org.\n\n\nWuertz, Diethelm, Tobias Setz, Yohan Chalabi, and Georgi N. Boshnakov.\n2023. timeDate: Rmetrics - Chronological and Calendar Objects.\nhttps://geobosh.github.io/timeDateDoc/.\n\n\nXie, Yihui. 2023. Knitr: A General-Purpose Package for Dynamic\nReport Generation in r. https://yihui.org/knitr/.\n\n\n———. 2024. Bookdown: Authoring Books and Technical Documents with r\nMarkdown. https://github.com/rstudio/bookdown.\n\n\nZeileis, Achim. 2016. Fortunes: R Fortunes. https://CRAN.R-project.org/package=fortunes.\n\n\nZeileis, Achim, Bettina Gruen, Friedrich Leisch, and Nikolaus Umlauf.\n2022. Exams: Automatic Generation of Exams in r. https://www.R-exams.org/.",
    "crumbs": [
      "Referências Bibliográficas"
    ]
  }
]