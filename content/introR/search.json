[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução ao R",
    "section": "",
    "text": "Prefácio\nEste livro introduz o leitor ao uso do R como ferramenta de computação e análise de dados. O conteúdo foi inspirado em minha outra obra, “Análise de Dados Financeiros e Econômicos com o R”, publicada em 2017. Com o tempo, logo percebi que seria desejável ter diversos livros focados dos capítulos, ao invés de uma única obra no tema. Ao final deste livro você irá aprender como utilizar o R para importar e manipular dados e, por fim, reportar tabelas e figuras de uma pesquisa em um relatório técnico.\nSou professor da Universidade Federal do Rio Grande do Sul, onde leciono, na graduação e na pós-graduação, disciplinas relacionadas ao uso do R em análise de dados. A experiência em sala de aula permite enxergar onde os alunos mais erram, e qual o melhor caminho didático para aprender a usar o R. Seja voce um pesquisador acadêmico, ou futuro analista de dados, este livro é um projeto pessoal para disseminar conhecimento sobre a ferramenta para um público maior e mais diversificado.\nOutra motivação que tive para escrever o livro foi minha experiência na utilização de códigos disponibilizados por outros pesquisadores. Na maioria das vezes, esses códigos são desorganizados, pouco claros e, possivelmente, funcionam apenas no computador do pesquisador que os escreveu! Assim como se espera que um artigo científico esteja bem escrito, também se deve esperar que o código por trás da respectiva pesquisa seja de qualidade. Porém, esse não é o caso na grande maioria das vezes. Com este livro, irei atacar esse problema, formalizando uma estrutura de código voltada à reprodutibilidade científica, focando em organização e usabilidade. Nesse sentido, espero que as futuras gerações de pesquisadores estejam mais bem preparadas para compartilhar o seu trabalho.\nAntes de prosseguir, um aviso. Não iremos trabalhar usos avançados do R. O conteúdo será limitado a exemplos simples e práticos de utilização do software para a construção de pesquisa baseada em dados financeiros e econômicos. De fato, um dos desafios na escrita deste livro foi definir o limite entre o material introdutório e o avançado. Procurei, sempre que possível, dosar gradualmente o nível de complexidade. Para leitores interessados em conhecer funções avançadas do programa e o seu funcionamento interno, sugiro a leitura do manual oficial do R (Teetor 2011) e de Wickham (2019).\nCom este livro irás aprender os seguinte tópicos:\nEste livro não seria possível sem a preciosa autonomia do meu cargo de professor universitário, sendo um dos facilitadores de todos os meus projetos literários, os quais me dedico com muita paixão. Assim, deixo aqui o meu agradecimento a UFRGS (Universidade Federal do Rio Grande do Sul), por possibilitar e incentivar este empreendimento no mercado literário.\nAdicionalmente, não posso também deixar de agradecer a toda a comunidade do R. Em especial, agradeço os autores do pacote {quarto} (Allaire 2023), sem o qual não seria possível compilar este livro de uma forma tão fácil. Adicionalmente, abaixo destaco os respectivos pacotes disponíveis no CRAN utilizados na produção do livro e suas devidas referências. A lista foi gerada automaticamente e está em ordem alfabética.\n{base} (R Core Team 2023a), {dplyr} (Wickham, François, et al. 2023), {forcats} (Wickham 2023a), {fs} (Hester, Wickham, and Csárdi 2023), {ggplot2} (Wickham, Chang, et al. 2023), {glue} (Hester and Bryan 2022), {gt} (Iannone et al. 2023), {knitr} (Xie 2023), {purrr} (Wickham and Henry 2023), {quarto} (Allaire 2023), {readr} (Wickham, Hester, and Bryan 2023), {renv} (Ushey and Wickham 2023), {reticulate} (Ushey, Allaire, and Tang 2023), {rmarkdown} (Allaire et al. 2023), {stats} (R Core Team 2023b), {tibble} (Müller and Wickham 2023), {tidyr} (Wickham, Vaughan, and Girlich 2023), {tidyverse} (Wickham 2023b)"
  },
  {
    "objectID": "index.html#material-suplementar",
    "href": "index.html#material-suplementar",
    "title": "Introdução ao R",
    "section": "Material Suplementar",
    "text": "Material Suplementar\nTodo o material usado no livro, incluindo exemplos de código separados por capítulos, está publicamente disponível na Internet e distribuído com um pacote R denominado introR. Este inclui arquivos de dados, e algumas funções que irão facilitar a execução dos exemplos do livro. Se você planeja, como sugerido, escrever código enquanto lê o livro, este pacote ajudará muito em sua jornada.\nPara instalar este pacote no seu computador, basta executar algumas linhas de comando no R. Veja o código destacado a seguir e copie e cole o mesmo no prompt do RStudio (canto inferior esquerdo da tela, com um sinal “&gt;”) e pressione Enter para cada comando. Esteja ciente de que você precisará do R e RStudio instalados em seu computador (consulte (instalacao?)).\n\n# install devtools dependency\ninstall.packages('devtools')\n\n# install book package\ndevtools::install_github('msperlin/introR')\n\nO que este código fará é instalar o pacote devtools, uma dependência necessária para instalar código do Github – um repositório de pacotes onde o livro está hospedado. Depois disso, uma chamada para install_github('msperlin/introR') irá instalar o pacote em seu computador.\nDepois da instalação, todos os arquivos do livro estarão disponíveis localmente, salvos em uma pasta do seu computador. Iremos usar todos estes arquivos futuramente. Opcionalmente, caso quiser olhar os arquivos, podes copiar todo conteúdo para outra pasta com o código a seguir:\n\nintroR::copy_book_files(path_to_copy = '~')\n\nVeja que o tilda (~) é um atalho para o diretório “Documentos” no Windows (ou “home” no Linux/Mac). Assim, o código anterior descompactará o arquivo do livro na pasta “Documentos/introR-files”. O pacote também inclui várias outras funções que serão usadas ao longo do livro. Se você preferir a maneira antiga e consagrada de baixar o arquivo e descompactar manualmente, podes encontrar uma cópia no site do livro."
  },
  {
    "objectID": "index.html#conteúdo-para-instrutores",
    "href": "index.html#conteúdo-para-instrutores",
    "title": "Introdução ao R",
    "section": "Conteúdo para Instrutores",
    "text": "Conteúdo para Instrutores\nSe você for um instrutor de R, aqui encontrarás muito material para usar em suas aulas:\n\nExercícios estáticos na internet\n\nCada capítulo deste livro inclui exercícios que seus alunos podem praticar. Todas as soluções estão disponíveis na versão online do livro, disponível em .\n\nExercícios exportáveis para pdf ou plataformas de e-learning\n\nTodos exercícios do livro estão no formato exams (Zeileis et al. 2022) e são exportáveis para arquivos em pdf ou então para plataformas de e-learning tal como o Moodle ou Blackboard. Veja este post no blog para maiores detalhes.\n\nAcesso ao livro na internet\n\nExiste uma versão online e gratuita do livro, disponível em &lt;&gt;. Seu alunos terão acesso ao material do próprio celular.\n\n\nEspero que goste deste livro. O conteúdo tem sido compilado por um longo período de tempo, a base de muito suor e, literalmente, litros de café chá por parte do autor.\nBoa leitura!\nMarcelo S. Perlin"
  },
  {
    "objectID": "01-introdução.html#o-que-é-o-r",
    "href": "01-introdução.html#o-que-é-o-r",
    "title": "1  Introdução",
    "section": "1.1 O que é o R",
    "text": "1.1 O que é o R\nO R é uma linguagem de programação voltada para a resolução de problemas estatísticos e para a visualização gráfica de dados. O código base do R foi inspirado na linguagem S, inicialmente criada no laboratório da Bell/AT&T por John Chambers e seus colegas. A ideia de criar uma linguagem de programação voltada a estatística foi redesenhada por dois acadêmicos, Ross Ihaka e Robert Gentleman, ambos da universidade de Auckland - Nova zelândia.\nHoje, R é sinônimo de programação voltada à análise de dados, com uma larga base de usuários acadêmicos e da indústria. É muito provável que analistas de áreas diversas, desde Economia até Biologia, ou mesmo Música, encontrem no R uma quantidade significativa de códigos que facilitem suas análises. No campo empresarial, grandes empresas como Google e Microsoft já o adotaram como a linguagem interna para a análise de dados. O R é atualmente mantido pelo R Foundation e o R Consortium, um esforço coletivo para financiar projetos de extensão da linguagem.\nE o mais importante: o R é totalmente livre e disponível em vários sistemas operacionais. Seja você um usuário do Windows, do Linux/Unix ou do MacOS, existe uma instalação do R para a sua plataforma, e os seus códigos devem rodar entre uma e outra com mínimas alterações.\n\n\n\n\n\n\nQual a origem do nome R?\n\n\n\nO que pode ser dito como uma ato pouco criativo, os desenvolvedores escolheram a letra R pois era a primeira letra de seus primeiros nomes, Ross e Robert."
  },
  {
    "objectID": "01-introdução.html#por-que-escolher-o-r",
    "href": "01-introdução.html#por-que-escolher-o-r",
    "title": "1  Introdução",
    "section": "1.2 Por que Escolher o R",
    "text": "1.2 Por que Escolher o R\nPossivelmente você esteja se perguntando por que deve optar pelo R e investir tempo em sua aprendizagem, ao invés de escolher uma outra linguagem.\nEm primeiro lugar, o R é uma plataforma madura, estável, continuamente suportada e intensamente utilizada na indústria. Ao escolher o R, você terá a bagagem computacional necessária não somente para uma carreira acadêmica em pesquisa científica, mas também para o trabalho em organizações privadas. Nesse sentido, com a escolha de outra linguagem de programação menos popular ou proprietária/comercial, é provável que tal linguagem não seja utilizada em um ambiente empresarial e isso pode limitar as suas futuras oportunidades profissionais. Sem dúvida, o conhecimento de programação em um plataforma aberta de análise de dados aumenta a sua atratividade como profissional.\nAprender a linguagem do R é fácil. A experiência que tenho ensinando o R em sala de aula me permite afirmar que os alunos, mesmo aqueles sem experiência em programação, apresentam facilidade em aprender a linguagem e em utilizá-la para criar seus próprios códigos de pesquisa. A linguagem é intuitiva e certas normas e funções podem ser estendidas para diferentes casos. Após entender como o programa funciona, fica fácil descobrir novas funcionalidades partindo de uma lógica anterior. Essa notação compartilhada entre procedimentos facilita o aprendizado.\nA interface do R e RStudio torna o uso da ferramenta bastante produtivo. A interface gráfica aberta e gratuita disponibilizada pela RStudio/Posit facilita o uso do software, assim como a produtividade do usuário. Utilizando o ambiente de trabalho do R e RStudio, têm-se a disposição diversas ferramentas que facilitam e estendem o uso da plataforma.\nOs pacotes do R permitem as mais diversas funcionalidades. Logo veremos que o R permite o uso de código de outros usuários, os quais podem ser localmente instalados através de um simples comando. Esses estendem a linguagem básica do R e possibilitam as mais diversas funcionalidades. Além das funções óbvias de analisar dados, podes utilizar o R para mandar emails, escrever e publicar um livro, criar provas objetivas com conteúdo dinâmico, contar piadas e poemas (é sério!), acessar e coletar dados da internet, entre diversas outras funcionalidades.\nO R tem compatibilidade com diferentes linguagens e sistemas operacionais. Se, por algum motivo, o usuário precisar utilizar código de outra linguagem de programação tal como C++, Python, Julia, é fácil integrar a mesma dentro de um programa do R. Diversos pacotes estão disponíveis para facilitar esse processo. Portanto, o usuário nunca fica restrito a uma única linguagem e tem flexibilidade para escolher as suas ferramentas de trabalho.\nO R é totalmente gratuito! O programa e todos os seus pacotes são completamente livres, não tendo custo algum de licença e distribuição. Portanto, você pode utilizá-lo e modificá-lo livremente no seu trabalho ou computador pessoal. Essa é uma razão muito forte para a adoção da linguagem em um ambiente empresarial, onde a obtenção de licenças individuais e coletivas de outros softwares comerciais pode incidir um alto custo financeiro."
  },
  {
    "objectID": "01-introdução.html#usos-do-r",
    "href": "01-introdução.html#usos-do-r",
    "title": "1  Introdução",
    "section": "1.3 Usos do R",
    "text": "1.3 Usos do R\nO R é uma linguagem de programação completa e qualquer problema computacional relacionado a dados pode ser resolvido com base nela. Dada a adoção do R por diferentes áreas de conhecimento, a lista de possibilidades é extensa. Para o caso de Finanças e Economia, destaco abaixo as possíveis utilizações do programa:\n\nSubstituir e melhorar tarefas intensivas e repetitivas dentro de ambientes corporativos, geralmente realizadas em planilhas eletrônicas;\nCriação de relatórios estruturados periódicos com a tecnologia RMarkdown e quarto. Podes, por exemplo, criar um relatório automatizado que importe dados brutos e analise as vendas as vendas na empresa no mês.\nDesenvolvimento de rotinas para administrar portfolios de investimentos e executar ordens financeiras;\nCriação de ferramentas para controle, avaliação e divulgação de índices econômicos sobre um país ou região;\nExecução de diversas possibilidades de pesquisa científica através da estimação de modelos econométricos e testes de hipóteses;\nCriação e manutenção de websites dinâmicos ou estáticos através do pacotes shiny, blogdown ou distill;\n\nAlém dos usos destacados anteriormente, o acesso público a pacotes desenvolvidos por usuários expande ainda mais essas funcionalidades. O site da CRAN (Comprehensive R Archive Network)1 oferece um Task Views do software para o tópico de Finanças2 e Econometria3. Nos links é possível encontrar os principais pacotes disponíveis para cada tema. Isso inclui a importação de dados financeiros da internet, a estimação de um modelo econométrico específico, cálculos de diferentes estimativas de risco, entre várias outras possibilidades. A leitura dessa página e o conhecimento desses pacotes são essenciais para aqueles que pretendem trabalhar com Finanças e Economia. Vale destacar, porém, que essa lista é moderada e apresenta apenas os principais itens. A lista completa de pacotes é muito maior do que o apresentado no Task Views."
  },
  {
    "objectID": "01-introdução.html#instalacao",
    "href": "01-introdução.html#instalacao",
    "title": "1  Introdução",
    "section": "1.4 Como Instalar o R",
    "text": "1.4 Como Instalar o R\nO R é instalado no seu sistema operacional como qualquer outro programa. A maneira mais direta e funcional de instalá-lo é ir ao website do R em  e clicar no link CRAN do painel Download, conforme mostrado na animação a seguir.\n\n\n\n\n\n\n\n\n\nFigure 1.1: Instalando o R no Windows\n\n\n\n\n\nknitr::include_graphics('resources/figs/cran-webshot-01.png')\n\n\n\n\nPágina inicial para o download do R\n\n\n\n\nA próxima tela apresenta a escolha do espelho para baixar os arquivos de instalação. O repositório do CRAN é espelhado em diversas partes do mundo, permitindo acesso rápido para os usuários. Para a grande maioria dos leitores deste livro, essa localidade deve ser o Brasil. Portanto, você pode escolher um dos links da instituição mais próxima, tal como o da UFPR (Universidade Federal do Paraná). Em caso de dúvida, escolha o repositório do RStudio 0-Cloud (veja Figura \\(\\ref{fig:website-cran-2}\\)), o qual automaticamente direciona para o local mais próximo.\n\n\n\n\n\nTela com a escolha do espelho para o download\n\n\n\n\nO próximo passo é selecionar o sistema operacional do computador. Devido à maior popularidade da plataforma Windows, a partir de agora daremos enfoque à instalação do R nesse sistema. As instruções de instalação nos demais sistemas operacionais podem ser facilmente encontradas na internet. Destaca-se que, independente da plataforma, o modo de uso do R é o mesmo. Existem, porém, algumas exceções, principalmente quando o R interage com o sistema de arquivos. Essas exceções serão destacadas no decorrer do livro. Assim, mesmo que você esteja utilizando Linux ou MacOS, poderá tirar proveito do material aqui apresentado.\n\n\n\n\n\nTela com a escolha do sistema operacional\n\n\n\n\nApós clicar no link Download R for Windows, a próxima tela irá mostrar as seguintes opções de download: base, contrib, old.contrib e RTools. Dentre as opções de download, a primeira (base) deve ser selecionada. O link acessa a instalação básica do R para Windows. O link contrib e old.contrib acessa os pacotes/módulos disponíveis para o R. Não precisas acessar estes últimos links, existe uma maneira muito mais fácil de instalar pacotes, como veremos em seguida.\nO último link, RTools, serve para instalar dependências necessárias no caso do usuário desenvolver e distribuir os seus próprios pacotes de R. Este não é uma instalação necessária para usuários iniciantes. Porém, saiba que alguns pacotes externos ao CRAN podem exigir a instalação do RTools para compilação de código. Minha sugestão é que já instale o Rtools e assim evite qualquer problema futuro.\n\n\n\n\n\nTela com opções de instalação\n\n\n\n\nApós clicar no link base, a próxima tela mostrará o link para o download do arquivo de instalação do R no Windows. Após baixar o arquivo, abra-o e siga os passos da tela de instalação do R. Escolha a língua inglesa em todas etapas do processo. O uso da língua inglessa não é acidental. Este é a melhor forma, mesmo para iniciantes, de se aprender a usar o R. É possível instalar uma versão em português porém isso limita o potencial da ferramenta. Caso não for fluente em inglês, não se preocupe, o vocabulário necessário é básico. Neste momento, nenhuma outra configuração especial é necessária. Sugiro manter todas as escolhas padrão selecionadas e simplesmente ir aceitando as telas de diálogo. Após a instalação do R, partimos para a instalação do RStudio.\n\nR_ver &lt;- R.version\n\nmajor &lt;- R_ver$major\nminor &lt;- R_ver$minor\n\nR_version_str &lt;- paste0(major, \".\", minor)\n\n\n\n\n\n\n\nImportante\n\n\n\nA cada quatro meses uma nova versão do R é lançada, corrigindo bugs e implementando novas soluções. Temos dois tipos principais de versões, major e minor. Por exemplo, na data de compilação do livro, 10/01/2024, a última versão disponível do R é 4.3.2. O primeiro dígito (4) indica a versão major e todos os demais são do tipo minor. Geralmente, as mudanças minor são bem específicas e, possivelmente, terão pouco impacto no seu trabalho.\nPorém, mudanças do tipo major refletem totalmente no ecossistema de pacotes do R. Toda vez que instalar uma nova versão major do R, terás que reinstalar todos os pacotes utilizados. O problema é que não é incomum problemas de incompatibilidade de pacotes com a nova versão.\nMinha dica é: toda vez que uma nova versão major do R sair, espere alguns meses antes de instalar na sua máquina. Assim, o autores dos pacotes terão mais tempo para atualizar os seus códigos, minimizando a possibilidade de problemas de compatibilidade."
  },
  {
    "objectID": "01-introdução.html#instalando-o-rstudio",
    "href": "01-introdução.html#instalando-o-rstudio",
    "title": "1  Introdução",
    "section": "1.5 Instalando o RStudio",
    "text": "1.5 Instalando o RStudio\nA instalação do R inclui a sua própria interface gráfica, um programa que facilita a edição e execução de nossos scripts. Essa, porém, possui várias limitações. O RStudio é um software que torna o uso e o visual do R muito mais prático e eficiente. Uma forma de entender essa relação é com uma analogia com carros. Enquanto o R é o motor da linguagem de programação, o RStudio é a carroceria e o painel de instrumentos. Além de apresentar um visual mais atrativo, o RStudio também é acrescido de várias funcionalidades que facilitam a vida do usuário, possibilitando a construção de projetos e pacotes do próprio R, a criação de documentos dinâmicos (Sweave/knitr) e a interface com edição de textos em LaTeX, entre várias outras. Assim como o R, o RStudio também é gratuito e pode ser utilizado no ambiente empresarial.\nA instalação do RStudio é mais simples do que a do R. Os arquivos estão disponíveis no endereço disponibilizado no site da empresa Posit Posit. Após acessar a página, clique em Download RStudio e depois em Download Rstudio Desktop. Logo após, basta selecionar o arquivo relativo ao sistema operacional em que você irá trabalhar. Provavelmente, essa opção será Windows Vista/7/8/10. Note que, assim como o R, o RStudio também está disponível para diferentes plataformas.\nDestaco que o uso do RStudio não é essencial para desenvolver programas no R. Outros softwares de interface estão disponíveis e podem ser utilizados. Porém, dada minha experiência atual, o RStudio é o programa de interface que oferece a maior variedade de funcionalidades para essa linguagem, além de ser amplamente utilizado, o que justifica a sua escolha. Como uma alternativa ao RStudio, sugiro o vscode, o qual possui uma ótima integração com o R."
  },
  {
    "objectID": "01-introdução.html#recursos-na-internet",
    "href": "01-introdução.html#recursos-na-internet",
    "title": "1  Introdução",
    "section": "1.6 Recursos na Internet",
    "text": "1.6 Recursos na Internet\nA comunidade R é viva e envolvente. Na internet é possível encontrar uma diversidade de material sobre o uso do R. Diversos usuários, assim como o próprio autor do livro, publicam material sobre o uso R em seus blogs. Isso inclui anúncios de pacotes, publicações sobre análise de dados na vida real, curiosidades, novidades e tutoriais. R-Bloggers é um site internacional que agrega esses blogs em um único local, tornando mais fácil para qualquer um acessar e participar. O conteúdo do R-Bloggers, porém, é todo em inglês.\nRecentemente, uma lista de blogs locais sobre o R está compilada e organizada por Marcos Vital no Github. Eu recomendo a inscrição no feed do R-Bloggers, além dos blogs nacionais. Não só você será informado sobre o que está acontecendo no universo do R, mas também aprenderá muito lendo artigos e os códigos de outros usuários.\nAprender e usar R pode ser uma experiência social. Várias conferências e grupos de usuários estão disponíveis em muitos países, incluindo o Brasil. O grupo R Brasil - Programadores no Facebook é bastante ativo, com um grande número de participantes. Recomendo fortemente a inscrição neste grupo e o acompanhamento das discussões relacionadas ao uso do R. Diversas conferências locais sobre o R são divulgadas nesse grupo."
  },
  {
    "objectID": "01-introdução.html#organização-e-material-do-livro",
    "href": "01-introdução.html#organização-e-material-do-livro",
    "title": "1  Introdução",
    "section": "1.7 Organização e Material do Livro",
    "text": "1.7 Organização e Material do Livro\nEste livro tem uma abordagem prática no uso do R e será acompanhado por uma série de códigos que irão exemplificar e mostrar para o leitor as funcionalidades do programa. Para tirar o máximo de proveito do material, sugiro que você primeiro busque entender o código mostrado e, somente então, tente utilizá-lo em seu próprio computador. O índice remissivo disponibilizado no final do livro impresso serve como uma mapa de uso das funções. Toda vez que uma função é chamada no livro, um registro do número da página é criado no índice remissivo. Esse indica, também, o pacote que a função pertence. Podes utilizar este mapa para localizar o uso de qualquer função ou pacote no decorrer do livro.\nSugiro também o uso da versão web do livro4, a qual permite que os código de exemplo sejam copiados direto para a sua sessão do R. Assim, perderás menos tempo digitando código, sobrando tempo para o estudo.\nAprender a programar em uma nova linguagem é como aprender uma língua estrangeira: o uso no dia-a-dia é de extrema importância para criar fluência. Sempre que possível, teste o código no seu computador e brinque com o mesmo, modificando os exemplos dados e verificando o efeito das modificações nas saídas do programa. Procure sempre entender como a rotina estudada pode ajudar na solução de um problema seu. Cada capítulo apresenta no seu final uma lista de exercícios, incluindo questões do tipo desafio. Podes testar as suas habilidades de programação resolvendo as atividades propostas. Vale relembrar que todo o código deste livro está disponibilizado na internet. Não precisas, portanto, escrever o código diretamente do livro. Podes copiar e colar do código fonte disponibilizado no site.\nNo decorrer da obra, toda demonstração de código terá duas partes: o código em si e sua saída do R. Essa saída nada mais é do que o resultado dos comandos na tela do programa. Todas as entradas e saídas de código serão sinalizadas no texto com um formato especial. Veja o exemplo a seguir:\n\n# create a list\nL &lt;- list(var1 = 'abc', var2 = 1:5)\n\n# print to prompt\nprint(L)\n\nR&gt; $var1\nR&gt; [1] \"abc\"\nR&gt; \nR&gt; $var2\nR&gt; [1] 1 2 3 4 5\n\n\nNo caso anterior, os textos L &lt;- list(var1 = 'abc', var2 = 1:5) e print(L) são os códigos de entrada. A saída do programa é a apresentação na tela dos elementos de x, com o símbolo antecessor R&gt;. Por enquanto não se preocupe em entender e reproduzir o código utilizado acima. Iremos tratar disso no próximo capítulo.\nNote que faço uso da língua inglesa no código, tanto para a nomeação de objetos quanto para os comentários. Isso não é acidental. O uso da língua inglesa facilita o desenvolvimento de código ao evitar caracteres latinos, além de ser uma das línguas mais utilizadas no mundo. Portanto, é importante já ir se acostumando com esse formato. O vocabulário necessário, porém, é limitado. De forma alguma precisarás ter fluência em inglês para entender o código.\nO código também pode ser espacialmente organizado usando novas linhas. Esse é um procedimento comum em torno de argumentos de funções. O próximo pedaço de código é equivalente ao anterior, e executará exatamente da mesma maneira. Observe como usei uma nova linha para alinhar verticalmente os argumentos da função list. Você verá em breve que, ao longo do livro, esse tipo de alinhamento vertical é constantemente usado em códigos longos. Afinal, o código tem que necessariamente caber na página do livro impresso.\n\n# create a list\nL &lt;- list(var1 = 'abc',\n          var2 = 1:5)\n\n# print to prompt\nprint(L)\n\nR&gt; $var1\nR&gt; [1] \"abc\"\nR&gt; \nR&gt; $var2\nR&gt; [1] 1 2 3 4 5\n\n\nO código também segue uma estrutura bem definida. Uma das decisões a ser feita na escrita de códigos de computação é a forma de nomear os objetos e como lidar com a estrutura do texto do código em geral. É recomendável seguir um padrão limpo de código, de forma que o mesmo seja fácil de ser mantido ao longo do tempo e de ser entendido por outros usuários. Para este livro, foi utilizado uma mistura de escolhas pessoais do autor com o estilo de código sugerido pelo Google. O usuário, porém, é livre para escolher a estrutura que achar mais eficiente. Voltaremos a discutir estrutura de código no capítulo @ref(otimizacao)."
  },
  {
    "objectID": "01-introdução.html#animações-de-código",
    "href": "01-introdução.html#animações-de-código",
    "title": "1  Introdução",
    "section": "1.8 Animações de código",
    "text": "1.8 Animações de código\nEsta edição do livro inclui animações de código no formato gif, as quais devem ajudar a memorizar e visualizar as diferentes operações na plataforma. Para os leitores do livro impresso, obviamente não existe maneira de incluir animações em paper. Como alternativa, cada animação inclui um QRCode que irá direcionar o leitor para página na web com a animação em questão. A imagem a esquera é a primeira tela de cada animação. Veja o exemplo abaixo na Figure 1.2:\n\n\n\n\n\n\n\n\n\nFigure 1.2: Exemplo de animação\n\n\n\n\nPara utilizar, abra seu celular e aponte a câmera para o QRCode da página. Após isso, basta clicar no link que aparecer na tela do celular."
  },
  {
    "objectID": "01-introdução.html#exercícios",
    "href": "01-introdução.html#exercícios",
    "title": "1  Introdução",
    "section": "1.9 Exercícios",
    "text": "1.9 Exercícios"
  },
  {
    "objectID": "01-introdução.html#footnotes",
    "href": "01-introdução.html#footnotes",
    "title": "1  Introdução",
    "section": "",
    "text": "https://cran.r-project.org/web/views↩︎\nhttps://cran.r-project.org/web/views/Finance.html↩︎\nhttps://cran.r-project.org/web/views/Econometrics.html↩︎\nhttps://www.msperlin.com/introR/↩︎"
  },
  {
    "objectID": "02-como-o-r-funciona.html#objetos-e-funções",
    "href": "02-como-o-r-funciona.html#objetos-e-funções",
    "title": "2  Como o R Funciona?",
    "section": "2.1 Objetos e Funções",
    "text": "2.1 Objetos e Funções\nNo R, tudo é um objeto, e cada tipo de objeto tem suas propriedades. Por exemplo, o valor de um índice de inflação ao longo do tempo – em vários meses e anos – pode ser representado como um objeto do tipo vetor numérico. As datas em si, no formato YYYY-MM-DD (ano-mês-dia), podem ser representadas como texto (character) ou a própria classe Date. Por fim, podemos representar conjuntamente os dados de inflação e as datas armazenando-os em um objeto único do tipo dataframe, o qual nada mais é do que uma tabela com linhas e colunas. Todos esses objetos fazem parte do ecossistema do R e é através da manipulação destes que tiramos o máximo proveito do software.\nOs principais tipos de objetos do R são:\n\nnuméricos (numeric)\n\nrepresentam números e medidas\n\ncaraterer (character)\n\nrepresentam texto\n\nfatores (factors)\n\nrepresentam grupos dentros dos dados, tipo “Casado/Solteiro”, “Destro/Canhoto”\n\ndataframes ou tibbles\n\nrepresentam tabelas, as quais podem conter dados numéricos, caracteres e fatores em um único objeto.\n\n\nEnquanto representamos informações do mundo real com as diferentes classes no R, um tipo especial de objeto é a função, a qual representa um procedimento preestabelecido que está disponível para o usuário. O R possui uma grande quantidade de funções, as quais possibilitam que o usuário realize uma vasta gama de procedimentos. Por exemplo, os comandos básicos do R, não incluindo demais pacotes, somam um total de 1268 funções. Com base neles e outros iremos importar dados, calcular médias, testar hipóteses, limpar dados, e muito mais.\nCada função possui um próprio nome. Por exemplo, a função sort() é um procedimento que ordena valores utilizados como input. Caso quiséssemos ordenear os valores no vetor numérico [2, 1, 3, 0], basta inserir no prompt o seguinte comando e apertar enter:\n\nsort(c(2, 1, 3, 0), decreasing = TRUE)\n\nR&gt; [1] 3 2 1 0\n\n\nO comando c(2, 1, 3, 0) combina os valores em um vetor (maiores detalhes sobre comando c serão dados em seção futura). Observe que a função sort() é utilizada com parênteses de início e fim. Esses parênteses servem para destacar as entradas (inputs), isto é, as informações enviadas para a função produzir alguma coisa. Observe que cada entrada (ou opção) da função é separada por uma vírgula, tal como em MinhaFuncao(entrada01, entrada02, entrada03, ...). No caso do código anterior, note que usamos a opção decreasing = TRUE. Essa é uma instrução específica para a função sort() ordenar de forma decrescente os elementos do vetor de entrada. Veja a diferença:\n\nsort(c(2, 1, 3, 0), decreasing = FALSE)\n\nR&gt; [1] 0 1 2 3\n\n\nO uso de funções está no coração do R e iremos dedicar grande parte do livro a elas. Por enquanto, essa breve introdução já serve o seu propósito. O principal é entender que uma função usa suas entradas para produzir algo de volta. Nos próximos capítulos iremos utilizar funções já existentes para as mais diferentes finalidades: baixar dados da internet, ler arquivos, realizar testes estatísticos e muito mais. No capítulo @ref(programacao) iremos tratar deste assunto com maior profundidade, incluindo a forma de escrevermos nossas próprias funções."
  },
  {
    "objectID": "02-como-o-r-funciona.html#criando-objetos-simples",
    "href": "02-como-o-r-funciona.html#criando-objetos-simples",
    "title": "2  Como o R Funciona?",
    "section": "2.2 Criando Objetos Simples",
    "text": "2.2 Criando Objetos Simples\nUm dos comandos mais básicos no R é a definição de objetos. Como foi mostrado nas seções anteriores, pode-se definir um objeto com o uso do comando &lt;-, o qual, para o português, é traduzido para o verbo defina (assign em inglês). Considere o seguinte código:\n\n# set x\nmy_x &lt;- 123\n\n# set x, y and z in one line\nmy_x &lt;- 1 ; my_y &lt;- 2; my_z &lt;- 3\n\nLê-se esse código como x é definido como 123. A direção da seta define onde o valor será armazenado. Por exemplo, utilizar 123 -&gt; my_x também funcionaria, apesar de ser uma sintaxe pouco utilizada ou recomendada. Note que também é possível escrever diversos comandos na mesma linha com o uso da semi-vírgula (;).\n\n\n\n\n\n\nImportante\n\n\n\nO uso do símbolo &lt;- para a definição de objetos é específico do R. Na época da concepção da linguagem S, de onde o R foi baseado, existiam teclados com uma tecla específica que definia diretamente o símbolo de seta. Teclados contemporâneos, porém, não possuem mais esta configuração. Uma alternativa é utilizar o atalho para o símbolo, o qual, no Windows, é definido por alt + -.\n\n\nÉ possível também usar o símbolo = para definir objetos assim como o &lt;-. Saliento que esta é prática comum em outras linguagens de programação. Porém, no ecosistema do R, a utilização do = com esse fim específico não é recomendada. O símbolo de igualdade tem o seu uso especial e resguardado na definição de argumentos de uma função tal como sort(x = 1:10, decreasing = TRUE).\n\n\n\n\n\n\nImportante\n\n\n\nA nomeação dos objetos criados no R é importante. Tirando alguns casos específicos, o usuário pode nomear os objetos como quiser. Essa liberdade, porém, pode ser um problema. É desejável sempre dar nomes curtos que façam sentido ao conteúdo do objeto e que sejam simples de entender. Isso facilita o entendimento do código por outros usuários e faz parte das normas sugeridas para a estruturação do código do Google.\n\n\nO R executa o código procurando objetos e funções disponíveis no seu ambiente de trabalho (enviromnent). Se tentarmos acessar um objeto que não existe, o R irá retornar uma mensagem de erro:\n\nprint(z)\n\n\n\nR&gt; Error in print(z): object 'z' not found\n\n\nIsso ocorre pois o objeto z não existe na sessão atual do R. Se criarmos uma variável z como z &lt;- 123 e repetirmos o comando print(z), não teremos a mesma mensagem de erro.\nUm ponto importante aqui é a definição de objetos de classes diferentes com o uso de símbolos específicos. O uso de aspas duplas (\" \") ou simples (' ') define objetos da classe texto enquanto números são definidos pelo próprio valor. Conforme será mostrado, cada objeto no R tem uma classe e cada classe tem um comportamento diferente. Portanto, objetos criados com o uso de aspas pertencem à classe character. Podemos confirmar isso via código:\n\n# set vars\nx &lt;- 1\ny &lt;- '1'\n\n# display classes\nclass(x)\n\nR&gt; [1] \"numeric\"\n\nclass(y)\n\nR&gt; [1] \"character\"\n\n\nAs saídas anteriores mostram que a variável x é do tipo numérico, enquanto a variável y é do tipo texto (character). Ambas fazem parte das classes básicas de objetos no R. Por enquanto, este é o mínimo que deves saber para avançar nos próximos capítulos. Iremos estudar este assunto mais profundamente no capítulo @ref(classes-basicas)."
  },
  {
    "objectID": "02-como-o-r-funciona.html#criando-vetores",
    "href": "02-como-o-r-funciona.html#criando-vetores",
    "title": "2  Como o R Funciona?",
    "section": "2.3 Criando Vetores",
    "text": "2.3 Criando Vetores\nNos exemplos anteriores criamos objetos simples tal como x &lt;- 1 e x &lt;- 'abc'. Enquanto isso é suficiente para demonstrar os comandos básicos do R, na prática tais comandos são bastante limitados, uma vez que um problema real de análise de dados certamente irá ter um maior volume de informações do mundo real.\nUm dos procedimentos mais utilizados no R é a criação de vetores atômicos. Esses são objetos que guardam uma série de elementos. Todos os elementos de um vetor atômico devem possuir a mesma classe, o que justifica a sua propriedade atômica. Um exemplo seria representar no R uma série de preços diários de uma ação. Tal série possui vários valores numéricos que formam um vetor da classe numérica.\nVetores atômicos são criados no R através do uso do comando c()** **, o qual é oriundo do verbo em inglês combine. Por exemplo, caso eu quisesse combinar os valores 1, 2 e 3 em um vetor, eu poderia fazê-lo através do seguinte comando:\n\n# set vector\nx &lt;- c(1, 2, 3)\n\n# print it\nprint(x)\n\nR&gt; [1] 1 2 3\n\n\nEsse comando funciona da mesma maneira para qualquer número de elementos. Caso necessário, poderíamos criar um vetor com mais elementos simplesmente adicionando valores após o 3, tal como em x &lt;- c(1, 2, 3, 4, 5).\nO uso do comando c() não é exclusivo para vetores numéricos. Por exemplo, poderíamos criar um vetor de outra classe de dados, tal como character:\n\ny &lt;- c('text 1', 'text 2', 'text 3', 'text 4')\nprint(y)\n\nR&gt; [1] \"text 1\" \"text 2\" \"text 3\" \"text 4\"\n\n\nA única restrição no uso do comando c() é que todos os itens do vetor tenham a mesma classe. Se inserirmos dados de classes diferentes, o R irá tentar transformar os itens para a mesma classe seguindo uma lógica própria, onde a classe mais complexa sempre tem preferência. Caso ele não consiga transformar todos os elementos para uma classe só, uma mensagem de erro será retornada. Observe no próximo exemplo como os valores numéricos no primeiro e segundo elemento de x são transformados para a classe de caracteres.\n\n# numeric class\nx &lt;- c(1, 2)\nclass(x)\n\nR&gt; [1] \"numeric\"\n\n# character class\nx &lt;- c(1, 2, '3')\nclass(x)\n\nR&gt; [1] \"character\"\n\n\nOutra utilização do comando c() é a combinação de vetores. De fato, isto é exatamente o que fizemos ao executar o código c(1, 2, 3). Neste caso, cada vetor possuía um elemento. Podemos realizar o mesmo com vetores maiores. Veja a seguir:\n\n# set x and y\nx &lt;- c(1, 2, 3)\ny &lt;- c(4, 5)\n\n# print concatenation between x and y\nprint(c(x, y))\n\nR&gt; [1] 1 2 3 4 5\n\n\nPortanto, o comando c() possui duas funções principais: criar e combinar vetores."
  },
  {
    "objectID": "02-como-o-r-funciona.html#conhecendo-os-objetos-criados",
    "href": "02-como-o-r-funciona.html#conhecendo-os-objetos-criados",
    "title": "2  Como o R Funciona?",
    "section": "2.4 Conhecendo os Objetos Criados",
    "text": "2.4 Conhecendo os Objetos Criados\nApós a execução de diversos comandos no editor ou prompt, é desejável saber quais são os objetos criados pelo código. É possível descobrir essa informação simplesmente olhando para o lado direito superior do RStudio, na aba da área de trabalho. Porém, existe um comando que sinaliza a mesma informação no prompt. Com o fim de saber quais são as variáveis atualmente disponíveis na memória do R, pode-se utilizar o comando ls() . Observe o exemplo a seguir:\n\n# set vars\nx &lt;- 1\ny &lt;- 2\nz &lt;- 3\n\n# show current objects\nls()\n\n\n\nR&gt; [1] \"x\" \"y\" \"z\"\n\n\nOs objetos x, y e z foram criados e estavam disponíveis no ambiente de trabalho atual, juntamente com outros objetos. Para descobrir os valores dos mesmos, basta digitar os nomes dos objetos e apertar enter no prompt:\n\nx\n\nR&gt; [1] 1\n\ny\n\nR&gt; [1] 2\n\nz\n\nR&gt; [1] 3\n\n\nDigitar o nome do objeto na tela tem o mesmo resultado que utilizar a função print() . De fato, ao executar o nome de uma variável, internamente o R passa esse objeto para a função print() .\nNo R, conforme já mostrado, todos os objetos pertencem a alguma classe. Para descobrir a classe de um objeto, basta utilizar a função class() . Observe no exemplo a seguir que x é um objeto da classe numérica e y é um objeto da classe de texto (character). \n\n# set vars\nx &lt;- 1\ny &lt;- 'a'\n\n# check classes\nclass(x)\n\nR&gt; [1] \"numeric\"\n\nclass(y)\n\nR&gt; [1] \"character\"\n\n\nOutra maneira de conhecer melhor um objeto é verificar a sua representação em texto. Todo objeto no R possui uma representação textual e a verificação desta é realizada através da função str() :\n\n# print textual representation of a vector\nx &lt;- 1:10\nprint(str(x))\n\nR&gt;  int [1:10] 1 2 3 4 5 6 7 8 9 10\nR&gt; NULL\n\n\nEssa função é particularmente útil quando se está tentando entender os detalhes de um objeto mais complexo, tal como uma tabela. A utilidade da representação textual é que nela aparece o tamanho do objeto e suas classes internas. Nesse caso, o objeto x é da classe integer e possui dez elementos."
  },
  {
    "objectID": "02-como-o-r-funciona.html#mostrando-e-formatando-informações-na-tela",
    "href": "02-como-o-r-funciona.html#mostrando-e-formatando-informações-na-tela",
    "title": "2  Como o R Funciona?",
    "section": "2.5 Mostrando e Formatando Informações na Tela",
    "text": "2.5 Mostrando e Formatando Informações na Tela\nComo já vimos, é possível mostrar o valor de uma variável na tela de duas formas, digitando o nome dela no prompt ou então utilizando a função print() . Explicando melhor, a função print() é voltada para a apresentação de objetos e pode ser customizada. Por exemplo, caso tivéssemos um objeto de classe chamada MyTable que representasse um objeto tabular, poderíamos criar uma função chamada print.MyTable que irá mostrar uma tabela na tela com um formato especial tal como número de linhas, nomes das colunas, etc. A função print() , portanto, pode ser customizada para cada classe de objeto.\nPorém, existem outras funções específicas para apresentar texto (e não objetos) no prompt. A principal delas é message. Essa toma como input um texto, processa-o para símbolos específicos e o apresenta na tela. Essa função é muito mais poderosa e personalizável do que print() .\nPor exemplo, caso quiséssemos mostrar na tela o texto 'O valor de x é igual a 2', poderíamos fazê-lo da seguinte forma:\n\n# set var\nx &lt;- 2\n\n# print with message()\nmessage('The value of x is', x)\n\nR&gt; The value of x is2\n\n\nFunção message também funciona para vetores:\n\n# set vec\nx &lt;- 2:5\n\n# print with message()\nmessage('The values in x are: ', x)\n\nR&gt; The values in x are: 2345\n\n\nA customização da saída da tela é possível através de comandos específicos. Por exemplo, se quiséssemos quebrar a linha da tela, poderíamos fazê-lo através do uso do caractere reservado \\n:\n\n# set char\nmy_text &lt;- 'First line,\\nSecond Line,\\nThird Line'\n\n# print with new lines\nmessage(my_text)\n\nR&gt; First line,\nR&gt; Second Line,\nR&gt; Third Line\n\n\nObserve que o uso do print() não resultaria no mesmo efeito, uma vez que esse comando apresenta o texto como ele é, sem processar para efeitos específicos:\n\nprint(my_text)\n\nR&gt; [1] \"First line,\\nSecond Line,\\nThird Line\"\n\n\nOutro exemplo no uso de comandos específicos para texto é adicionar um espaçamento tab no texto apresentado com o símbolo \\t. Veja a seguir:\n\n# set char with \\t\nmy_text_1 &lt;- 'A and B'\nmy_text_2 &lt;- '\\tA and B'\nmy_text_3 &lt;- '\\t\\tA and B'\n\n# print with message()\nmessage(my_text_1)\n\nR&gt; A and B\n\nmessage(my_text_2)\n\nR&gt;  A and B\n\nmessage(my_text_3)\n\nR&gt;      A and B\n\n\nVale destacar que, na grande maioria dos casos de pesquisa, será necessário apenas o uso de \\n para formatar textos de saída. Outras maneiras de manipular a saída de texto no prompt com base em símbolos específicos são encontradas no manual oficial do R.\nParte do processo de apresentação de texto na tela é a customização do mesmo. Para isto, existem duas funções muito úteis: paste() e format() .\nA função paste() cola uma série de caracteres juntos. É uma função muito útil, a qual será utilizada intensamente para o resto dos exemplos deste livro. Observe o código a seguir:\n\n# set chars\nmy_text_1 &lt;- 'I am a text'\nmy_text_2 &lt;- 'very beautiful'\nmy_text_3 &lt;- 'and informative.'\n\n# using paste and message\nmessage(paste(my_text_1, my_text_2, my_text_3))\n\nR&gt; I am a text very beautiful and informative.\n\n\nO resultado anterior não está muito longe do que fizemos no exemplo com a função print() . Note, porém, que a função paste() adiciona um espaço entre cada texto. Caso não quiséssemos esse espaço, poderíamos usar a função paste0() : \n\n# using paste0\nmessage(paste0(my_text_1, my_text_2, my_text_3))\n\nR&gt; I am a textvery beautifuland informative.\n\n\n\n\n\n\n\n\nImportante\n\n\n\nUma alternativa a função message é cat (concatenate and print). Não é incomum encontrarmos códigos onde mensagens para o usuário são transmitidas via cat e não message. Como regra, dê preferência a message pois esta é mais fácil de controlar. Por exemplo, caso o usuário quiser silenciar uma função, omitindo todas saídas da tela, bastaria usar o comando suppressMessages.\n\n\nOutra possibilidade muito útil no uso do paste() é modificar o texto entre a junção dos itens a serem colados. Por exemplo, caso quiséssemos adicionar uma vírgula e espaço (,) entre cada item, poderíamos fazer isso através do uso do argumento sep, como a seguir:\n\n# using custom separator\nmessage(paste(my_text_1, my_text_2, my_text_3, sep = ', '))\n\nR&gt; I am a text, very beautiful, and informative.\n\n\nCaso tivéssemos um vetor atômico com os elementos da frase em um objeto apenas, poderíamos atingir o mesmo resultado utilizando paste() o argumento collapse:\n\n# using paste with collapse argument\nmy_text &lt;-c('Eu sou um texto', 'muito bonito', 'e charmoso.')\nmessage(paste(my_text, collapse = ', '))\n\nR&gt; Eu sou um texto, muito bonito, e charmoso.\n\n\nProsseguindo, o comando format() é utilizado para formatar números e datas. É especialmente útil quando formos montar tabelas e buscarmos apresentar os números de uma maneira visualmente atraente. Por definição, o R apresenta uma série de dígitos após a vírgula:\n\n# message without formatting\nmessage(1/3)\n\nR&gt; 0.333333333333333\n\n\nCaso quiséssemos apenas dois dígitos aparecendo na tela, utilizaríamos o seguinte código:\n\n# message with format and two digits\nmessage(format(1/3, digits=2))\n\nR&gt; 0.33\n\n\nTal como, também é possível mudar o símbolo de decimal:\n\n# message with format and two digits\nmessage(format(1/3, decimal.mark = ','))\n\nR&gt; 0,3333333\n\n\nTal flexibilidade é muito útil quando devemos reportar resultados respeitando algum formato local tal como o Brasileiro.\nUma alternativa recente e muito interessante para o comando paste() é stringr::str_c() e stringr::str_glue() . Enquanto a primeira é quase idêntica a paste0() , a segunda tem uma maneira pecular de juntar objetos. Veja um exemplo a seguir:\n\nlibrary(stringr)\n\n# define some vars\nmy_name &lt;- 'Pedro'\nmy_age &lt;- 23\n\n# using base::paste0\nmy_str_1 &lt;- paste0('My name is ', my_name, ' and my age is ', my_age)\n\n# using stringr::str_c\nmy_str_2 &lt;- str_c('My name is ', my_name, ' and my age is ', my_age)\n\n# using stringr::str_glue\nmy_str_3 &lt;- str_glue('My name is {my_name} and my age is {my_age}')\n\nidentical(my_str_1, my_str_2)\n\nR&gt; [1] TRUE\n\nidentical(my_str_1, my_str_3)\n\nR&gt; [1] FALSE\n\nidentical(my_str_2, my_str_3)\n\nR&gt; [1] FALSE\n\n\nComo vemos, temos três alternativas para o mesmo resultado final. Note que str_glue usa de chaves para definir as variáveis dentro do próprio texto. Esse é um formato muito interessante e prático para concatenar textos em um único objeto."
  },
  {
    "objectID": "02-como-o-r-funciona.html#conhecendo-o-tamanho-dos-objetos",
    "href": "02-como-o-r-funciona.html#conhecendo-o-tamanho-dos-objetos",
    "title": "2  Como o R Funciona?",
    "section": "2.6 Conhecendo o Tamanho dos Objetos",
    "text": "2.6 Conhecendo o Tamanho dos Objetos\nNa prática de programação com o R, é muito importante saber o tamanho das variáveis que estão sendo utilizadas. Isso serve não somente para auxiliar o usuário na verificação de possíveis erros do código, mas também para saber o tamanho necessário em certos procedimentos de iteração tal como loops, os quais serão tratados em capítulo futuro.\nNo R, o tamanho do objeto pode ser verificado com o uso de quatro principais funções: length() , nrow() , ncol() e dim() .\nA função length() é destinada a objetos com uma única dimensão, tal como vetores atômicos:\n\n# set x\nx &lt;- c(2, 3, 3, 4, 2, 1)\n\n# get length x\nn &lt;- length(x)\n\n# display message\nmessage(paste('The length of x is', n))\n\nR&gt; The length of x is 6\n\n\nPara objetos com mais de uma dimensão, por exemplo matrizes e dataframes, utilizam-se as funções nrow() , ncol() e dim() para descobrir o número de linhas (primeira dimensão) e o número de colunas (segunda dimensão). Veja a diferença a seguir.\n\n# set matrix and print it\nx &lt;- matrix(1:20, nrow = 4, ncol = 5)\nprint(x)\n\nR&gt;      [,1] [,2] [,3] [,4] [,5]\nR&gt; [1,]    1    5    9   13   17\nR&gt; [2,]    2    6   10   14   18\nR&gt; [3,]    3    7   11   15   19\nR&gt; [4,]    4    8   12   16   20\n\n# find number of rows, columns and elements\nmy_nrow &lt;- nrow(x)\nmy_ncol &lt;- ncol(x)\nmy_length &lt;- length(x)\n\n# print message\nmessage(paste('\\nThe number of lines in x is ', my_nrow))\n\nR&gt; \nR&gt; The number of lines in x is  4\n\nmessage(paste('\\nThe number of columns in x is ', my_ncol))\n\nR&gt; \nR&gt; The number of columns in x is  5\n\nmessage(paste('\\nThe number of elements in x is ', my_length))\n\nR&gt; \nR&gt; The number of elements in x is  20\n\n\nJá a função dim() mostra a dimensão do objeto, resultando em um vetor numérico como saída. Essa deve ser utilizada quando o objeto tiver mais de duas dimensões. Na prática, esses casos são raros. Um exemplo para a variável x é dado a seguir:\n\nprint(dim(x))\n\nR&gt; [1] 4 5\n\n\nPara o caso de objetos com mais de duas dimensões, podemos utilizar a função array para criá-los e dim() para descobrir o seu tamanho:\n\n# set array with dimension\nmy_array &lt;- array(1:9, dim = c(3,3,3))\n\n# print it\nprint(my_array)\n\nR&gt; , , 1\nR&gt; \nR&gt;      [,1] [,2] [,3]\nR&gt; [1,]    1    4    7\nR&gt; [2,]    2    5    8\nR&gt; [3,]    3    6    9\nR&gt; \nR&gt; , , 2\nR&gt; \nR&gt;      [,1] [,2] [,3]\nR&gt; [1,]    1    4    7\nR&gt; [2,]    2    5    8\nR&gt; [3,]    3    6    9\nR&gt; \nR&gt; , , 3\nR&gt; \nR&gt;      [,1] [,2] [,3]\nR&gt; [1,]    1    4    7\nR&gt; [2,]    2    5    8\nR&gt; [3,]    3    6    9\n\n# print its dimension\nprint(dim(my_array))\n\nR&gt; [1] 3 3 3\n\n\nReforçando, cada objeto no R tem suas propriedades e funções específicas para manipulação.\n\n\n\n\n\n\nCuidado\n\n\n\nUma observação importante aqui é que as funções anteriores não servem para descobrir o número de letras em um texto. Esse é um erro bastante comum. Por exemplo, caso tivéssemos um objeto do tipo texto e usássemos a função length() , o resultado seria o seguinte:\n\n# set char object\nmy_char &lt;- 'abcde'\n\n# find its length (and NOT number of characters)\nprint(length(my_char))\n\nR&gt; [1] 1\n\n\nIsso ocorre pois a função length() retorna o número de elementos. Nesse caso, my_char possui apenas um elemento. Para descobrir o número de caracteres no objeto, utilizamos a função nchar() , conforme a seguir:\n\n# using nchar for number of characters\nprint(nchar(my_char))\n\nR&gt; [1] 5"
  },
  {
    "objectID": "03-rstudio.html#executando-códigos-em-um-script",
    "href": "03-rstudio.html#executando-códigos-em-um-script",
    "title": "3  Introdução ao RStudio",
    "section": "3.1 Executando Códigos em um Script",
    "text": "3.1 Executando Códigos em um Script\nAgora, vamos juntar todos os códigos digitados anteriormente e colar na tela do editor (lado esquerdo superior), assim como mostrado a seguir:\n\n# set objects\nx &lt;- 1\ny &lt;- 'my text'\n\n# print it\nprint(x)\nprint(1:50)\n\nApós colar todos os comandos no editor, salve o arquivo .R em alguma pasta pessoal. Esse arquivo, o qual no momento não faz nada de especial, registrou os passos de um algoritmo simples que cria dois objetos e mostra os seus valores. Futuramente esse irá ter mais forma, com a importação de dados, manipulação e modelagem dos mesmos e saída de tabelas e figuras.\nNo RStudio existem alguns atalhos predefinidos para executar códigos que economizam bastante tempo. Para executar um script inteiro, basta apertar control + shift + s. Esse é o comando source. Com o RStudio aberto, sugiro testar essa combinação de teclas e verificar como o código digitado anteriormente é executado, mostrando os valores no prompt do R. Visualmente, o resultado deve ser próximo ao apresentado na figura Figure 3.3.\n\n\n\n\n\nFigure 3.3: Exemplo de Rotina no R\n\n\n\n\nOutro comando muito útil é a execução por linha. Nesse caso não é executado todo o arquivo, mas somente a linha em que o cursor do mouse se encontra. Para isto, basta apertar control+enter. Esse atalho é bastante útil no desenvolvimento de rotinas pois permite que cada linha seja testada antes de executar o programa inteiro. Como um exemplo de uso, aponte o cursor para a linha print(x) e pressione control + enter. Verás que o valor de x é mostrado na tela do prompt. A seguir destaco esses e outros atalhos do RStudio, os quais também são muito úteis.\n\ncontrol+shift+s executa o arquivo atual do RStudio, sem mostrar comandos no prompt (sem eco – somente saída);\ncontrol+shift+enter: executa o arquivo atual, mostrando comandos na tela (com eco – código e saída);\ncontrol+enter: executa a linha selecionada, mostrando comandos na tela;\ncontrol+shift+b: executa os códigos do início do arquivo até a linha atual onde o cursor se encontra;\ncontrol+shift+e: executa os códigos da linha onde o cursor se encontra até o final do arquivo.\n\nSugere-se que esses atalhos sejam memorizados e utilizados. Isso facilita bastante o uso do programa. Para aqueles que gostam de utilizar o mouse, uma maneira alternativa para rodar o código do script é apertar o botão source, localizado no canto direito superior do editor de rotinas. Isto é equivalente ao atalho control+shift+s.\nPorém, no mundo real de programação, poucos são os casos em que uma análise de dados é realizada por um script apenas. Como uma forma de organizar o código, pode-se dividir o trabalho em N scripts diferentes, onde um deles é o “mestre”, responsável por rodar os demais.\nNeste caso, para executar os scripts em sequência, basta chamá-los no script mestre com o comando source() , como no código a seguir:\n\n# Import all data\nsource('01-import-data.R')\n\n# Clean up\nsource('02-clean-data.R')\n\n# Build tables\nsource('03-build-table.R')\n\nNesse caso, o código anterior é equivalente a abrirmos e executarmos (control + shift + s) cada um dos scripts sequencialmente.\nComo podemos ver, existem diversas maneiras de executar uma rotina de pesquisa. Na prática, porém, iras centralizar o uso em dois comandos apenas: control+shift+s para rodar o script inteiro e control+enter para rodar por linha."
  },
  {
    "objectID": "03-rstudio.html#tipos-de-arquivos",
    "href": "03-rstudio.html#tipos-de-arquivos",
    "title": "3  Introdução ao RStudio",
    "section": "3.2 Tipos de Arquivos",
    "text": "3.2 Tipos de Arquivos\nAssim como outros programas, o R e o RStudio possuem um ecossistema de arquivos e cada extensão tem uma finalidade diferente. A seguir apresenta-se uma descrição de diversas extensões de arquivos exclusivos ao R e RStudio. Os itens da lista estão ordenados por ordem de importância e uso.\nArquivos com extensão .R: Representam arquivos do tipo texto contendo diversas instruções para o R. Esses são os arquivos que conterão o código da pesquisa e onde passaremos a maior parte do tempo. Também pode ser chamado de um script ou rotina de pesquisa. Como sugestão, pode-se dividir toda uma pesquisa em etapas e arquivos numerados. Exemplos: 01-Get-Data.R, 02-Clean-data.R, 03-Estimate-Models.R.\nArquivos com extensão .RData e .rds: armazenam dados nativos do R. Esses arquivos servem para salvar (ou congelar) objetos do R em um arquivo no disco rígido do computador para, em sessão futura, serem novamente carregados. Por exemplo, podes guardar o resultado de uma pesquisa em uma tabela, a qual é salva em um arquivo com extensão .RData ou .rds. Exemplos: Raw-Data.RData, Table-Results.rds.\nArquivos com extensão .Rmd, .Rnw e .qmd: São arquivos relacionados a tecnologia Rmarkdown e Quarto. O uso desses arquivos permite a criação de documentos onde texto e código são integrados.\nArquivos com extensão .Rproj: Contém informações para a edição de projetos no RStudio. O sistema de projetos do RStudio permite a configuração customizada do projeto e também facilita a utilização de ferramentas de controle de código, tal como controle de versões. O seu uso, porém, não é essencial. Para aqueles com interesse em conhecer esta funcionalidade, sugiro a leitura do manual do RStudio. Uma maneira simples de entender os tipos de projetos disponíveis é, no RStudio, clicar em “File”, “New project”, “New Folder” e assim deve aparecer uma tela com todos os tipos possíveis de projetos no RStudio. Exemplo: My-Dissertation-Project.Rproj."
  },
  {
    "objectID": "03-rstudio.html#testando-código",
    "href": "03-rstudio.html#testando-código",
    "title": "3  Introdução ao RStudio",
    "section": "3.3 Testando Código",
    "text": "3.3 Testando Código\nO desenvolvimento de códigos em R segue um conjunto de etapas. Primeiro você escreverá uma nova linha de comando em uma rotina. Essa linha será testada com o atalho control + enter, verificando-se a ocorrência de erros e as saídas na tela. Caso não houver erro e o resultado for igual ao esperado, parte-se para a próxima linha de código.\nUm ciclo de trabalho fica claro, a escrita do código da linha atual é seguida pela execução, seguido da verificação de resultados, modificação caso necessário e assim por diante. Esse é um processo normal e esperado. Dado que uma rotina é lida e executada de cima para baixo, você precisa ter certeza de que cada linha de código está corretamente especificada antes de passar para a próxima.\nQuando você está tentando encontrar um erro em um script preexistente, o R oferece algumas ferramentas para controlar e avaliar sua execução. Isso é especialmente útil quando você possui um código longo e complicado. A ferramenta de teste mais simples e fácil de utilizar que o RStudio oferece é o ponto de interrupção do código. No RStudio, você pode clicar no lado esquerdo do editor e aparecerá um círculo vermelho, como na Figura Figure 3.4.\n\n\n\n\n\nFigure 3.4: Exemplo de debug\n\n\n\n\nO círculo vermelho indica um ponto de interrupção do código que forçará o R a pausar a execução nessa linha. Quando a execução atinge o ponto de interrupção, o prompt mudará para browser[1]&gt; e você poderá verificar o conteúdo dos objetos. No console, você tem a opção de continuar a execução para o próximo ponto de interrupção ou interrompê-la. O mesmo resultado pode ser alcançado usando a função browser() . Dê uma olhada:\n\n# set x\nx &lt;- 1\n\n# set y\nbrowser()\ny &lt;- 'My humble text'\n\n# print contents of x\nprint(x)\n\nO resultado prático do código anterior é o mesmo que utilizar o círculo vermelho do RStudio, figura Figure 3.4. Porém, o uso do browser() permite mais controle sobre onde a execução deve ser pausada. Como um teste, copie e cole o código anterior no RStudio, salve em um novo script e execute com Control + Shift + S. Para sair do ambiente de depuramento (debug), aperte enter no prompt do RStudio."
  },
  {
    "objectID": "03-rstudio.html#cancelando-a-execução-de-um-código",
    "href": "03-rstudio.html#cancelando-a-execução-de-um-código",
    "title": "3  Introdução ao RStudio",
    "section": "3.4 Cancelando a Execução de um Código",
    "text": "3.4 Cancelando a Execução de um Código\nToda vez que o R estiver executando algum código, uma sinalização visual no formato de um pequeno círculo vermelho no canto direito do prompt irá aparecer. Caso conseguir ler (o símbolo é pequeno em monitores modernos), o texto indica o termo stop. Esse símbolo não somente indica que o programa ainda está rodando mas também pode ser utilizado para cancelar a execução de um código. Para isso, basta clicar no referido botão. Outra maneira de cancelar uma execução é apontar o mouse no prompt e pressionar a tecla Esc no teclado.\nPara testar o cancelamento de código, copie e cole o código a seguir em um script do RStudio. Após salvar, rode o mesmo com control+shift+s.\n\nfor (i in 1:100) {\n  message('\\nRunning code (please make it stop by hitting esc!)')\n  Sys.sleep(1)\n}\n\nO código anterior usa um comando especial do tipo for para mostrar a mensagem a cada segundo. Neste caso, o código demorará 100 segundos para rodar. Caso não desejes esperar, aperte esc para cancelar a execução. Por enquanto, não se preocupe com as funções utilizadas no exemplo. Iremos discutir o uso do comando for no capítulo Chapter 10."
  },
  {
    "objectID": "03-rstudio.html#procurando-ajuda",
    "href": "03-rstudio.html#procurando-ajuda",
    "title": "3  Introdução ao RStudio",
    "section": "3.5 Procurando Ajuda",
    "text": "3.5 Procurando Ajuda\nUma tarefa muito comum no uso do R é procurar ajuda. A quantidade de funções disponíveis para o R é gigantesca e memorizar todas peculariedades é quase impossível. Assim, até mesmo usuários avançados comumente procuram ajuda sobre tarefas específicas no programa, seja para entender detalhes sobre algumas funções ou estudar um novo procedimento.\nÉ possível buscar ajuda utilizando tanto o painel de help do RStudio como diretamente do prompt. Para isso, basta digitar o ponto de interrogação junto ao objeto sobre o qual se deseja ajuda, tal como em ?mean. Nesse caso, o objeto mean() é uma função e o uso do comando irá abrir o painel de ajuda sobre ela.\nNo R, toda tela de ajuda de uma função é igual, conforme se vê na Figure 3.5 apresentada a seguir. Esta mostra uma descrição da função mean() , seus argumentos de entrada explicados e também o seu objeto de saída. A tela de ajuda segue com referências e sugestões para outras funções relacionadas. Mais importante, os exemplos de uso da função aparecem por último e podem ser copiados e colados para acelerar o aprendizado no uso da função.\n\n\n\n\n\n\n\n\n\nFigure 3.5: Usando o sistema de ajuda do RStudio\n\n\n\n\nCaso quiséssemos procurar um termo nos arquivos de ajuda, bastaria utilizar o comando ??\"standard deviation\". Essa operação irá procurar a ocorrência do termo em todos os pacotes do R e é muito útil para aprender como realizar alguma operação, nesse caso o cálculo de desvio padrão.\nComo sugestão, o ponto inicial e mais direto para aprender uma nova função é observando o seu exemplo de uso, localizada no final da página de ajuda. Com isto, podes verificar quais tipos de objetos de entrada a mesma aceita e qual o formato e o tipo de objeto na sua saída. Após isso, leia atentamente a tela de ajuda para entender se a mesma faz exatamente o que esperas e quais são as suas opções de uso nas respectivas entradas. Caso a função realizar o procedimento desejado, podes copiar e colar o exemplo de uso para o teu próprio script, ajustando onde for necessário.\nOutra fonte muito importante de ajuda é a própria internet. Sites como stackoverflow.com e mailing lists específicos do R, cujo conteúdo também está na internet, são fontes preciosas de informação. Havendo alguma dúvida que não foi possível solucionar via leitura dos arquivos de ajuda do R, vale o esforço de procurar uma solução via mecanismo de busca na internet. Em muitas situações, o seu problema, por mais específico que seja, já ocorreu e já foi solucionado por outros usuários.\nCaso estiver recebendo uma mensagem de erro enigmática, outra dica é copiar e colar a mesma para uma pesquisa no Google. Aqui apresenta-se outro benefício do uso da língua inglesa. É mais provável que encontres a solução se o erro for escrito em inglês, dado o maior número de usuários na comunidade global. Caso não encontrar uma solução desta forma, podes inserir uma pergunta no stackoverflow ou no grupo Brasileiro do R no Facebook.\n\n\n\n\n\n\nCuidado\n\n\n\nToda vez que for pedir ajuda na internet, procure sempre 1) descrever claramente o seu problema e 2) adicionar um código reproduzível do seu problema. Assim, o leitor pode facilmente verificar o que está acontecendo ao rodar o exemplo no seu computador. Não tenho dúvida que, se respeitar ambas regras, logo uma pessoa caridosa lhe ajudará com o seu problema."
  },
  {
    "objectID": "03-rstudio.html#utilizando-code-completion-com-a-tecla-tab",
    "href": "03-rstudio.html#utilizando-code-completion-com-a-tecla-tab",
    "title": "3  Introdução ao RStudio",
    "section": "3.6 Utilizando Code Completion com a Tecla tab",
    "text": "3.6 Utilizando Code Completion com a Tecla tab\nUm dos recursos mais úteis do RStudio é o preenchimento automático de código (code completion). Essa é uma ferramenta de edição que facilita o encontro de nomes de objetos, nome de pacotes, nome de arquivos e nomes de entradas em funções. O seu uso é muito simples. Após digitar um texto qualquer, basta apertar a tecla tab e uma série de opções aparecerá. Veja a Figura @ref(fig:autocomplete) apresentada a seguir, em que, após digitar a letra f e apertar tab, aparece uma janela com uma lista de objetos que iniciam com a respectiva letra. Figura Figure 3.6\n\n\n\n\n\n\n\n\n\nFigure 3.6: Usando o sistema de ajuda do RStudio\n\n\n\n\nEssa ferramenta também funciona para pacotes. Para verificar, digite library(r) no prompt ou no editor, coloque o cursor entre os parênteses e aperte tab. O resultado deve ser algo parecido com a Figure 3.7.\n\n\n\n\n\n\n\n\n\nFigure 3.7: Usando o autocomplete para procurar pacotes\n\n\n\n\nObserve que uma descrição do pacote ou objeto também é oferecida. Isso facilita bastante o dia a dia, pois a memorização das funcionalidades e dos nomes dos pacotes e os objetos do R não é uma tarefa fácil. O uso do tab diminui o tempo de investigação dos nomes e evita possíveis erros de digitação na definição destes.\nO uso dessa ferramenta torna-se ainda mais benéfico quando os objetos são nomeados com algum tipo de padrão. No restante do livro observarás que os objetos tendem a ser nomeados com o prefixo my, como em my_x, my_num, my_char. O uso desse padrão facilita o encontro futuro do nome dos objetos, pois basta digitar my, apertar tab e uma lista de todos os objetos criados pelo usuário aparecerá.\nOutro uso do tab é no encontro de arquivos e pastas no computador. Basta criar uma variável como my_file &lt;- \" \", apontar o cursor para o meio das aspas e apertar a tecla tab. Uma tela com os arquivos e pastas do diretório atual de trabalho aparecerá, conforme mostrado na Figure 3.8. Nesse caso específico, o R estava direcionado para a minha pasta de códigos, em que é possível enxergar diversos trabalhos realizados no passado.\n\n\n\n\n\n\n\n\n\nFigure 3.8: Usando o autocomplete para navegar diretórios\n\n\n\n\nUma dica aqui é utilizar o tab com a raiz do computador. Assumindo que o disco do seu computador está alocado para C:/, digite my_file &lt;- \"C:/\" e pressione tab após o símbolo /. Uma tela com os arquivos da raiz do computador aparecerá no RStudio. Podes facilmente navegar o sistema de arquivos utilizando as setas e enter.\nO autocomplete também funciona para encontrar e definir as entradas de uma função. Veja um exemplo na Figure 3.9.\n\n\n\n\n\n\n\n\n\nFigure 3.9: Usando o autocomplete para navegar argumentos de funções\n\n\n\n\n\n\n\n\n\n\nImportante\n\n\n\nO autocomplete é uma das ferramentas mais importantes do RStudio, funcionando para encontro de objetos, locais no disco rígido, pacotes e funções. Acostume-se a utilizar a tecla tab o quanto antes e logo verá como fica mais fácil escrever código rapidamente, e sem erros de digitação."
  },
  {
    "objectID": "04-pacotes.html#instalando-pacotes-do-cran",
    "href": "04-pacotes.html#instalando-pacotes-do-cran",
    "title": "4  Pacotes do R",
    "section": "4.1 Instalando Pacotes do CRAN",
    "text": "4.1 Instalando Pacotes do CRAN\nPara instalar um pacote, basta utilizar o comando install.packages() . Como exemplo, vamos instalar um pacote que será utilizado nos capítulos futuros, o {readr} (Wickham, Hester, and Bryan 2023):\n\n# install pkg readr\ninstall.packages('readr')\n\nCopie e cole este comando no prompt e pronto! O R irá baixar os arquivos necessários e instalar o pacote {readr} (Wickham, Hester, and Bryan 2023) e suas dependências. Após isto, as funções relativas ao pacote estarão prontas para serem usadas após o carregamento do módulo (detalhes a seguir). Observe que definimos o nome do pacote na instalação como se fosse texto, com o uso das aspas (\"). Caso o pacote instalado seja dependente de outros pacotes, o R automaticamente instala todos módulos faltantes. Assim, todos os requerimentos para o uso do respectivo pacote já serão satisfeitos e tudo funcionará perfeitamente. É possível, porém, que um pacote tenha uma dependência externa. Como um exemplo, o pacote RndTexExams depende da existência de uma instalação do LaTex. Geralmente essa é anunciada na sua descrição e um erro é sinalizado na execução do programa quando o LaTex não é encontrado. Fique atento, portanto, a esses casos.\nAproveitando o tópico, sugiro que o leitor já instale todos os pacotes do {tidyverse} (Wickham 2023) com o seguinte código:\n\n# install pkgs from tidyverse\ninstall.packages('tidyverse')\n\nO {tidyverse} (Wickham 2023) é um conjunto de pacotes voltados a data science e com uma sintaxe própria e consistente, voltada a praticabilidade. Verás que, em uma instalação nova do R, o {tidyverse} (Wickham 2023) depende de uma grande quantidade de pacotes."
  },
  {
    "objectID": "04-pacotes.html#instalando-pacotes-do-github",
    "href": "04-pacotes.html#instalando-pacotes-do-github",
    "title": "4  Pacotes do R",
    "section": "4.2 Instalando Pacotes do Github",
    "text": "4.2 Instalando Pacotes do Github\nPara instalar um pacote diretamente do Github, é necessário instalar antes o pacote devtools, disponível no CRAN: \n\n# install devtools\ninstall.packages('devtools')\n\nApós isto, utilize função devtools::install_github para instalar um pacote diretamente do Github. Note que o símbolo :: indica que função install_github pertence ao pacote devtools. Com esta particular sintaxe, não precisamos carregar todo o pacote para utilizar apenas uma função.\nNo exemplo a seguir instalamos a versão em desenvolvimento do pacote ggplot2, cuja versão oficial também está disponível no CRAN: \n\n# install ggplot2 from github\ndevtools::install_github(\"hadley/ggplot2\")\n\nObserve que o nome do usuário do repositório também é incluído. No caso anterior, o nome hadley pertence ao desenvolvedor do ggplot2, Hadley Wickham. No decorrer do livro notará que esse nome aparecerá diversas vezes, dado que Hadley é um prolífico e competente desenvolvedor de diversos pacotes do R e do {tidyverse} (Wickham 2023).\n\n\n\n\n\n\nCuidado\n\n\n\nUm aviso aqui é importante. Os pacotes do github não são moderados. Qualquer pessoa pode enviar código para lá e o conteúdo não é checado de forma independente. Nunca instale pacotes do github sem conhecer os autores. Apesar de improvável – nunca aconteceu comigo por exemplo – é possível que esses possuam algum código malicioso."
  },
  {
    "objectID": "04-pacotes.html#carregando-pacotes",
    "href": "04-pacotes.html#carregando-pacotes",
    "title": "4  Pacotes do R",
    "section": "4.3 Carregando Pacotes",
    "text": "4.3 Carregando Pacotes\nDentro de uma rotina de pesquisa, utilizamos a função library para carregar um pacote na nossa sessão do R. Ao fecharmos o RStudio ou então iniciar uma nova sessão do R, os pacotes são descarregados. Vale salientar que alguns pacotes, tal como o {base} (R Core Team 2023) e o stats, são inicializados automaticamente a cada nova sessão. A grande maioria, porém, deve ser carregada no início dos scripts. Veja o exemplo a seguir:\n\n# load dplyr\nlibrary(dplyr)\n\nA partir disso, todas as funções do pacote estarão disponíveis para o usuário. Note que não é necessário utilizar aspas (\") ao carregar o pacote. Caso utilize uma função específica do pacote e não deseje carregar todo ele, pode fazê-lo através do uso do símbolo especial ::, conforme o exemplo a seguir.\n\n# call fct fortune() from pkg fortune\nfortunes::fortune(10)\n\nR&gt; \nR&gt; Overall, SAS is about 11 years behind R and S-Plus in\nR&gt; statistical capabilities (last year it was about 10 years\nR&gt; behind) in my estimation.\nR&gt;    -- Frank Harrell (SAS User, 1969-1991)\nR&gt;       R-help (September 2003)\n\n\nNesse caso, utilizamos a função fortune do próprio pacote fortunes, o qual mostra na tela uma frase possivelmente engraçada escolhida do mailing list do R. Nesse caso, selecionamos a mensagem número 10. Se não tiver disponível o pacote, o R mostrará a seguinte mensagem de erro:\n\n\nR&gt; Error in library(\"fortune\") : there is no package called \"fortune\"\n\n\nPara resolver, utilize o comando install.packages(\"fortunes\") para instalar o pacote no seu computador. Execute o código fortunes::fortune(10) no prompt para confirmar a instalação. Toda vez que se deparar com essa mensagem de erro, deves instalar o pacote que está faltando.\nOutra maneira de carregar um pacote é através da função require. Essa tem um comportamento diferente da função library e deve ser utilizada dentro da definição de funções ou no teste do carregamento do pacote. Caso o usuário crie uma função customizada que necessite de procedimentos de um pacote em particular, o mesmo deve carregar o pacote no escopo da função. Por exemplo, veja o código a seguir, em que criamos uma função dependente do pacote quantmod:\n\nmy_fct &lt;- function(x){\n  require(quantmod)\n\n  df &lt;- getSymbols(x, auto.assign = F)\n  return(df)\n}\n\nNesse caso, a função getSymbols faz parte do pacote quantmod. Não se preocupe agora com a estrutura utilizada para criar uma função no R. Essa será explicada em capítulo futuro.\n\n\n\n\n\n\nCuidado!\n\n\n\nUma precaucão que deve sempre ser tomada quando se carrega um pacote é um possível conflito de funções. Por exemplo, existe uma função chamada filter no pacote {dplyr} (Wickham et al. 2023) e também no pacote stats. Caso carregarmos ambos pacotes e chamarmos a função filter no escopo do código, qual delas o R irá usar? Pois bem, a preferência é sempre para o último pacote carregado. Esse é um tipo de problema que pode gerar muita confusão. Felizmente, note que o próprio R acusa um conflito de nome de funções no carregamento do pacote. Para testar, inicie uma nova sessão do R e carregue o pacote {dplyr} (Wickham et al. 2023). Verás que uma mensagem indica haver dois conflitos com o pacote stats e quatro com pacote o {base} (R Core Team 2023)."
  },
  {
    "objectID": "04-pacotes.html#atualizando-pacotes",
    "href": "04-pacotes.html#atualizando-pacotes",
    "title": "4  Pacotes do R",
    "section": "4.4 Atualizando Pacotes",
    "text": "4.4 Atualizando Pacotes\nAo longo do tempo, é natural que os pacotes disponibilizados no CRAN sejam atualizados para acomodar novas funcionalidades ou se adaptar a mudanças em suas dependências. Assim, é recomendável que os usuários atualizem os seus pacotes instalados para uma nova versão através da internet. Esse procedimento é bastante fácil. Uma maneira direta de atualizar pacotes é clicar no botão update no painel de pacotes no canto direito inferior do RStudio, conforme mostrado na figura @ref(fig:RStudio-update).\n\n\n\n\n\nAtualizando pacotes no R\n\n\n\n\nA atualização de pacotes através do prompt também é possível. Para isso, basta utilizar o comando update.packages, conforme mostrado a seguir. \n\nupdate.packages()\n\nO comando update.packages() compara a versão dos pacotes instalados em relação a versão disponível no CRAN. Caso tiver alguma diferença, a nova versão é instalada. Após a execução do comando, todos os pacotes estarão atualizados com a versão disponível nos servidores do CRAN.\n\n\n\n\n\n\nImportante\n\n\n\nVersionamento de pacotes é extremamente importante para manter a reproducibilidade do código. Apesar de ser raro de acontecer, é possível que a atualização de um pacote no R modifique, para os mesmos dados, resultados já obtidos anteriormente. Tenho uma experiência particularmente memorável quando um artigo científico retornou da revisão e, devido a atualização de um dos pacotes, não consegui reproduzir os resultados apresentados no artigo. No final deu tudo certo, mas o trauma fica.\nUma solução para este problema é congelar as versões dos pacotes para cada projeto usando a ferramenta packrat do RStudio. Em resumo, o packrat faz cópias locais dos pacotes utilizados no projeto, os quais têm preferência aos pacotes do sistema. Assim, se um pacote for atualizado no sistema, mas não no projeto, o código R vai continuar usando a versão mais antiga e seu código sempre rodará nas mesmas condições.\n\n\n\n\n\n\nR Core Team. 2023. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/.\n\n\nWickham, Hadley. 2023. Tidyverse: Easily Install and Load the Tidyverse. https://tidyverse.tidyverse.org.\n\n\nWickham, Hadley, Romain François, Lionel Henry, Kirill Müller, and Davis Vaughan. 2023. Dplyr: A Grammar of Data Manipulation. https://dplyr.tidyverse.org.\n\n\nWickham, Hadley, Jim Hester, and Jennifer Bryan. 2023. Readr: Read Rectangular Text Data. https://readr.tidyverse.org."
  },
  {
    "objectID": "05-interagindo-computador-internet.html#mostrando-e-mudando-o-diretório-de-trabalho",
    "href": "05-interagindo-computador-internet.html#mostrando-e-mudando-o-diretório-de-trabalho",
    "title": "5  Interagindo com o Sistema Operacional e a Internet",
    "section": "5.1 Mostrando e Mudando o Diretório de Trabalho",
    "text": "5.1 Mostrando e Mudando o Diretório de Trabalho\nAssim como outros softwares, o R sempre trabalha em algum diretório. É com base nesse diretório que o R procura arquivos para importar dados. É nesse mesmo diretório que o R salva arquivos, caso não definirmos um endereço no computador explicitamente. Essa saída pode ser um arquivo de uma figura, um arquivo de texto ou uma planilha eletrônica.\n\n\n\n\n\n\nImportante\n\n\n\nComo boa prática de criação e organização de scripts, deve-se sempre mudar o diretório de trabalho para onde o arquivo do script está localizado. Isso facilita a importação e exportação de dados de arquivos.\n\n\n\n\n\n\n\n\nImportante\n\n\n\nUma forma simples e direta de mudar o diretório de trabalho é utilizar o sistema de projetos do RStudio. Toda vez que um projeto é aberto, a sessão do R automaticamente será direcionado ao diretório do projeto.\n\n\nEm sua inicialização, o R possui como diretório default a pasta de documentos do usuário cujo atalho é o tilda ('~').\nPara mostrar o diretório atual de trabalho, basta utilizar a função getwd() :\n\n# get current directory\nmy_dir &lt;- getwd()\n\n# print it\nprint(my_dir)\n\nR&gt; [1] \"/tmp/RtmpoywnSz/book-compile__470f130a44e0\"\n\n\nO resultado do código anterior mostra a pasta onde este livro foi escrito. Esse é o diretório onde os arquivos do livro foram compilados dentro do ambiente Linux.\nA mudança de diretório de trabalho é realizada através do comando setwd() . Por exemplo, caso quiséssemos mudar o nosso diretório de trabalho para C:/Minha pesquisa/, basta digitar no prompt:\n\n# set dir\nmy_d &lt;- 'C:/Minha Pesquisa/'\nsetwd(my_d)\n\nEnquanto para casos simples, como o anterior, lembrar o nome do diretório é fácil, em casos práticos o diretório de trabalho pode ser em um lugar mais profundo da raiz de diretórios do sistema de arquivos. Nessa situação, uma estratégia eficiente para descobrir a pasta de trabalho é utilizar um explorador de arquivos, tal como o Explorer no Windows. Abra esse aplicativo e vá até o local onde quer trabalhar com o seu script. Após isso, coloque o cursor na barra de endereço e selecione todo o endereço. Aperte control+c para copiar o endereço para a área de transferência. Volte para o seu código e cole o mesmo no código. Atenção nesta etapa, o Windows utiliza a barra invertida para definir endereços no computador, enquanto o R utiliza a barra normal. Caso tente utilizar a barra invertida, um erro será mostrado na tela. Veja o exemplo a seguir.\n\nmy_d &lt;- 'C:\\Minha pesquisa\\'\nsetwd(my_d)\n\nO erro terá a seguinte mensagem:\nError: '\\M' is an unrecognized escape in character string...\"\nA justificativa para o erro é que a barra invertida \\ é um caractere reservado no R e não pode ser utilizado isoladamente. Caso precises, podes definí-lo no objeto de texto com dupla barra, tal como em \\\\. Veja no exemplo a seguir, onde a dupla barra é substituída por uma barra única:\n\n# set char with \\\nmy_char &lt;- 'using \\\\'\n\n# print it\nmessage(my_char)\n\nR&gt; using \\\n\n\nA solução do problema é simples. Após copiar o endereço, modifique todas as barras para a barra normal, assim como no código a seguir:\n\nmy_d &lt;- 'C:/Minha pesquisa/'\nsetwd(my_d)\n\nÉ possível também utilizar barras invertidas duplas \\\\ na definição de diretórios, porém não se recomenda essa formatação, pois não é compatível com outros sistemas operacionais.\nOutro ponto importante aqui é o uso de endereços relativos. Por exemplo, caso esteja trabalhando em um diretório que contém um subdiretório chamado Data, podes entrar nele com o seguinte código:\n\n# change to subfolder\nsetwd('Data')\n\nOutra possibilidade pouco conhecida no uso de setwd() é que é possível entrar em níveis inferiores do sistema de diretórios com .., tal como em:\n\n# change to previous level\nsetwd('..')\n\nPortanto, caso estejas trabalhando no diretório C:/My Research/ e executar o comando setwd('..'), o diretório atual de trabalho viraria C:/, um nível inferior a C:/My Research/.\nUma maneira mais moderna e pouco conhecida de definir o diretório de trabalho é usar as funções internas do RStudio. Este é um conjunto de funções que só funcionam dentro do RStudio e fornecem diversas informações sobre o arquivo sendo editado. Para descobrir o caminho do arquivo atual que está sendo editado no RStudio e configurar o diretório de trabalho para lá, você pode escrever:\n\nmy_path &lt;- dirname(rstudioapi::getActiveDocumentContext()$path)\nsetwd(my_path)\n\nDessa forma, o script mudará o diretório para sua própria localização. Apesar de não ser um código exatamente elegante, ele é bastante funcional. Caso copie o arquivo para outro diretório, o valor de my_path muda para o novo diretório. Esteja ciente, no entanto, de que esse truque só funciona no editor de rotinas do RStudio e dentro de um arquivo salvo. O código não funcionará a partir do prompt.\n\n\n\n\n\n\nImportante\n\n\n\nOutro truque bastante útil para definir diretórios de trabalho no R é usar o símbolo ~. Esse define a pasta 'Documentos' no Windows, a qual é única para cada usuário. Portanto, ao executar setwd('~'), irás direcionar o R a uma pasta de fácil acesso e livre modificação pelo usuário atual do computador.\n\n\n\n5.1.1 Listando Arquivos e Pastas\nPara listar arquivos do computador, basta utilizar o função list.files() ou então a alternativa do fs::dir_ls() . O primeiro argumento define o diretório para listar os arquivos. Na construção deste livro foi criado um diretório chamado resources/figs, onde as figuras utilizadas no livro estão salvas são salvos. Pode-se verificar os arquivos nessa pasta com o seguinte código:\n\nmy_f &lt;- fs::dir_ls(path = \"resources/figs\")\nprint(my_f[1:5])\n\nR&gt; resources/figs/CAPADigital_DadosFinanceirosR_20180510.jpg\nR&gt; resources/figs/Command_view.png\nR&gt; resources/figs/ExemploAjuda.png\nR&gt; resources/figs/Exemplo_inline_code.png\nR&gt; resources/figs/Favicon\n\n\nObserve que nesse diretório encontram-se vários arquivos com extensão .png. Destaca-se que também é possível listar os arquivos de forma recursiva, isto é, listar os arquivos de subpastas do endereço original. Para verificar, tente utilizar o seguinte código no seu computador:\n\n# list all files recursively\nfs::dir_ls(path = getwd(),  \n           recurse = TRUE)\n\nO comando anterior irá listar todos os arquivos existentes na pasta atual e subpastas de trabalho. Dependendo de onde o comando foi executado, pode levar um certo tempo para o término do processo. Caso precisar cancelar a execução, aperte esc no teclado.\nPara listar pastas (diretórios) do computador, basta utilizar o comando list.dirs() ou então a função fs::dir_ls() com argumento type = \"directory\". Veja a seguir.\n\n# list directories\nmy_dirs &lt;- fs::dir_ls(\".\", type = \"directory\")\nprint(my_dirs)\n\nR&gt; EOCE-Rmd  _book     backup    resources site_libs\n\n\nNo caso anterior, o comando lista todos os diretórios do trabalho atual sem recursividade. A saída do comando mostra os diretórios que utilizei para escrever este livro. Isso inclui o diretório de saída do livro (./_book), entre diversos outros. Nesse mesmo diretório, encontram-se os capítulos do livro, organizados por arquivos e baseados na linguagem Quarto. Para listar somente os arquivos com extensão .qmd, utiliza-se o argumento glob = \".qmd\" da função fs::dir_ls() , como a seguir:\n\nqmd_files &lt;- fs::dir_ls(\".\", glob = \"*.qmd$\")\n\nprint(qmd_files)\n\nR&gt; 00a-prefacio.qmd\nR&gt; 00b-agradecimentos.qmd\nR&gt; 01-introdução.qmd\nR&gt; 02-como-o-r-funciona.qmd\nR&gt; 03-rstudio.qmd\nR&gt; 04-pacotes.qmd\nR&gt; 05-interagindo-computador-internet.qmd\nR&gt; 06-importacao-exportacao-dados-locais.qmd\nR&gt; 07-importacao-internet.qmd\nR&gt; 08-objetos-armazenamento.qmd\nR&gt; 09-objetos-basicos.qmd\nR&gt; 10-intro-programacao.qmd\nR&gt; 99-references.qmd\nR&gt; _BemVindo.qmd\nR&gt; index.qmd\n\n\nO texto *.qmd$ orienta o R a procurar todos arquivos que terminam o seu nome com o texto .Rmd. Os símbolos '*'' e '$' são operadores específicos para o encontro de padrões em texto em uma linguagem chamada regex (regular expressions) e, nesse caso, indicam que o usuário quer encontrar todos arquivos com extensão .qmd. O símbolo ’*’ diz para ignorar qualquer texto anterior a ‘.qmd’ e ‘$’ indica o fim do nome do arquivo. Os arquivos apresentados anteriormente contêm todo o conteúdo deste livro, incluindo este próprio parágrafo!\n\n\n5.1.2 Apagando Arquivos e Diretórios\nA remoção de arquivos é realizada através do comando file.remove() ou então fs::file_delete() :\n\n# create temporary file in docs folder\nmy_file &lt;- '~/MyTemp.csv'\nwrite.csv(x = data.frame(x=1:10),\n          file = my_file)\n\n# delete it\nfs::file_delete(my_file)\n\nLembre-se que deves ter permissão do seu sistema operacional para apagar um arquivo. Para o nosso caso, o retorno TRUE mostra que a operação teve sucesso.\nPara deletar diretórios e todos os seus elementos, utilizamos unlink() ou então fs::dir_delete() :\n\n# create temp dir\nname_temp &lt;- \"TEMP\"\nfs::dir_create(name_temp)\n\n# fill it with file\nmy_file &lt;- fs::path(name_temp, \"tempfile.csv\")\nwrite.csv(x = data.frame(x=1:10),\n          file = my_file)\n\nfs::dir_delete(name_temp)\n\nA função, neste caso, não retorna nada. Podes checar se o diretório existe com fs::dir_exists() :\n\nfs::dir_exists(name_temp)\n\nR&gt;  TEMP \nR&gt; FALSE\n\n\n\n\n\n\n\n\nCuidado\n\n\n\nTenha muito cuidado com comandos de remover pastas e arquivos no R, principalmente quando utilizar recursividade, isto é, quanto apagar todas as pastas e arquivos existentes no caminho inputado. Uma execução errada e partes importantes do seu disco rídigo podem ser apagadas, deixando o seu computador inoperável. Saiba que o R realmente apaga os arquivos e não somente manda para a lixeira. Portanto, ao apagar diretórios inteiros, não poderás recuperar os arquivos facilmente.\n\n\n\n\n5.1.3 Utilizando Arquivos e Diretórios Temporários\nToda vez que uma nova sessão do R é inicializada, o programa automaticamente cria uma pasta temporária no seu sistema. É nesse diretório que o R guarda quaisquer arquivos e pastas descartáveis que possam ser necessárias na sua sessão. No momento que a sessão do R é finalizada, tal como quando fechamos o RStudio, as pastas temporárias são removidas.\nO endereço do diretório temporário de uma sessão do R é verificado com tempdir() ou fs::path_temp() :\n\nmy_tempdir &lt;- fs::path_temp()\nmessage(stringr::str_glue('My tempdir is {my_tempdir}'))\n\nR&gt; My tempdir is /tmp/Rtmp3BCpGP\n\n\nO último texto do diretório, neste caso Rtmp3BCpGP é aleatóriamente definido e irá trocar a cada nova sessão do R.\nA mesma dinâmica é encontrada para nomes de arquivos. Caso queira, por algum motivo, utilizar um nome temporário e aleatório para algum arquivo com extensão .txt, utilize tempfile() ou fs::file_temp() e defina o tipo de arquivo com as entradas da função:\n\nmy_tempfile &lt;- fs::file_temp(ext = '.txt')\nmessage(my_tempfile)\n\nR&gt; /tmp/Rtmp3BCpGP/file499a77e0d8c1.txt\n\n\nNote que o nome do arquivo – file499a77e0d8c1.txt – é totalmente aleatório e mudará a cada chamada da função.\n\n\n5.1.4 Baixando Arquivos da Internet\nO R pode baixar arquivos da Internet diretamente no código. Isso é realizado com a função download.file() . Veja o exemplo a seguir, onde baixamos uma planilha de Excel do site da Microsoft para um arquivo temporário:\n\n# set link\nlink_dl &lt;- 'go.microsoft.com/fwlink/?LinkID=521962'\nlocal_file &lt;- fs::file_temp(ext = '.xlsx') # name of local file\n\ndownload.file(url = link_dl,\n              destfile = local_file)\n\nO uso de download.file() é bastante prático quando se está trabalhando com dados da Internet que são constantemente atualizados. Basta baixar e atualizar o arquivo com dados no início do script. Poderíamos continuar a rotina lendo o arquivo baixado e realizando a nossa análise dos dados disponíveis.\nUm exemplo nesse caso é a tabela de empresas listadas na bolsa divulgada pela CVM (comissão de valores mobiliários). A tabela está disponível em um arquivo no site. Podemos baixar o arquivo e, logo em seguida, ler os dados.\n\n# set destination link and file\nmy_link &lt;- 'http://dados.cvm.gov.br/dados/CIA_ABERTA/CAD/DADOS/cad_cia_aberta.csv'\nmy_destfile &lt;- fs::file_temp(ext = '.csv')\n\n# download file\ndownload.file(my_link, \n              destfile = my_destfile, \n              mode = \"wb\")\n\n# read it\ndf_cvm &lt;- readr::read_csv2(my_destfile,\n                     #delim = '\\t',\n                     locale = locale(encoding = 'Latin1'),\n                     col_types = cols())\n\nR&gt; ℹ Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n\n# check available columns\nprint(names(df_cvm))\n\nR&gt;  [1] \"CNPJ_CIA\"           \"DENOM_SOCIAL\"      \nR&gt;  [3] \"DENOM_COMERC\"       \"DT_REG\"            \nR&gt;  [5] \"DT_CONST\"           \"DT_CANCEL\"         \nR&gt;  [7] \"MOTIVO_CANCEL\"      \"SIT\"               \nR&gt;  [9] \"DT_INI_SIT\"         \"CD_CVM\"            \nR&gt; [11] \"SETOR_ATIV\"         \"TP_MERC\"           \nR&gt; [13] \"CATEG_REG\"          \"DT_INI_CATEG\"      \nR&gt; [15] \"SIT_EMISSOR\"        \"DT_INI_SIT_EMISSOR\"\nR&gt; [17] \"CONTROLE_ACIONARIO\" \"TP_ENDER\"          \nR&gt; [19] \"LOGRADOURO\"         \"COMPL\"             \nR&gt; [21] \"BAIRRO\"             \"MUN\"               \nR&gt; [23] \"UF\"                 \"PAIS\"              \nR&gt; [25] \"CEP\"                \"DDD_TEL\"           \nR&gt; [27] \"TEL\"                \"DDD_FAX\"           \nR&gt; [29] \"FAX\"                \"EMAIL\"             \nR&gt; [31] \"TP_RESP\"            \"RESP\"              \nR&gt; [33] \"DT_INI_RESP\"        \"LOGRADOURO_RESP\"   \nR&gt; [35] \"COMPL_RESP\"         \"BAIRRO_RESP\"       \nR&gt; [37] \"MUN_RESP\"           \"UF_RESP\"           \nR&gt; [39] \"PAIS_RESP\"          \"CEP_RESP\"          \nR&gt; [41] \"DDD_TEL_RESP\"       \"TEL_RESP\"          \nR&gt; [43] \"DDD_FAX_RESP\"       \"FAX_RESP\"          \nR&gt; [45] \"EMAIL_RESP\"         \"CNPJ_AUDITOR\"      \nR&gt; [47] \"AUDITOR\"\n\n\nExistem diversas informações interessantes nestes dados incluindo nome e CNPJ de empresas listadas (ou deslistadas) da bolsa de valores Brasileira. E, mais importante, o arquivo está sempre atualizado. O código anterior estará sempre buscando os dados mais recentes a cada execução."
  },
  {
    "objectID": "06-importacao-exportacao-dados-locais.html#pacote-intror",
    "href": "06-importacao-exportacao-dados-locais.html#pacote-intror",
    "title": "6  Importação e Exportação de Dados Locais",
    "section": "6.1 Pacote introR",
    "text": "6.1 Pacote introR\nNas seções futuras iremos utilizar o pacote do livro – introR – para carregar diversos exemplos de arquivos. Se você seguiu as instruções da seção Material Suplementar localizada no prefácio do livro, já deves ter o pacote instalado. Caso contrário, execute o seguinte código:\n\n# install devtools (if not installed)\nif (!require(devtools)) install.packages ('devtools')\n\n# install book package\ndevtools::install_github ('msperlin/introR')\n\nUma vez que você instalou o pacote introR, todos os arquivos de dados usados no livro foram baixados. Podemos verificar os cinco primeiros arquivos disponíveis com o comando introR::data_list() :\n\n# list available data files\nprint(introR::data_list())\n\nR&gt; \n\n\nR&gt; ── Available data files at '/home/msperlin/R/x86_64-pc-linux\n\n\nR&gt; ℹ CH04_another-funky-csv-file.csv\n\n\nR&gt; ℹ CH04_example-fst.fst\n\n\nR&gt; ℹ CH04_example-Rdata.RData\n\n\nR&gt; ℹ CH04_example-rds.rds\n\n\nR&gt; ℹ CH04_example-sqlite.SQLite\n\n\nR&gt; ℹ CH04_example-tsv.tsv\n\n\nR&gt; ℹ CH04_funky-csv-file.csv\n\n\nR&gt; ℹ CH04_ibovespa-Excel.xlsx\n\n\nR&gt; ℹ CH04_ibovespa.csv\n\n\nR&gt; ℹ CH04_price-and-prejudice.txt\n\n\nR&gt; ℹ CH04_SP500-Excel.xlsx\n\n\nR&gt; ℹ CH04_SP500.csv\n\n\nR&gt; ℹ CH07_FileWithLatinChar_Latin1.txt\n\n\nR&gt; ℹ CH07_FileWithLatinChar_UTF-8.txt\n\n\nR&gt; ℹ CH08_some-stocks-SP500.csv\n\n\nR&gt; ℹ CH08_wide-example-stocks.csv\n\n\nR&gt; ℹ CH10_sp500-stocks-long-by-year.csv\n\n\nR&gt; ℹ CH11_grunfeld.csv\n\n\nR&gt; ℹ CH11_SP500.csv\n\n\nR&gt; ℹ CH11_UCI-Credit-Card.csv\n\n\nR&gt; ℹ EX_B3-stocks.rds\n\n\nR&gt; ℹ EX_football-br.csv\n\n\nR&gt; ℹ EX_Ibov_PETR4.csv\n\n\nR&gt; ℹ EX_ibovespa.rds\n\n\nR&gt; ℹ EX_SP500-stocks-wide.csv\n\n\nR&gt; ℹ EX_SP500-stocks-yearly.rds\n\n\nR&gt; ℹ EX_SP500-stocks.rds\n\n\nR&gt; ℹ EX_TD-data.rds\n\n\nR&gt; ℹ EX_TweetsElonMusk.csv\n\n\nR&gt; \n\n\nR&gt; ✔ You can get the local path of file using introR::data_path(name_of_file)\n\n\nR&gt; ✔ Example: local_path &lt;- introR::data_path('CH08_some-stocks-SP500.csv')\n\n\nR&gt;  [1] \"CH04_another-funky-csv-file.csv\"   \nR&gt;  [2] \"CH04_example-fst.fst\"              \nR&gt;  [3] \"CH04_example-Rdata.RData\"          \nR&gt;  [4] \"CH04_example-rds.rds\"              \nR&gt;  [5] \"CH04_example-sqlite.SQLite\"        \nR&gt;  [6] \"CH04_example-tsv.tsv\"              \nR&gt;  [7] \"CH04_funky-csv-file.csv\"           \nR&gt;  [8] \"CH04_ibovespa-Excel.xlsx\"          \nR&gt;  [9] \"CH04_ibovespa.csv\"                 \nR&gt; [10] \"CH04_price-and-prejudice.txt\"      \nR&gt; [11] \"CH04_SP500-Excel.xlsx\"             \nR&gt; [12] \"CH04_SP500.csv\"                    \nR&gt; [13] \"CH07_FileWithLatinChar_Latin1.txt\" \nR&gt; [14] \"CH07_FileWithLatinChar_UTF-8.txt\"  \nR&gt; [15] \"CH08_some-stocks-SP500.csv\"        \nR&gt; [16] \"CH08_wide-example-stocks.csv\"      \nR&gt; [17] \"CH10_sp500-stocks-long-by-year.csv\"\nR&gt; [18] \"CH11_grunfeld.csv\"                 \nR&gt; [19] \"CH11_SP500.csv\"                    \nR&gt; [20] \"CH11_UCI-Credit-Card.csv\"          \nR&gt; [21] \"EX_B3-stocks.rds\"                  \nR&gt; [22] \"EX_football-br.csv\"                \nR&gt; [23] \"EX_Ibov_PETR4.csv\"                 \nR&gt; [24] \"EX_ibovespa.rds\"                   \nR&gt; [25] \"EX_SP500-stocks-wide.csv\"          \nR&gt; [26] \"EX_SP500-stocks-yearly.rds\"        \nR&gt; [27] \"EX_SP500-stocks.rds\"               \nR&gt; [28] \"EX_TD-data.rds\"                    \nR&gt; [29] \"EX_TweetsElonMusk.csv\"\n\n\nOs arquivos anteriores estão salvos na pasta de instalação dos pacote introR. Para ter o caminho completo, basta usar função introR::data_path() tendo o nome do arquivo como entrada:\n\n# get location of file\nmy_f &lt;- introR::data_path('CH11_grunfeld.csv')\n\n# print it\nprint(my_f)\n\nA partir de agora iremos usar a função introR::data_path para obter o caminho dos arquivos utilizados nos exemplos. Note que, desde que tenha o pacote introR instalado, podes facilmente reproduzir todos os exemplos do livro no seu computador."
  },
  {
    "objectID": "06-importacao-exportacao-dados-locais.html#arquivos-csv",
    "href": "06-importacao-exportacao-dados-locais.html#arquivos-csv",
    "title": "6  Importação e Exportação de Dados Locais",
    "section": "6.2 Arquivos csv",
    "text": "6.2 Arquivos csv\nConsidere o arquivo de dados no formato csv chamado 'CH04_ibovespa.csv', pertencente ao repositório do livro. Vamos copiar o mesmo para a pasta “Meus Documentos” com o uso do tilda (~):\n\n# get location of file\nmy_f &lt;- introR::data_path('CH04_ibovespa.csv')\n\n# copy to ~\nfile.copy(from = my_f, \n          to = '~' )\n\nR&gt; [1] TRUE\n\n\n\n\nR&gt; [1] TRUE\n\n\nCaso seja a primeira vez trabalhando com arquivos do tipo .csv, sugiro usar o explorador de arquivos do Windows e abrir CH04_ibovespa.csv com qualquer editor de texto instalado, tal como o Notepad (veja Figure 6.1. Observe que as primeiras linhas do arquivo definem os nomes das colunas: “ref_date” e “price_close”. Conforme notação internacional, as linhas são definidas pela quebra do texto e as colunas pelo uso da vírgula (,).\n\n\n\n\n\nFigure 6.1: Exemplo de arquivo .csv no Notepad\n\n\n\n\n\n\n\n\n\n\nO Formato Brasileiro\n\n\n\nQuando trabalhando com dados brasileiros, a notação internacional pode gerar uma confusão desnecessária. Dados locais tendem a usar a vírgula para indicar valores decimais em números, assim como também datas no formato dia/mês/ano. Abaixo apresenta-se algumas regras de formatação de números e códigos para o caso brasileiro.\nDecimal: O decimal no R é definido pelo ponto (.), tal como em 2.5 e não vírgula, como em 2,5. Esse é o padrão internacional, e a diferença para a notação brasileira gera muita confusão. Em nenhuma situação deve-se utilizar a vírgula como separador de casas decimais. Mesmo quando estiver exportando dados, sempre dê prioridade para o formato internacional.\nCaracteres latinos: Devido ao seu padrão internacional, o R apresenta problemas para entender caracteres latinos, tal como cedilha e acentos. Caso possa evitar, não utilize esses tipos de caracteres no código para nomeação de variáveis ou arquivos. Nos objetos de classe texto (character), é possível utilizá-los desde que a codificação do objeto esteja correta (UTF-8 ou Latin1). Assim, recomenda-se que o código do R seja escrito na língua inglesa.\nFormato das datas: Datas no R são formatadas de acordo com a norma ISO 8601, seguindo o padrão YYYY-MM-DD, onde YYYY é o ano em quatro números, MM é o mês e DD é o dia. Por exemplo, uma data em ISO 8601 é 2024-01-10. No Brasil, as datas são formatadas como DD/MM/YYYY. Reforçando a regra, sempre dê preferência ao padrão internacional. Vale salientar que a conversão entre um formato e outro é bastante fácil e será apresentada em capítulo futuro.\n\n\nO conteúdo de CH04_ibovespa.csv é bastante conservador e não será difícil importar o seu conteúdo. Porém, saiba que muitas vezes o arquivo .csv vem com informações extras de cabeçalho – o chamado metadata – ou diferentes formatações que exigem adaptações. Como sugestão para evitar problemas, antes de prosseguir para a importação de dados em um arquivo .csv, abra o arquivo em um editor de texto qualquer e siga os seguintes passos:\n\nVerifique a existência de texto antes dos dados e a necessidade de ignorar algumas linhas iniciais. A maioria dos arquivos .csv não contém cabeçalho, porém deves sempre checar. No R, a função de leitura de arquivos .csv possui uma opção para ignorar um definido número de linhas antes de começar a leitura do arquivo;\nVerifique a existência ou não dos nomes das colunas na primeira linha com os dados. Em caso negativo, verifique com o autor qual o nome (e significado) das colunas;\nVerifique qual o símbolo de separador de colunas. Comumente, seguindo notação internacional, será a vírgula, porém nunca se tem certeza sem checar;\nPara dados numéricos, verifique o símbolo de decimal, o qual deve ser o ponto (.) tal como em 2.5. Caso necessário, podes ajustar o símbolo na própria função de leitura;\nVerifique a codificação do arquivo de texto. Normalmente é UTF-8, Latin1 (ISO-8859) ou windows1252. Esses são formatos amplos e devem ser suficientes para a maioria dos idiomas. Sempre que você encontrar símbolos estranhos nas colunas de texto do dataframe resultante, o problema é devido a uma diferença na codificação entre o arquivo e o R. Os usuários do Windows podem verificar a codificação de um arquivo de texto abrindo-o no software Notepad++. As informações sobre a codificação estarão disponíveis no canto inferior direito do editor. No entanto, você precisa estar ciente de que o Notepad++ não faz parte da instalação do Windows e pode ser necessário instalá-lo em seu computador. Os usuários de Linux e Mac podem encontrar as mesmas informações em qualquer software editor de texto avançado, como o Kate.\n\n\n\n\n\n\n\nImportante\n\n\n\nSempre que você encontrar uma estrutura de texto inesperada em um arquivo .csv, use os argumentos da função de leitura csv para importar as informações corretamente. Repetindo, nunca modifique dados brutos manualmente. É muito mais eficiente usar o código R para lidar com diferentes estruturas de arquivos em .csv. Pode parecer mais trabalhoso, mas essa política vai economizar muito tempo no futuro, pois, em algumas semanas, você provavelmente esquecerá como limpou manualmente aquele arquivo .csv utilizado em pesquisa passada. Com o uso de código para a adaptação da importação de dados, sempre que você precisar atualizar o arquivo de dados, o código irá resolver todos os problemas, automatizando o processo.\n\n\n\n6.2.1 Importação de Dados\nO R possui uma função nativa chamada read.csv() para importar dados de arquivos .csv. Porém, esse é um dos muitos casos em que a alternativa do {tidyverse} (Wickham 2023) – readr::read_csv() – é mais eficiente e mais fácil de trabalhar. Resumindo, readr::read_csv() lê arquivos mais rapidamente que read.csv() , além de usar regras mais inteligentes para definir as classes das colunas importadas.\nEste é a primeira vez que usamos um pacote do {tidyverse} (Wickham 2023), neste caso o {readr} (Wickham, Hester, and Bryan 2023). Antes de fazer isso, é necessário instalá-lo em sua sessão R. Uma maneira simples de instalar todos os pacotes pertencentes ao {tidyverse} (Wickham 2023) é instalar o módulo de mesmo nome:\n\ninstall.packages('tidyverse')\n\nApós executar o código anterior, todos os pacotes {tidyverse} (Wickham 2023) serão instalados em seu computador. Você também deve ter em mente que alguns aspectos dessa instalação podem demorar um pouco. Assim que terminar, carregue o conjunto de pacotes {tidyverse} (Wickham 2023).\n\n# load library\nlibrary(tidyverse)\n\nDe volta à importação de dados de arquivos .csv, use a função readr::read_csv() para carregar o conteúdo do arquivo CH04_ibovespa.csv no R:\n\n# set file to read\nmy_f &lt;- introR::data_path('CH04_ibovespa.csv')\n\n# read data\nmy_df_ibov &lt;- read_csv(my_f)\n\nO conteúdo do arquivo importado é convertido para um objeto do tipo dataframe no R. Conforme mencionado no capítulo anterior, cada coluna de um dataframe tem uma classe. Podemos verificar as classes de my_df_ibov usando a função dplyr::glimpse() do pacote {dplyr} (Wickham et al. 2023), que também faz parte do {tidyverse} (Wickham 2023):\n\n# check content\nglimpse(my_df_ibov)\n\nR&gt; Rows: 3,215\nR&gt; Columns: 2\nR&gt; $ ref_date    &lt;date&gt; 2010-01-04, 2010-01-05, 2010-01-06, 2…\nR&gt; $ price_close &lt;dbl&gt; 70045, 70240, 70729, 70451, 70263, 704…\n\n\nObserve que a coluna de datas (ref_date) foi importada como um vetor Date e os preços de fechamento como numéricos (dbl, precisão dupla). Isso é exatamente o que esperávamos. Internamente, a função readr::read_csv() identifica as classes das colunas de acordo com seu conteúdo.\nObserve também como o código anterior apresentou a mensagem “Parsed with column specification: …”. Essa mensagem mostra como a função identifica as classes das colunas lendo as primeiras 1000 linhas do arquivo. Regras inteligentes tentam prever a classe com base no conteúdo importado. Podemos usar essas informações em nosso próprio código copiando o texto e atribuindo-o a uma variável:\n\n# set cols from readr import message\nmy_cols &lt;- cols(\n  price_close = col_double(),\n  ref_date = col_date(format = \"\")\n)\n\n# read file with readr::read_csv\nmy_df_ibov &lt;- read_csv(my_f,\n                       col_types = my_cols)\n\nComo um exercício, vamos importar os mesmos dados, porém usando a classe character (texto) para colunas ref_date:\n\n# set cols from readr import message\nmy_cols &lt;- cols(\n  price_close = col_double(),\n  ref_date = col_character()\n)\n\n# read file with readr::read_csv\nmy_df_ibov &lt;- read_csv(my_f,\n                       col_types = my_cols)\n\n# check content\nglimpse(my_df_ibov)\n\nR&gt; Rows: 3,215\nR&gt; Columns: 2\nR&gt; $ ref_date    &lt;chr&gt; \"2010-01-04\", \"2010-01-05\", \"2010-01-0…\nR&gt; $ price_close &lt;dbl&gt; 70045, 70240, 70729, 70451, 70263, 704…\n\n\nComo esperado, a coluna de datas – ref_date – agora foi importada como texto. Assim, o uso de readr::read_csv() pode ser resumido em duas etapas: 1) leia o arquivo sem argumentos em readr::read_csv() ; 2) copie o texto das classes de coluna padrão da mensagem de saída e adicione como entrada col_types. O conjunto de passos anterior é suficiente para a grande maioria dos casos. O uso da mensagem com as classes das colunas é particularmente útil quando o arquivo importado tem várias colunas e a definição manual de cada classe exige muita digitação.\nUma alternativa mais prática no uso do readr::read_csv() é confiar na heurística da função e usar a definição padrão das colunas automaticamente. Para isto, basta definir a entrada col_types como cols(). Veja a seguir:\n\n# read file with readr::read_csv\nmy_df_ibov &lt;- read_csv(my_f,\n                       col_types = cols())\n\nAgora, vamos estudar um caso mais anormal de arquivo .csv. No pacote do livro temos um arquivo chamado CH04_funky-csv-file.csv onde:\n\no cabeçalho possui texto com informações dos dados;\no arquivo usará a vírgula como decimal;\no texto do arquivo conterá caracteres latinos.\n\nAs primeiras 10 linhas dos arquivos contém o seguinte conteúdo:\n\n\nR&gt; Example of funky file:\nR&gt; - columns separated by \";\"\nR&gt; - decimal points as \",\"\nR&gt; \nR&gt; Data build in 2022-12-28\nR&gt; Origin: www.funkysite.com.br\nR&gt; \nR&gt; ID;Race;Age;Sex;Hour;IQ;Height;Died\nR&gt; 001;White;80;Male;00:00:00;92;68;FALSE\nR&gt; 002;Hispanic;25;Female;00:00:00;99;68;TRUE\n\n\nNote a existência do cabeçalho até linha de número 7 e as colunas sendo separadas pela semi-vírgula (“;”).\nAo importar os dados com opções padrões (e erradas), teremos o resultado a seguir:\n\ndf_funky &lt;- readr::read_csv(my_f, \n                     col_types = readr::cols())\n\ndplyr::glimpse(df_funky)\n\nR&gt; Rows: 2\nR&gt; Columns: 1\nR&gt; $ `Example of funky file:` &lt;chr&gt; \"- columns separated by \\…\n\n\nClaramente a importação deu errado, com a emissão de diversas mensagens de warning. Para resolver, utilizamos o seguinte código, estruturando todas as particularidades do arquivo:\n\ndf_not_funky &lt;- readr::read_delim(file = my_f, \n                           skip = 7, # how many lines do skip\n                           delim = ';', # column separator\n                           col_types = readr::cols(), # column types\n                           locale = readr::locale(decimal_mark = ',')# locale\n)\n\ndplyr::glimpse(df_not_funky)\n\nR&gt; Rows: 100\nR&gt; Columns: 8\nR&gt; $ ID     &lt;chr&gt; \"001\", \"002\", \"003\", \"004\", \"005\", \"006\", \"…\nR&gt; $ Race   &lt;chr&gt; \"White\", \"Hispanic\", \"Asian\", \"White\", \"Whi…\nR&gt; $ Age    &lt;dbl&gt; 80, 25, 25, 64, 76, 89, 33, 61, 23, 59, 80,…\nR&gt; $ Sex    &lt;chr&gt; \"Male\", \"Female\", \"Male\", \"Male\", \"Female\",…\nR&gt; $ Hour   &lt;time&gt; 00:00:00, 00:00:00, 00:00:00, 00:00:00, 00…\nR&gt; $ IQ     &lt;dbl&gt; 92, 99, 98, 105, 109, 84, 109, 109, 99, 126…\nR&gt; $ Height &lt;dbl&gt; 68, 68, 69, 69, 67, 73, 65, 72, 70, 66, 63,…\nR&gt; $ Died   &lt;lgl&gt; FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, FALSE…\n\n\nVeja que agora os dados foram corretamente importados, com as classes corretas das colunas. Para isso, usamos a função alternativa readr::read_delim. O pacote {readr} (Wickham, Hester, and Bryan 2023) também possui várias outras funções para situações específicas de importação. Caso a função readr::read_csv() não resolva o seu problema na leitura de algum arquivo de dados estruturado em texto, certamente outra função desse pacote resolverá.\n\n\n6.2.2 Exportação de Dados\nPara exportar tabelas em um arquivo .csv, basta utilizar a função readr::write_csv() . No próximo exemplo iremos criar dados artificiais, salvar em um dataframe e exportar para um arquivo .csv temporário. Veja a seguir:\n\nlibrary(readr)\n\n# set number of observations\nN &lt;- 100\n\n# create dataframe with random data\nmy_df &lt;- data.frame(y = runif(N),\n                    z = rep('a', N))\n\n# write to file\nf_out &lt;- tempfile(fileext = '.csv')\nwrite_csv(x = my_df, file = f_out)\n\nNo exemplo anterior, salvamos o dataframe chamado my_df para o arquivo file4a6d2eb4e365.csv, localizado na pasta temporária do computador. Podemos verificar o arquivo importando o seu conteúdo:\n\nmy_df &lt;- read_csv(f_out,\n                  col_types = cols(y = col_double(),\n                                   z = col_character() ) )\nprint(head(my_df))\n\nR&gt; # A tibble: 6 × 2\nR&gt;        y z    \nR&gt;    &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1 0.267  a    \nR&gt; 2 0.0759 a    \nR&gt; 3 0.541  a    \nR&gt; 4 0.910  a    \nR&gt; 5 0.649  a    \nR&gt; 6 0.643  a\n\n\nO resultado está conforme o esperado, um dataframe com duas colunas, a primeira com números e a segunda com texto.\nNote que toda exportação com função readr::write_csv() irá ser formatada, por padrão, com a notação internacional. Caso quiser algo diferentes, verifique as opções disponíveis na função readr::write_delim() , a qual é muito mais flexível."
  },
  {
    "objectID": "06-importacao-exportacao-dados-locais.html#arquivos-excel-xls-e-xlsx",
    "href": "06-importacao-exportacao-dados-locais.html#arquivos-excel-xls-e-xlsx",
    "title": "6  Importação e Exportação de Dados Locais",
    "section": "6.3 Arquivos Excel (xls e xlsx)",
    "text": "6.3 Arquivos Excel (xls e xlsx)\nEm Finanças e Economia, é bastante comum encontrarmos dados salvos em arquivos do tipo Microsoft Excel, com extensão .xls ou .xlsx. Apesar de não ser um formato de armazenamento de dados eficiente, esse é um programa de planilhas bastante popular devido às suas funcionalidades. É muito comum que informações sejam armazenadas e distribuídas dessa forma. Por exemplo, dados históricos do Tesouro Direto são disponibilizados como arquivos .xls no site do tesouro nacional. A CVM (Comissão de Valores Mobiliários) e ANBIMA (Associação Brasileira das Entidades dos Mercados Financeiro e de Capitais) também tem preferência por esse tipo de formato em alguns dados publicados em seu site.\nA desvantagem de usar arquivos do Excel para armazenar dados é sua baixa portabilidade e o maior tempo necessário para leitura e gravação. Isso pode não ser um problema para tabelas pequenas, mas ao lidar com um grande volume de dados, o uso de arquivos Excel é frustrante e não aconselhável. Se possível, evite o uso de arquivos do Excel em seu ciclo de trabalho.\n\n6.3.1 Importação de Dados\nO R não possui uma função nativa para importar dados do Excel e, portanto, deve-se instalar e utilizar certos pacotes para realizar essa operação. Existem diversas opções, porém, os principais pacotes são {XLConnect} (Mirai Solutions GmbH 2023), {xlsx} (Dragulescu and Arendt 2020), {readxl} (Wickham and Bryan 2023) e {tidyxl} (Garmonsway 2023).\nApesar de os pacotes anteriores terem objetivos semelhantes, cada um tem suas peculiaridades. Caso a leitura de arquivos do Excel seja algo importante no seu trabalho, aconselho-o fortemente a estudar as diferenças entre esses pacotes. Por exemplo, pacote {tidyxl} (Garmonsway 2023) permite a leitura de dados não-estruturados de um arquivo Excel, enquanto {XLConnect} (Mirai Solutions GmbH 2023) possibilita a abertura de uma conexão ativa entre o R e o Excel, onde o usuário pode transmitir dados entre um e o outro, formatar células, criar gráficos no Excel e muito mais.\nNesta seção, daremos prioridade para funções do pacote {readxl} (Wickham and Bryan 2023), o qual é um dos mais fáceis e diretos de se utilizar, além de não necessitar de outros softwares instalados (tal como o Java). Para instalar o referido pacote, basta utilizar a função install.packages() :\n\ninstall.packages('readxl')\n\nImagine agora a existência de um arquivo chamado CH04_ibovespa-Excel.xlsx que contenha os mesmos dados do Ibovespa que importamos na seção anterior. A importação das informações contidas nesse arquivo para o R será realizada através da função readxl::read_excel() :\n\nlibrary(readxl)\nlibrary(dplyr)\n\n# set file\nmy_f &lt;- introR::data_path(\"CH04_ibovespa-Excel.xlsx\")\n\n# read xlsx into dataframe\nmy_df &lt;- read_excel(my_f, sheet = 'Sheet1')\n\n# glimpse contents\nglimpse(my_df)\n\nR&gt; Rows: 3,215\nR&gt; Columns: 2\nR&gt; $ ref_date    &lt;dttm&gt; 2010-01-04, 2010-01-05, 2010-01-06, 2…\nR&gt; $ price_close &lt;dbl&gt; 70045, 70240, 70729, 70451, 70263, 704…\n\n\nObserve que, nesse caso, as datas já foram importadas com a formatação correta na classe dttm (datetime). Essa é uma vantagem ao utilizar arquivos do Excel: a classe dos dados do arquivo original é levada em conta no momento da importação. O lado negativo desse formato é a baixa portabilidade dos dados e o maior tempo necessário para a execução da importação. Como regra geral, dados importados do Excel apresentarão um tempo de carregamento mais alto do que dados importados de arquivos .csv.\n\n\n6.3.2 Exportação de Dados\nA exportação para arquivo Excel também é fácil. Assim como para a importação, não existe uma função nativa do R que execute esse procedimento. Para tal tarefa, temos pacotes {xlsx} (Dragulescu and Arendt 2020) e {writexl} (Ooms 2023). Uma diferença aqui é que o pacote {xlsx} (Dragulescu and Arendt 2020) oferece mais funcionalidade mas exige a instalação do Java JDK no sistema operacional. No caso do Windows, basta visitar o site do Java e instalar o software na versão 64 bits (opção Windows Off-line (64 bits)). Logo após, instale o pacote {xlsx} (Dragulescu and Arendt 2020) normalmente no R com o comando install.packages('xlsx').\nPara fins de ilustração de uso, vamos utilizar o pacote {writexl} (Ooms 2023)\n\n# set number of rows\nN &lt;- 50\n\n# create random dataframe\nmy_df &lt;- data.frame(y = seq(1,N),\n                    z = rep('a',N))\n\n# write to xlsx\nf_out &lt;- fs::file_temp(ext = '.xlsx')\n\nwritexl::write_xlsx(x = my_df, path = f_out)"
  },
  {
    "objectID": "06-importacao-exportacao-dados-locais.html#formato-.rdata-e-.rds",
    "href": "06-importacao-exportacao-dados-locais.html#formato-.rdata-e-.rds",
    "title": "6  Importação e Exportação de Dados Locais",
    "section": "6.4 Formato .RData e .rds",
    "text": "6.4 Formato .RData e .rds\nO R possui dois formatos nativos para salvar objetos de sua área de trabalho para um arquivo local com extensão RData ou rds. O grande benefício, em ambos os casos, é que o arquivo resultante é compacto e o seu acesso é muito rápido. A desvantagem é que os dados perdem portabilidade para outros programas. A diferença entre um formato e outro é que arquivos RData podem salvar mais de um objeto, enquanto o formato .rds salva apenas um. Na prática, porém, essa não é uma restrição forte. No R existe um objeto do tipo lista que incorpora outros. Portanto, caso salvarmos uma lista em um arquivo .rds, podemos gravar no disco quantos objetos forem necessários.\n\n6.4.1 Importação de Dados\nPara carregar os dados de um aquivo RData, utilizamos a função load() :\n\n# set a object\nmy_x &lt;- 1:100\n\n# set temp name of RData file\nmy_file &lt;- introR::data_path('CH04_example-Rdata.RData')\n\n# load it\nload(file = my_file)\n\nO arquivo CH04_example-Rdata.RData possui dois objetos, my_x e my_y, os quais se tornam disponíveis na área de trabalho depois da chamada de load() .\nO processo de importação para arquivos .rds é muito semelhante. A diferença é no uso da função readr::read_rds() :\n\n# set file path\nmy_file &lt;- introR::data_path('CH04_example-rds.rds')\n\n# load content into workspace\nmy_x &lt;- readr::read_rds(file = my_file)\n\nComparando o código entre o uso de arquivos .RData e .rds, note que um benefício no uso de .rds é a explícita definição do objeto na área de trabalho. Isto é, o conteúdo de my_file em readr::read_rds() é explicitamente salvo em my_x. Quando usamos a função load() , no código não fica claro qual o nome do objeto que foi importado. Isso é particularmente inconveniente quando é necessário modificar o nome do objeto importado.\n\n\n\n\n\n\nImportante\n\n\n\nComo sugestão, dê preferência ao uso do formato .rds, o qual deve resultar em códigos mais transparentes. A diferença de velocidade de acesso e gravação entre um e outro é mínima. O benefício de importar vários objetos em um mesmo arquivo com o formato RData torna-se irrelevante quando no uso de objetos do tipo lista, os quais podem incorporar outros objetos no seu conteúdo.\n\n\n\n\n6.4.2 Exportação de Dados\nPara criar um novo arquivo RData, utilizamos a função save() . Veja o exemplo a seguir, onde criamos um arquivo RData com dois objetos:\n\n# set vars\nmy_x &lt;- 1:100\nmy_y &lt;- 1:100\n\n# write to RData\nmy_file &lt;- fs::file_temp(ext = '.RData')\nsave(list = c('my_x', 'my_y'),\n     file = my_file)\n\nPodemos verificar a existência do arquivo::\n\nfs::file_exists(my_file)\n\nR&gt; /tmp/RtmphMLwie/file4a6d35ab281b.RData \nR&gt;                                   TRUE\n\n\nObserve que o arquivo file4a6d35ab281b.RData está disponível na pasta temporária.\nJá para arquivos .rds, salvamos o objeto com função readr::write_rds() :\n\n# set data and file\nmy_x &lt;- 1:100\nmy_file &lt;- fs::file_temp(ext = \".rds\")\n\n# save as .rds\nreadr::write_rds(my_x, my_file)\n\n# read it\nmy_x2 &lt;- readr::read_rds(my_file)\n\n# test equality\nprint(identical(my_x, my_x2))\n\nR&gt; [1] TRUE\n\n\nO comando identical() testa a igualdade entre os objetos e, como esperado, verificamos que my_x e my_x2 são exatamente iguais."
  },
  {
    "objectID": "06-importacao-exportacao-dados-locais.html#arquivos-fst",
    "href": "06-importacao-exportacao-dados-locais.html#arquivos-fst",
    "title": "6  Importação e Exportação de Dados Locais",
    "section": "6.5 Arquivos fst",
    "text": "6.5 Arquivos fst\nPacote {fst} (Klik 2022) foi especialmente desenhado para possibilitar a gravação e leitura de dados tabulares de forma rápida e com mínimo uso do espaço no disco. O uso deste formato é particularmente benéfico quando se está trabalhando com volumosas bases de dados em computadores potentes. O grande truque do formato fst é usar todos núcleos do computador para importar e exportar dados, enquanto todos os demais formatos se utilizam de apenas um. Como logo veremos, o ganho em velocidade é bastante significativo.\n\n6.5.1 Importação de Dados\nO uso do formato fst é bastante simples. Utilizamos a função fst::read_fst() para ler arquivos:\n\nlibrary(fst)\n\nmy_file &lt;- introR::data_path('CH04_example-fst.fst')\nmy_df &lt;- read_fst(my_file)\n\ndplyr::glimpse(my_df)\n\nR&gt; Rows: 100\nR&gt; Columns: 8\nR&gt; $ ID     &lt;chr&gt; \"001\", \"002\", \"003\", \"004\", \"005\", \"006\", \"…\nR&gt; $ Race   &lt;fct&gt; Black, White, Hispanic, Black, White, White…\nR&gt; $ Age    &lt;int&gt; 33, 35, 23, 87, 65, 51, 58, 67, 22, 52, 52,…\nR&gt; $ Sex    &lt;fct&gt; Male, Female, Male, Female, Male, Male, Fem…\nR&gt; $ Hour   &lt;dbl&gt; 0.00000000, 0.00000000, 0.00000000, 0.00000…\nR&gt; $ IQ     &lt;dbl&gt; 108, 108, 85, 106, 92, 92, 88, 100, 86, 80,…\nR&gt; $ Height &lt;dbl&gt; 72, 63, 77, 72, 71, 74, 64, 69, 63, 72, 70,…\nR&gt; $ Died   &lt;lgl&gt; FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, TRUE…\n\n\nAssim como para os demais casos, os dados estão disponíveis na área de trabalho após a importação.\n\n\n6.5.2 Exportação de Dados\nUtilizamos a função fst::write_fst() para gravar arquivos no formato fst, :\n\nlibrary(fst)\n\n# create dataframe\nN &lt;- 1000\nmy_file &lt;- fs::file_temp(ext = '.fst')\nmy_df &lt;- data.frame(x = runif(N))\n\n# write to fst\nwrite_fst(x = my_df, path = my_file)\n\n\n\n6.5.3 Testando o Tempo de Execução do Formato fst\nComo um teste do potencial do pacote {fst} (Klik 2022), a seguir vamos cronometrar o tempo de leitura e gravação entre fst e rds para um dataframe com grande quantidade de dados: 5,000,000 linhas e 2 colunas. Iremos reportar também o tamanho do arquivo resultante.\n\nlibrary(fst)\n\n# set number of rows\nN &lt;- 5000000\n\n# create random dfs\nmy_df &lt;- data.frame(y = seq(1,N),\n                    z = rep('a',N))\n\n# set files\nmy_file_rds &lt;- fs::file_temp(ext = \".rds\")\nmy_file_fst &lt;- fs::file_temp(ext = \".fst\")\n\n# test write\ntime_write_rds &lt;- system.time(readr::write_rds(my_df, my_file_rds ))\ntime_write_fst &lt;- system.time(fst::write_fst(my_df, my_file_fst ))\n\n# test read\ntime_read_rds &lt;- system.time(readr::read_rds(my_file_rds))\ntime_read_fst &lt;- system.time(fst::read_fst(my_file_fst))\n\n# test file size (MB)\nfile_size_rds &lt;- file.size(my_file_rds)/1000000\nfile_size_fst &lt;- file.size(my_file_fst)/1000000\n\nApós a execução, vamos verificar o resultado:\n\n# results\nmy_formats &lt;- c('.rds', '.fst')\nresults_read &lt;- c(time_read_rds[3], time_read_fst[3])\nresults_write&lt;- c(time_write_rds[3], time_write_fst[3])\nresults_file_size &lt;- c(file_size_rds , file_size_fst)\n\n# print text\nmy_text &lt;- paste0('\\nTime to WRITE dataframe with ',\n                  my_formats, ': ',\n                  results_write, ' seconds', collapse = '')\nmessage(my_text)\n\nR&gt; \nR&gt; Time to WRITE dataframe with .rds: 0.749 seconds\nR&gt; Time to WRITE dataframe with .fst: 0.115 seconds\n\nmy_text &lt;- paste0('\\nTime to READ dataframe with ',\n                  my_formats, ': ',\n                  results_read, ' seconds', collapse = '')\nmessage(my_text)\n\nR&gt; \nR&gt; Time to READ dataframe with .rds: 0.916 seconds\nR&gt; Time to READ dataframe with .fst: 0.141 seconds\n\nmy_text &lt;- paste0('\\nResulting FILE SIZE for ',\n                  my_formats, ': ',\n                  results_file_size, ' MBs', collapse = '')\nmessage(my_text)\n\nR&gt; \nR&gt; Resulting FILE SIZE for .rds: 65.000177 MBs\nR&gt; Resulting FILE SIZE for .fst: 14.791938 MBs\n\n\nA diferença é gritante! O formato fst não somente lê e grava com mais rapidez mas o arquivo resultante também é menor. Porém, saiba que os resultados anteriores foram compilados em um computador com 16 núcleos. É possível que a diferença de tempo para um computador mais modesto não seja tão significativa.\n\n\n\n\n\n\nDica\n\n\n\nDevido ao uso de todos os núcleos do computador, o formato fst é altamente recomendado quando estiver trabalhando com dados volumosos em um computador potente. Não somente os arquivos resultantes serão menores, mas o processo de gravação e leitura será consideravelmente mais rápido.\n\n\n\n\n\n\n\n\nTip\n\n\n\nDevido ao uso de todos os núcleos do computador, o formato fst é altamente recomendado quando estiver trabalhando com dados volumosos em um computador potente. Não somente os arquivos resultantes serão menores, mas o processo de gravação e leitura será consideravelmente mais rápido."
  },
  {
    "objectID": "06-importacao-exportacao-dados-locais.html#dados-não-estruturados-e-outros-formatos",
    "href": "06-importacao-exportacao-dados-locais.html#dados-não-estruturados-e-outros-formatos",
    "title": "6  Importação e Exportação de Dados Locais",
    "section": "6.6 Dados Não-Estruturados e Outros Formatos",
    "text": "6.6 Dados Não-Estruturados e Outros Formatos\nOs pacotes e formatos anteriores são suficientes para resolver o problema de importação de dados na grande maioria das situações. Apesar disso, vale destacar que o R possui outras funções específicas para diferentes formatos. Isso inclui arquivos exportados de outros softwares, tal como SPSS, Matlab, entre vários outros. Se esse for o seu caso, sugiro um estudo aprofundado do pacote {foreign} (R Core Team 2023).\nEm alguns casos nos deparamos com dados armazenados de uma forma não estruturada, tal como um texto qualquer. Pode-se importar o conteúdo de um arquivo de texto linha por linha através da função readr::read_lines() . Veja o exemplo a seguir, onde importamos o conteúdo inteiro do livro Pride and Prejudice:\n\n# set file to read\nmy_f &lt;- introR::data_path('CH04_price-and-prejudice.txt')\n\n# read file line by line\nmy_txt &lt;- readr::read_lines(my_f)\n\n# print 50 characters of first fifteen lines\nprint(stringr::str_sub(string = my_txt[1:15], \n              start = 1, \n              end = 50))\n\nR&gt;  [1] \"                            [Illustration:\"        \nR&gt;  [2] \"\"                                                  \nR&gt;  [3] \"                             GEORGE ALLEN\"         \nR&gt;  [4] \"                               PUBLISHER\"          \nR&gt;  [5] \"\"                                                  \nR&gt;  [6] \"                        156 CHARING CROSS ROAD\"    \nR&gt;  [7] \"                                LONDON\"            \nR&gt;  [8] \"\"                                                  \nR&gt;  [9] \"                             RUSKIN HOUSE\"         \nR&gt; [10] \"                                   ]\"              \nR&gt; [11] \"\"                                                  \nR&gt; [12] \"                            [Illustration:\"        \nR&gt; [13] \"\"                                                  \nR&gt; [14] \"               _Reading Jane’s Letters._      _Cha\"\nR&gt; [15] \"                                   ]\"\n\n\nNeste exemplo, arquivo CH04_price-and-prejudice.txt contém todo o conteúdo do livro Pride and Prejudice de Jane Austen, disponível gratuitamente pelo projeto Gutenberg. Importamos todo o conteúdo do arquivo como um vetor de texto denominado my_txt. Cada elemento de my_txt é uma linha do arquivo do texto original. Com base nisso, podemos calcular o número de linhas do livro e o número de vezes que o nome 'Bennet', um dos protagonistas da história, aparece no texto:\n\n# count number of lines\nn_lines &lt;- length(my_txt)\n\n# set target text\nname_to_search &lt;- 'Bennet'\n\n# set function for counting words\nfct_count_bennet &lt;- function(str_in, target_text) {\n  \n  require(stringr)\n  \n  \n  n_words &lt;- length(str_locate_all(string = str_in, \n                                   pattern = target_text)[[1]])\n  \n  return(n_words)\n}\n\n# use fct for all lines of Pride and Prejudice\nn_times &lt;- sum(sapply(X = my_txt, \n                      FUN = fct_count_bennet, \n                      target_text = name_to_search))\n\n# print results\nmy_msg &lt;- paste0('The number of lines found in the file is ', \n                 n_lines, '.\\n',\n                 'The word \"', name_to_search, '\" appears ', \n                 n_times, ' times in the book.')\nmessage(my_msg)\n\nR&gt; The number of lines found in the file is 14529.\nR&gt; The word \"Bennet\" appears 696 times in the book.\n\n\nNo exemplo, mais uma vez usamos sapply() . Neste caso, a função nos permitiu usar outra função para cada elemento de my_txt. Neste caso, procuramos e contamos o número de vezes que a palavra “Bennet” foi encontrada no texto. Observe que poderíamos simplesmente mudar name_to_search por qualquer outro nome, caso quiséssemos.\n\n6.6.1 Exportando de Dados Não-Estruturados\nEm algumas situações, é necessário exportar algum tipo de texto para um arquivo. Por exemplo: quando se precisa salvar o registro de um procedimento em um arquivo de texto; ou quando se precisa gravar informações em um formato específico não suportado pelo R. Esse procedimento é bastante simples. Junto à função readr::write_lines() , basta indicar um arquivo de texto para a saída com o argumento file. Veja a seguir:\n\n# set file\nmy_f &lt;- tempfile(fileext = '.txt')\n\n# set some string\nmy_text &lt;- paste0('Today is ', Sys.Date(), '\\n', \n                  'Tomorrow is ', Sys.Date()+1)\n\n# save string to file\nreadr::write_lines(x = my_text, file = my_f, append = FALSE)\n\nNo exemplo, criamos um objeto de texto com uma mensagem sobre a data atual e gravamos a saída no arquivo temporário file4a6d6bb543e3.txt. Podemos checar o resultado com a função readr::read_lines() :\n\nprint(readr::read_lines(my_f))\n\nR&gt; [1] \"Today is 2024-01-10\"    \"Tomorrow is 2024-01-11\""
  },
  {
    "objectID": "06-importacao-exportacao-dados-locais.html#selecionando-o-formato",
    "href": "06-importacao-exportacao-dados-locais.html#selecionando-o-formato",
    "title": "6  Importação e Exportação de Dados Locais",
    "section": "6.7 Selecionando o Formato",
    "text": "6.7 Selecionando o Formato\nApós entendermos a forma de salvar e carregar dados de arquivos locais em diferentes formatos, é importante discutirmos sobre a escolha do formato. O usuário deve levar em conta três pontos nessa decisão:\n\nvelocidade de importação e exportação;\ntamanho do arquivo resultante;\ncompatibilidade com outros programas e sistemas.\n\nNa grande maioria das situações, o uso de arquivos csv satisfaz esses quesitos. Ele nada mais é do que um arquivo de texto que pode ser aberto, visualizado e importado em qualquer programa. Desse modo, fica muito fácil compartilhar dados compatíveis com outros usuários. Além disso, o tamanho de arquivos csv geralmente não é exagerado em computadores modernos. Caso necessário, podes compactar o arquivo .csv usando o programa 7zip, por exemplo, o qual irá diminuir consideravelmente o tamanho do arquivo. Por esses motivos, o uso de arquivos csv para importações e exportações é preferível na grande maioria das situações.\nExistem casos, porém, onde a velocidade de importação e exportação pode fazer diferença. Caso abrir mão de portabilidade não faça diferença ao projeto, o formato rds é ótimo e prático. Se este não foi suficiente, então a melhor alternativa é partir para o fst, o qual usa maior parte do hardware do computador para importar os dados. Como sugestão, caso puder, apenas evite o formato do Excel, o qual é o menos eficiente de todos."
  },
  {
    "objectID": "06-importacao-exportacao-dados-locais.html#exerc-importacao-exportacao",
    "href": "06-importacao-exportacao-dados-locais.html#exerc-importacao-exportacao",
    "title": "6  Importação e Exportação de Dados Locais",
    "section": "6.8 Exercícios",
    "text": "6.8 Exercícios\n\n\n\n\nDragulescu, Adrian, and Cole Arendt. 2020. Xlsx: Read, Write, Format Excel 2007 and Excel 97/2000/XP/2003 Files. https://github.com/colearendt/xlsx.\n\n\nGarmonsway, Duncan. 2023. Tidyxl: Read Untidy Excel Files. https://github.com/nacnudus/tidyxl.\n\n\nKlik, Mark. 2022. Fst: Lightning Fast Serialization of Data Frames. http://www.fstpackage.org.\n\n\nMirai Solutions GmbH. 2023. XLConnect: Excel Connector for r. https://mirai-solutions.ch https://github.com/miraisolutions/xlconnect.\n\n\nOoms, Jeroen. 2023. Writexl: Export Data Frames to Excel Xlsx Format. https://docs.ropensci.org/writexl/.\n\n\nR Core Team. 2023. Foreign: Read Data Stored by Minitab, s, SAS, SPSS, Stata, Systat, Weka, dBase, ... https://svn.r-project.org/R-packages/trunk/foreign/.\n\n\nWickham, Hadley. 2023. Tidyverse: Easily Install and Load the Tidyverse. https://tidyverse.tidyverse.org.\n\n\nWickham, Hadley, and Jennifer Bryan. 2023. Readxl: Read Excel Files. https://readxl.tidyverse.org.\n\n\nWickham, Hadley, Romain François, Lionel Henry, Kirill Müller, and Davis Vaughan. 2023. Dplyr: A Grammar of Data Manipulation. https://dplyr.tidyverse.org.\n\n\nWickham, Hadley, Jim Hester, and Jennifer Bryan. 2023. Readr: Read Rectangular Text Data. https://readr.tidyverse.org."
  },
  {
    "objectID": "07-importacao-internet.html#pacote-yfr-r-yfr",
    "href": "07-importacao-internet.html#pacote-yfr-r-yfr",
    "title": "7  Importação de Dados via Pacotes",
    "section": "7.1 Pacote {yfR} (M. Perlin 2023b)",
    "text": "7.1 Pacote {yfR} (M. Perlin 2023b)\n\nPacote {yfR} (M. Perlin 2023b) faz a comunicação do R com os dados financeiros disponíveis no Yahoo Finance. Essa gigantesca base de dados inclui valores agregados de preços e volumes negociados de ações na B3 e outras bolsas internacionais na frequência diária. Tudo que se precisa saber para acessar a base de dados são os identificadores das ações (tickers) e um período de tempo.\nOs diferenciais do {yfR} (M. Perlin 2023b) são:\nLimpeza e organização: todos os dados financeiros de diferentes tickers são mantidos no mesmo dataframe, facilitando a análise futura com as ferramentas do {tidyverse} (Wickham 2023).\nControle de erros de importação: todos erros de download são registrados na saída do programa. Caso uma ação em particular não exista no Yahoo Finance, esta será ignorada e apenas as demais disponíveis serão retornadas na saída do código;\nComparação de datas a um benchmark: os dados de ativos individuais são comparados com dados disponíveis para um ativo benchmark, geralmente um índice de mercado. Caso o número de datas faltantes seja maior que um determinado limite imposto pelo usuário, a ação é retirada do dataframe final.\nUso de sistema de cache: no momento de acesso aos dados, os mesmos são salvos localmente no computador do usuário e são persistentes para cada sessão. Caso o usuário requisitar os mesmos dados na mesma sessão do R, o sistema de cache será utilizado. Se os dados desejados não estão disponíveis no cache, a função irá comparar e baixar apenas as informações que faltam. Isso aumenta significativamente a velocidade de acesso aos dados, ao mesmo tempo em que minimiza o uso da conexão a Internet;\n\n\n\n\n\n\nImportante\n\n\n\nDesde versão 2.6 (2020-11-22) de {yfR} (M. Perlin 2023b) a pasta default de cache do {yfR} (M. Perlin 2023b) se localiza no diretório temporário da sessão do R. Assim, o cache é persistente apenas para a sessão do usuário. Esta mudança foi motivada por quebras estruturais nos dados do Yahoo Finance, onde os dados passados registrados em cache não mais estavam corretos devido a eventos coporativos. O usuário, porém, pode trocar a pasta de cache usando a entrada cache.folder.\n\n\nAcesso a tickers em índices de mercado: O pacote inclui funções para baixar a composição dos índices Ibovespa, SP500 e FTSE100. Isso facilita a importação de dados para uma grande quantidade de ações. Podes, por exemplo, baixar cotações de todas as ações que fazem parte de certo índice.\nProcessamento paralelo: Caso o usuário estiver baixando um grande volume de dados do Yahoo Finance, uma opção para execução paralela está disponível. Isto é, ao invés de usar apenas um núcleo na requisição dos dados, usamos vários ao mesmo tempo. O efeito prático é, dependendo do número de núcleos do computador, uma diminuição significativa no tempo total de importação.\nFlexibilidade de formato: O pacote também oferece funções para modificar o formato dos dados. Caso o usuário deseje uma saída do dataframe no formato largo, onde tickers são colunas e as linhas os preços/retornos, basta chamar função BatchGetSymbols::reshape.wide. Da mesma forma, uma transformação temporal também é possível. Se o usuário desejar dados na frequência semanal, mensal ou anual, basta indicar na entrada freq.data da função.\nComo exemplo de uso, vamos baixar dados financeiros referentes a quatro ações no último ano (360 dias) usando a função de mesmo nome do pacote. Os tickers de cada ação podem ser encontrados nos próprios sites do Yahoo Finance. Note que adicionamos texto .SA a cada um deles. Essa é uma notação específica do site e vale para qualquer ação Brasileira.\nNa chamada da função {yfR} (M. Perlin 2023b), utilizamos um valor de 0.95 (95%) para o input thresh.bad.data e '^BVSP' para bench.ticker. Isso faz com que a função compare as datas obtidas para cada ativo em relação ao nosso benchmark, o índice Ibovespa, cujo ticker no Yahoo Finance é ^BVSP. Se, durante o processo de importação, uma ação individual não apresenta mais de 95% de casos válidos em relação ao benchmark, esta é retirada da saída.\n \n\nlibrary(BatchGetSymbols)\nlibrary(dplyr)\n\n# set tickers\nmy_tickers &lt;- c('PETR4.SA', 'CIEL3.SA',\n                'GGBR4.SA', 'GOAU4.SA')\n\n# set dates and other inputs\nfirst_date &lt;- Sys.Date()-360\nlast_date &lt;- Sys.Date()\nthresh_bad_data &lt;- 0.95   # sets percent threshold for bad data\nbench_ticker &lt;- '^BVSP'   # set benchmark as ibovespa\n\nl_out &lt;- BatchGetSymbols(tickers = my_tickers,\n                         first.date = first_date,\n                         last.date = last_date,\n                         bench.ticker = bench_ticker,\n                         thresh.bad.data = thresh_bad_data)\n\nR&gt; Warning: `BatchGetSymbols()` was deprecated in BatchGetSymbols\nR&gt; 2.6.4.\nR&gt; ℹ Please use `yfR::yf_get()` instead.\nR&gt; ℹ 2022-05-01: Package BatchGetSymbols will soon be replaced\nR&gt;   by yfR.  More details about the change is available at\nR&gt;   github &lt;&lt;www.github.com/msperlin/yfR&gt; You can install yfR\nR&gt;   by executing:\nR&gt; \nR&gt; remotes::install_github('msperlin/yfR')\n\n\nA saída de {yfR} (M. Perlin 2023b) é um objeto do tipo lista, ainda não visto no livro. Por enquanto, tudo que precisas saber é que uma lista é um objeto flexível, acomodando outros objetos em sua composição. O acesso a cada elemento de uma lista pode ser feito pelo operador $. No capítulo @ref(classe-estrutura) iremos estudar melhor esta classe de objetos.\n\n\n\n\n\n\nImportante\n\n\n\nNote que as entradas da função BatchGetSymbols::BatchGetSymbols usam o “.” em seus nomes, tal como thresh.bad.data, e bench.ticker, enquanto o livro está escrito usando o traço baixo (_), tal como thresh_bad_data, e bench_ticker. Esta diferença pode resultar em problemas se, na falta de atenção, o usuário trocar um pelo outro. Como regra, procure dar prioridade para o uso de traço baixo nos nomes de objetos. Infelizmente algumas funções escritas no passado acabaram ficando com a estrutura antiga e, para não prejudicar os usuários, os nomes das entradas foram mantidos.\n\n\nVoltando ao nosso exemplo, função {yfR} (M. Perlin 2023b) retorna uma lista com dois elementos: um dataframe com o resultado do processo de importação – df_control – e outro dataframe com os dados das ações – df_tickers. Vamos checar o conteúdo do primeiro dataframe.\n\n# print result of download process\nprint(l_out$df.control)\n\nR&gt; # A tibble: 4 × 6\nR&gt;   ticker   src   download.status total.obs\nR&gt;   &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;               &lt;int&gt;\nR&gt; 1 PETR4.SA yahoo OK                    244\nR&gt; 2 CIEL3.SA yahoo OK                    244\nR&gt; 3 GGBR4.SA yahoo OK                    244\nR&gt; 4 GOAU4.SA yahoo OK                    244\nR&gt; # ℹ 2 more variables: perc.benchmark.dates &lt;dbl&gt;,\nR&gt; #   threshold.decision &lt;chr&gt;\n\n\nObjeto df.control mostra que todos tickers foram válidos, com um total de 244 observações para cada ativo. Note que as datas batem 100% com o Ibovespa (coluna perc.benchmark.dates).\nQuanto aos dados financeiros, esses estão contidos em l_out$df.tickers:\n\n# print df_tickers\nglimpse(l_out$df.tickers)\n\nR&gt; Rows: 976\nR&gt; Columns: 10\nR&gt; $ price.open          &lt;dbl&gt; 24.41, 24.11, 25.84, 25.00, 25…\nR&gt; $ price.high          &lt;dbl&gt; 24.50, 25.62, 26.03, 25.95, 26…\nR&gt; $ price.low           &lt;dbl&gt; 23.83, 24.11, 25.00, 24.79, 25…\nR&gt; $ price.close         &lt;dbl&gt; 24.04, 25.52, 25.07, 25.89, 26…\nR&gt; $ volume              &lt;dbl&gt; 31973700, 91797500, 69692900, …\nR&gt; $ price.adjusted      &lt;dbl&gt; 18.62798, 19.77480, 19.42610, …\nR&gt; $ ref.date            &lt;date&gt; 2023-01-16, 2023-01-17, 2023-…\nR&gt; $ ticker              &lt;chr&gt; \"PETR4.SA\", \"PETR4.SA\", \"PETR4…\nR&gt; $ ret.adjusted.prices &lt;dbl&gt; NA, 0.061564070, -0.017633247,…\nR&gt; $ ret.closing.prices  &lt;dbl&gt; NA, 0.061564039, -0.017633258,…\n\n\nComo esperado, a informação sobre preços, retornos e volumes está lá, com as devidas classes de colunas: dbl (double) para valores numéricos e date para as datas. Observe que uma coluna chamada ticker também está incluída. Essa indica em que linhas da tabela os dados de uma ação começam e terminam. Mais tarde, no capítulo @ref(limpando-estruturando), usaremos essa coluna para fazer diversos cálculos para cada ação.\n\n7.1.1 Baixando Dados da Composição do Ibovespa\nOutra função útil do pacote é BatchGetSymbols::GetIbovStocks, a qual importa a composição atual do índice Ibovespa diretamente do site da B3. Esse índice é um termômetro do mercado local e as ações que o compõem são selecionadas devido sua alta negociabilidade. Portanto, sequenciando o uso de GetIbovStocks e {yfR} (M. Perlin 2023b), podemos facilmente baixar uma volumosa quantidade de dados de ações para o mercado Brasileiro. Considere o seguinte fragmento de código, onde realizamos essa operação: \n\nlibrary(BatchGetSymbols)\n\n# set tickers\ndf_ibov &lt;- GetIbovStocks()\nmy_tickers &lt;- paste0(df_ibov$tickers,'.SA')\n\n\n# set dates and other inputs\nfirst_date &lt;- Sys.Date()-30\nlast_date &lt;- Sys.Date()\nthresh_bad_data &lt;- 0.95   # sets percent threshold for bad data\nbench_ticker &lt;- '^BVSP'   # set benchmark as ibovespa\ncache_folder &lt;- 'data/BGS_Cache' # set folder for cache\n\n\nl_out &lt;- BatchGetSymbols(tickers = my_tickers,\n                         first.date = first_date,\n                         last.date = last_date,\n                         bench.ticker = bench_ticker,\n                         thresh.bad.data = thresh_bad_data,\n                         cache.folder = cache_folder)\n\nNote que utilizamos a função paste0() para adicionar o texto '.SA' para cada ticker em df_ibov$tickers. A saída do código anterior não foi mostrada para não encher páginas e páginas com as mensagens do processamento. Destaco que, caso necessário, poderíamos facilmente exportar os dados em l_out para um arquivo .rds e futuramente carregá-los localmente para realizar algum tipo de análise.\n\n\n\n\n\n\nCuidado\n\n\n\nSaiba que os preços do Yahoo Finance não são ajustados a dividendos. O ajuste realizado pelo sistema é apenas para desdobramentos das ações. Isso significa que, ao olhar séries de preços em um longo período, existe um viés de retorno para baixo. Ao comparar com outro software que faça o ajustamento dos preços por dividendos, verás uma grande diferença na rentabilidade total das ações. Como regra, em uma pesquisa formal, evite usar dados de ações individuais no Yahoo Finance para períodos longos. A excessão é para índices financeiros, tal como o Ibovespa, onde os dados do Yahoo Finance são bastante confiáveis uma vez que índices não sofrem os mesmos ajustamentos que ações individuais."
  },
  {
    "objectID": "07-importacao-internet.html#pacote-gettddata-r-gettddata",
    "href": "07-importacao-internet.html#pacote-gettddata-r-gettddata",
    "title": "7  Importação de Dados via Pacotes",
    "section": "7.2 Pacote {GetTDData} (M. Perlin 2023a)",
    "text": "7.2 Pacote {GetTDData} (M. Perlin 2023a)\nArquivos com informações sobre preços e retornos de títulos emitidos pelo governo brasileiro podem ser baixados manualmente no site do Tesouro Nacional. O tesouro direto é um tipo especial de mercado onde pessoa física pode comprar e vender dívida pública. Os contratos de dívida vendidos na plataforma são bastante populares devido a atratividade das taxas de retorno e a alta liquidez oferecida ao investidor comum.\nPacote {GetTDData} (M. Perlin 2023a) importa os dados das planilhas em Excel do site do Tesouro Nacional e os organiza. O resultado é um dataframe com dados empilhados. Como exemplo, vamos baixar dados de um título prefixado do tipo LTN com vencimento em 2021-01-01. Esse é o tipo de contrato de dívida mais simples que o governo brasileiro emite, não pagando nenhum cupom1 durante sua validade e, na data de vencimento, retorna 1.000 R$ ao comprador. Para baixar os dados da internet, basta usar o código a seguir:\n \n\nlibrary(GetTDData)\n\nasset_codes &lt;- 'LTN'   # Identifier of assets\nmaturity &lt;- '010121'  # Maturity date as string (ddmmyy)\n\n# download and read files\ndf_TD &lt;- td_get(asset_codes)\n\nR&gt; \n\n\nR&gt; ── Downloading TD files\n\n\nR&gt; ℹ Downloading LTN_2005.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2005.xls' is found, with size 252.9 kB.\n\n\nR&gt; ℹ Downloading LTN_2006.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2006.xls' is found, with size 288.8 kB.\n\n\nR&gt; ℹ Downloading LTN_2007.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2007.xls' is found, with size 260.1 kB.\n\n\nR&gt; ℹ Downloading LTN_2008.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2008.xls' is found, with size 259.6 kB.\n\n\nR&gt; ℹ Downloading LTN_2009.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2009.xls' is found, with size 191.0 kB.\n\n\nR&gt; ℹ Downloading LTN_2010.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2010.xls' is found, with size 148.5 kB.\n\n\nR&gt; ℹ Downloading LTN_2011.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2011.xls' is found, with size 161.8 kB.\n\n\nR&gt; ℹ Downloading LTN_2012.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2012.xls' is found, with size 144.9 kB.\n\n\nR&gt; ℹ Downloading LTN_2013.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2013.xls' is found, with size 147.5 kB.\n\n\nR&gt; ℹ Downloading LTN_2014.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2014.xls' is found, with size 147.5 kB.\n\n\nR&gt; ℹ Downloading LTN_2015.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2015.xls' is found, with size 142.3 kB.\n\n\nR&gt; ℹ Downloading LTN_2016.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2016.xls' is found, with size 176.1 kB.\n\n\nR&gt; ℹ Downloading LTN_2017.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2017.xls' is found, with size 174.6 kB.\n\n\nR&gt; ℹ Downloading LTN_2018.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2018.xls' is found, with size 174.6 kB.\n\n\nR&gt; ℹ Downloading LTN_2019.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2019.xls' is found, with size 177.2 kB.\n\n\nR&gt; ℹ Downloading LTN_2020.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2020.xls' is found, with size 176.1 kB.\n\n\nR&gt; ℹ Downloading LTN_2021.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2021.xls' is found, with size 175.1 kB.\n\n\nR&gt; ℹ Downloading LTN_2022.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2022.xls' is found, with size 175.6 kB.\n\n\nR&gt; ℹ Downloading LTN_2023.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2023.xls' is found, with size 146.9 kB.\n\n\nR&gt; ℹ Downloading LTN_2024.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2024.xls' is found, with size 20.5 kB.\n\n\nR&gt; \n\n\nR&gt; ── Checking files\n\n\nR&gt; ✔ Found 20 files\n\n\nR&gt; \n\n\nR&gt; ── Reading files\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2005.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 040105\n\n\nR&gt; ✔    Reading Sheet LTN 010405\n\n\nR&gt; ✔    Reading Sheet LTN 010705\n\n\nR&gt; ✔    Reading Sheet LTN 011005\n\n\nR&gt; ✔    Reading Sheet LTN 010106\n\n\nR&gt; ✔    Reading Sheet LTN 010406\n\n\nR&gt; ✔    Reading Sheet LTN 010706\n\n\nR&gt; ✔    Reading Sheet LTN 011006\n\n\nR&gt; ✔    Reading Sheet LTN 010107\n\n\nR&gt; ✔    Reading Sheet LTN 010407\n\n\nR&gt; ✔    Reading Sheet LTN 010707\n\n\nR&gt; ✔    Reading Sheet LTN 010108\n\n\nR&gt; ✔    Reading Sheet LTN 010708\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2006.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010406\n\n\nR&gt; ✔    Reading Sheet LTN 010706\n\n\nR&gt; ✔    Reading Sheet LTN 011006\n\n\nR&gt; ✔    Reading Sheet LTN 010107\n\n\nR&gt; ✔    Reading Sheet LTN 010407\n\n\nR&gt; ✔    Reading Sheet LTN 010707\n\n\nR&gt; ✔    Reading Sheet LTN 011007\n\n\nR&gt; ✔    Reading Sheet LTN 010108\n\n\nR&gt; ✔    Reading Sheet LTN 010408\n\n\nR&gt; ✔    Reading Sheet LTN 010708\n\n\nR&gt; ✔    Reading Sheet LTN 010109\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2007.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010407\n\n\nR&gt; ✔    Reading Sheet LTN 010707\n\n\nR&gt; ✔    Reading Sheet LTN 011007\n\n\nR&gt; ✔    Reading Sheet LTN 010108\n\n\nR&gt; ✔    Reading Sheet LTN 010408\n\n\nR&gt; ✔    Reading Sheet LTN 010708\n\n\nR&gt; ✔    Reading Sheet LTN 011008\n\n\nR&gt; ✔    Reading Sheet LTN 010109\n\n\nR&gt; ✔    Reading Sheet LTN 010709\n\n\nR&gt; ✔    Reading Sheet LTN 011009\n\n\nR&gt; ✔    Reading Sheet LTN 010110\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2008.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010408\n\n\nR&gt; ✔    Reading Sheet LTN 010708\n\n\nR&gt; ✔    Reading Sheet LTN 011008\n\n\nR&gt; ✔    Reading Sheet LTN 010109\n\n\nR&gt; ✔    Reading Sheet LTN 010409\n\n\nR&gt; ✔    Reading Sheet LTN 010709\n\n\nR&gt; ✔    Reading Sheet LTN 011009\n\n\nR&gt; ✔    Reading Sheet LTN 010110\n\n\nR&gt; ✔    Reading Sheet LTN 010710\n\n\nR&gt; ✔    Reading Sheet LTN 010111\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2009.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010409\n\n\nR&gt; ✔    Reading Sheet LTN 010709\n\n\nR&gt; ✔    Reading Sheet LTN 011009\n\n\nR&gt; ✔    Reading Sheet LTN 010110\n\n\nR&gt; ✔    Reading Sheet LTN 010710\n\n\nR&gt; ✔    Reading Sheet LTN 010111\n\n\nR&gt; ✔    Reading Sheet LTN 010112\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2010.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010710\n\n\nR&gt; ✔    Reading Sheet LTN 010111\n\n\nR&gt; ✔    Reading Sheet LTN 010711\n\n\nR&gt; ✔    Reading Sheet LTN 010112\n\n\nR&gt; ✔    Reading Sheet LTN 010113\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2011.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010711\n\n\nR&gt; ✔    Reading Sheet LTN 010112\n\n\nR&gt; ✔    Reading Sheet LTN 010113\n\n\nR&gt; ✔    Reading Sheet LTN 010114\n\n\nR&gt; ✔    Reading Sheet LTN 010115\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2012.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010113\n\n\nR&gt; ✔    Reading Sheet LTN 010114\n\n\nR&gt; ✔    Reading Sheet LTN 010115\n\n\nR&gt; ✔    Reading Sheet LTN 010116\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2013.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010114\n\n\nR&gt; ✔    Reading Sheet LTN 010115\n\n\nR&gt; ✔    Reading Sheet LTN 010116\n\n\nR&gt; ✔    Reading Sheet LTN 010117\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2014.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010115\n\n\nR&gt; ✔    Reading Sheet LTN 010116\n\n\nR&gt; ✔    Reading Sheet LTN 010117\n\n\nR&gt; ✔    Reading Sheet LTN 010118\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2015.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010116\n\n\nR&gt; ✔    Reading Sheet LTN 010117\n\n\nR&gt; ✔    Reading Sheet LTN 010118\n\n\nR&gt; ✔    Reading Sheet LTN 010121\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2016.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010117\n\n\nR&gt; ✔    Reading Sheet LTN 010118\n\n\nR&gt; ✔    Reading Sheet LTN 010119\n\n\nR&gt; ✔    Reading Sheet LTN 010121\n\n\nR&gt; ✔    Reading Sheet LTN 010123\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2017.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010118\n\n\nR&gt; ✔    Reading Sheet LTN 010119\n\n\nR&gt; ✔    Reading Sheet LTN 010120\n\n\nR&gt; ✔    Reading Sheet LTN 010121\n\n\nR&gt; ✔    Reading Sheet LTN 010123\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2018.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010119\n\n\nR&gt; ✔    Reading Sheet LTN 010120\n\n\nR&gt; ✔    Reading Sheet LTN 010121\n\n\nR&gt; ✔    Reading Sheet LTN 010123\n\n\nR&gt; ✔    Reading Sheet LTN 010125\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2019.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010120\n\n\nR&gt; ✔    Reading Sheet LTN 010121\n\n\nR&gt; ✔    Reading Sheet LTN 010122\n\n\nR&gt; ✔    Reading Sheet LTN 010123\n\n\nR&gt; ✔    Reading Sheet LTN 010125\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2020.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010121\n\n\nR&gt; ✔    Reading Sheet LTN 010122\n\n\nR&gt; ✔    Reading Sheet LTN 010123\n\n\nR&gt; ✔    Reading Sheet LTN 010125\n\n\nR&gt; ✔    Reading Sheet LTN 010126\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2021.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010122\n\n\nR&gt; ✔    Reading Sheet LTN 010123\n\n\nR&gt; ✔    Reading Sheet LTN 010724\n\n\nR&gt; ✔    Reading Sheet LTN 010125\n\n\nR&gt; ✔    Reading Sheet LTN 010126\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2022.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010123\n\n\nR&gt; ✔    Reading Sheet LTN 010724\n\n\nR&gt; ✔    Reading Sheet LTN 010125\n\n\nR&gt; ✔    Reading Sheet LTN 010126\n\n\nR&gt; ✔    Reading Sheet LTN 010129\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2023.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010724\n\n\nR&gt; ✔    Reading Sheet LTN 010125\n\n\nR&gt; ✔    Reading Sheet LTN 010126\n\n\nR&gt; ✔    Reading Sheet LTN 010129\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2024.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010724\n\n\nR&gt; ✔    Reading Sheet LTN 010125\n\n\nR&gt; ✔    Reading Sheet LTN 010126\n\n\nR&gt; ✔    Reading Sheet LTN 010129\n\n\nVamos checar o conteúdo do dataframe:\n\n# check content\nglimpse(df_TD)\n\nR&gt; Rows: 24,465\nR&gt; Columns: 5\nR&gt; $ ref_date   &lt;date&gt; 2005-01-03, 2005-01-03, 2005-01-04, 20…\nR&gt; $ yield_bid  &lt;dbl&gt; 0.1774, 0.1836, 0.1839, 0.1841, 0.1842,…\nR&gt; $ price_bid  &lt;dbl&gt; 1000.00, 960.66, 961.24, 961.85, 962.48…\nR&gt; $ asset_code &lt;chr&gt; \"LTN 040105\", \"LTN 010405\", \"LTN 010405…\nR&gt; $ matur_date &lt;date&gt; 2005-01-04, 2005-04-01, 2005-04-01, 20…\n\n\nTemos informações sobre data de referência (ref.date), retorno contratado (yield.bid), preço do contrato na data (price.bid), nome do contrato (asset.code) e dia de maturidade (matur.date). No gráfico a seguir checamos os dados:\n\n\nR&gt; Warning: Using `size` aesthetic for lines was deprecated in ggplot2\nR&gt; 3.4.0.\nR&gt; ℹ Please use `linewidth` instead.\n\n\n\n\n\nComo esperado de um título de dívida pré-fixado, os preços possuem uma tendência positiva ao longo do tempo, chegando ao valor esperado de 1000 R$ no vencimento em 2021-01-01. Podemos também visualizar as mudanças do yield do título:\n\n\n\n\n\nOs retornos do título tiveram forte queda ao longo dos anos. Este resultado é esperado pois o juros do mercado – taxa SELIC – caiu bastante nos últimos cinco anos.\nAs funções do {GetTDData} (M. Perlin 2023a) também funcionam com vários argumentos como asset.codes e maturity. Suponhamos que desejamos visualizar todos os preços de todos os prazos disponíveis para títulos do tipo LTN a partir de 2010. Tudo o que precisamos fazer é adicionar o valor NULL ao argumento maturity e filtrar as datas:\n\nlibrary(GetTDData)\n\nasset_codes &lt;- 'LTN'   # Name of asset\nmaturity &lt;- NULL      # = NULL, downloads all maturities\n\n# download data\ndf_TD &lt;- td_get(asset_codes)\n\nR&gt; \n\n\nR&gt; ── Downloading TD files\n\n\nR&gt; ℹ Downloading LTN_2005.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2006.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2007.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2008.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2009.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2010.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2011.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2012.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2013.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2014.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2015.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2016.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2017.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2018.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2019.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2020.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2021.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2022.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2023.xls\n\n\nR&gt; ✔    Found file in folder, skipping it.\n\n\nR&gt; ℹ Downloading LTN_2024.xls\n\n\nR&gt; ✔    '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2024.xls' is found, with size 20.5 kB.\n\n\nR&gt; \n\n\nR&gt; ── Checking files\n\n\nR&gt; ✔ Found 20 files\n\n\nR&gt; \n\n\nR&gt; ── Reading files\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2005.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 040105\n\n\nR&gt; ✔    Reading Sheet LTN 010405\n\n\nR&gt; ✔    Reading Sheet LTN 010705\n\n\nR&gt; ✔    Reading Sheet LTN 011005\n\n\nR&gt; ✔    Reading Sheet LTN 010106\n\n\nR&gt; ✔    Reading Sheet LTN 010406\n\n\nR&gt; ✔    Reading Sheet LTN 010706\n\n\nR&gt; ✔    Reading Sheet LTN 011006\n\n\nR&gt; ✔    Reading Sheet LTN 010107\n\n\nR&gt; ✔    Reading Sheet LTN 010407\n\n\nR&gt; ✔    Reading Sheet LTN 010707\n\n\nR&gt; ✔    Reading Sheet LTN 010108\n\n\nR&gt; ✔    Reading Sheet LTN 010708\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2006.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010406\n\n\nR&gt; ✔    Reading Sheet LTN 010706\n\n\nR&gt; ✔    Reading Sheet LTN 011006\n\n\nR&gt; ✔    Reading Sheet LTN 010107\n\n\nR&gt; ✔    Reading Sheet LTN 010407\n\n\nR&gt; ✔    Reading Sheet LTN 010707\n\n\nR&gt; ✔    Reading Sheet LTN 011007\n\n\nR&gt; ✔    Reading Sheet LTN 010108\n\n\nR&gt; ✔    Reading Sheet LTN 010408\n\n\nR&gt; ✔    Reading Sheet LTN 010708\n\n\nR&gt; ✔    Reading Sheet LTN 010109\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2007.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010407\n\n\nR&gt; ✔    Reading Sheet LTN 010707\n\n\nR&gt; ✔    Reading Sheet LTN 011007\n\n\nR&gt; ✔    Reading Sheet LTN 010108\n\n\nR&gt; ✔    Reading Sheet LTN 010408\n\n\nR&gt; ✔    Reading Sheet LTN 010708\n\n\nR&gt; ✔    Reading Sheet LTN 011008\n\n\nR&gt; ✔    Reading Sheet LTN 010109\n\n\nR&gt; ✔    Reading Sheet LTN 010709\n\n\nR&gt; ✔    Reading Sheet LTN 011009\n\n\nR&gt; ✔    Reading Sheet LTN 010110\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2008.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010408\n\n\nR&gt; ✔    Reading Sheet LTN 010708\n\n\nR&gt; ✔    Reading Sheet LTN 011008\n\n\nR&gt; ✔    Reading Sheet LTN 010109\n\n\nR&gt; ✔    Reading Sheet LTN 010409\n\n\nR&gt; ✔    Reading Sheet LTN 010709\n\n\nR&gt; ✔    Reading Sheet LTN 011009\n\n\nR&gt; ✔    Reading Sheet LTN 010110\n\n\nR&gt; ✔    Reading Sheet LTN 010710\n\n\nR&gt; ✔    Reading Sheet LTN 010111\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2009.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010409\n\n\nR&gt; ✔    Reading Sheet LTN 010709\n\n\nR&gt; ✔    Reading Sheet LTN 011009\n\n\nR&gt; ✔    Reading Sheet LTN 010110\n\n\nR&gt; ✔    Reading Sheet LTN 010710\n\n\nR&gt; ✔    Reading Sheet LTN 010111\n\n\nR&gt; ✔    Reading Sheet LTN 010112\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2010.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010710\n\n\nR&gt; ✔    Reading Sheet LTN 010111\n\n\nR&gt; ✔    Reading Sheet LTN 010711\n\n\nR&gt; ✔    Reading Sheet LTN 010112\n\n\nR&gt; ✔    Reading Sheet LTN 010113\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2011.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010711\n\n\nR&gt; ✔    Reading Sheet LTN 010112\n\n\nR&gt; ✔    Reading Sheet LTN 010113\n\n\nR&gt; ✔    Reading Sheet LTN 010114\n\n\nR&gt; ✔    Reading Sheet LTN 010115\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2012.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010113\n\n\nR&gt; ✔    Reading Sheet LTN 010114\n\n\nR&gt; ✔    Reading Sheet LTN 010115\n\n\nR&gt; ✔    Reading Sheet LTN 010116\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2013.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010114\n\n\nR&gt; ✔    Reading Sheet LTN 010115\n\n\nR&gt; ✔    Reading Sheet LTN 010116\n\n\nR&gt; ✔    Reading Sheet LTN 010117\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2014.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010115\n\n\nR&gt; ✔    Reading Sheet LTN 010116\n\n\nR&gt; ✔    Reading Sheet LTN 010117\n\n\nR&gt; ✔    Reading Sheet LTN 010118\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2015.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010116\n\n\nR&gt; ✔    Reading Sheet LTN 010117\n\n\nR&gt; ✔    Reading Sheet LTN 010118\n\n\nR&gt; ✔    Reading Sheet LTN 010121\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2016.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010117\n\n\nR&gt; ✔    Reading Sheet LTN 010118\n\n\nR&gt; ✔    Reading Sheet LTN 010119\n\n\nR&gt; ✔    Reading Sheet LTN 010121\n\n\nR&gt; ✔    Reading Sheet LTN 010123\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2017.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010118\n\n\nR&gt; ✔    Reading Sheet LTN 010119\n\n\nR&gt; ✔    Reading Sheet LTN 010120\n\n\nR&gt; ✔    Reading Sheet LTN 010121\n\n\nR&gt; ✔    Reading Sheet LTN 010123\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2018.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010119\n\n\nR&gt; ✔    Reading Sheet LTN 010120\n\n\nR&gt; ✔    Reading Sheet LTN 010121\n\n\nR&gt; ✔    Reading Sheet LTN 010123\n\n\nR&gt; ✔    Reading Sheet LTN 010125\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2019.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010120\n\n\nR&gt; ✔    Reading Sheet LTN 010121\n\n\nR&gt; ✔    Reading Sheet LTN 010122\n\n\nR&gt; ✔    Reading Sheet LTN 010123\n\n\nR&gt; ✔    Reading Sheet LTN 010125\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2020.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010121\n\n\nR&gt; ✔    Reading Sheet LTN 010122\n\n\nR&gt; ✔    Reading Sheet LTN 010123\n\n\nR&gt; ✔    Reading Sheet LTN 010125\n\n\nR&gt; ✔    Reading Sheet LTN 010126\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2021.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010122\n\n\nR&gt; ✔    Reading Sheet LTN 010123\n\n\nR&gt; ✔    Reading Sheet LTN 010724\n\n\nR&gt; ✔    Reading Sheet LTN 010125\n\n\nR&gt; ✔    Reading Sheet LTN 010126\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2022.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010123\n\n\nR&gt; ✔    Reading Sheet LTN 010724\n\n\nR&gt; ✔    Reading Sheet LTN 010125\n\n\nR&gt; ✔    Reading Sheet LTN 010126\n\n\nR&gt; ✔    Reading Sheet LTN 010129\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2023.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010724\n\n\nR&gt; ✔    Reading Sheet LTN 010125\n\n\nR&gt; ✔    Reading Sheet LTN 010126\n\n\nR&gt; ✔    Reading Sheet LTN 010129\n\n\nR&gt; ℹ Reading '/tmp/Rtmp5tTg1S/td-files/LTN/LTN_2024.xls'\n\n\nR&gt; ✔    Reading Sheet LTN 010724\n\n\nR&gt; ✔    Reading Sheet LTN 010125\n\n\nR&gt; ✔    Reading Sheet LTN 010126\n\n\nR&gt; ✔    Reading Sheet LTN 010129\n\n# remove data prior to 2010\ndf_TD &lt;- dplyr::filter(df_TD,\n                       ref_date &gt;= as.Date('2010-01-01'))\n\nApós a importação das informações, plotamos os preços dos diferentes ativos:\n\n\n\n\n\nNote como todos contratos do tipo LTN terminam com valor R$ 1.000 em sua data de expiração e possuem uma dinâmica linear de crescimento de preço ao longo do tempo.\nOutra funcionalidade do pacote {GetTDData} (M. Perlin 2023a) é o acesso a curva de juros atual do sistema financeiro brasileiro diretamente do site da Anbima. Para isso, basta utilizar a função get.yield.curve:\n\n\nlibrary(GetTDData)\n\n# get yield curve\ndf_yield &lt;- get.yield.curve()\n\n# check result\ndplyr::glimpse(df_yield)\n\nR&gt; Rows: 111\nR&gt; Columns: 5\nR&gt; $ n.biz.days   &lt;dbl&gt; 252, 378, 504, 630, 756, 882, 1008, 1…\nR&gt; $ type         &lt;chr&gt; \"real_return\", \"real_return\", \"real_r…\nR&gt; $ value        &lt;dbl&gt; 5.6837, 5.3658, 5.2534, 5.2275, 5.236…\nR&gt; $ ref.date     &lt;date&gt; 2025-01-07, 2025-07-10, 2026-01-06, …\nR&gt; $ current.date &lt;date&gt; 2024-01-09, 2024-01-09, 2024-01-09, …\n\n\nOs dados incluem a curva de juros nominal, juros real e da inflação. Para melhor visualizar as informações, vamos plotá-las em um gráfico:\n\n\n\n\n\nA curva de juros é uma ferramente utilizada no mercado financeiro com o propósito de representar graficamente a expectatica do mercado sobre juros futuro. Baseada nos preços dos títulos públicos, calcula-se e extrapola-se o juros implícito para cada período futuro. Uma curva ascendente, o formato esperado, indica que é mais caro (maior o juro) tomar dinheiro emprestado no longo prazo."
  },
  {
    "objectID": "07-importacao-internet.html#pacote-getbcbdata-r-getbcbdata",
    "href": "07-importacao-internet.html#pacote-getbcbdata-r-getbcbdata",
    "title": "7  Importação de Dados via Pacotes",
    "section": "7.3 Pacote {GetBCBData} (M. Perlin 2022)",
    "text": "7.3 Pacote {GetBCBData} (M. Perlin 2022)\nO Banco Central Brasileiro (BCB) disponibiliza em seu Sistema de Séries Temporais (SGS) uma vasta quantidade de tabelas relativas a economia do Brasil. Mais importante, estas tabelas são atualizadas constantemente e o acesso é gratuito e sem necessidade de registro.\nComo um exemplo, vamos usar o pacote para estudar a inadimplência de crédito no sistema financeiro Brasileiro. O primeiro passo no uso de {GetBCBData} (M. Perlin 2022) é procurar o símbolo da série de interesse. Acessando o sistema de séries temporais do BCB, vemos que o código identificador para o percentual total de inandimplência no Brasil é 21082.\nNo código, basta indicar a série de interesse e o período de tempo desejado:\n\nlibrary(GetBCBData)\nlibrary(dplyr)\n\n# set ids and dates\nid_series &lt;- c(perc_default = 21082)\nfirst_date = '2010-01-01'\n\n# get series from bcb\ndf_cred &lt;- gbcbd_get_series(id = id_series,\n                            first.date = first_date,\n                            last.date = Sys.Date(), \n                            use.memoise = FALSE)\n\nR&gt; \nR&gt; Fetching perc_default [21082] from BCB-SGS from Online API \nR&gt;   Found 153 observations\n\n# check it\nglimpse(df_cred)\n\nR&gt; Rows: 153\nR&gt; Columns: 4\nR&gt; $ ref.date    &lt;date&gt; 2011-03-01, 2011-04-01, 2011-05-01, 2…\nR&gt; $ value       &lt;dbl&gt; 3.17, 3.24, 3.37, 3.32, 3.42, 3.45, 3.…\nR&gt; $ id.num      &lt;dbl&gt; 21082, 21082, 21082, 21082, 21082, 210…\nR&gt; $ series.name &lt;chr&gt; \"perc_default\", \"perc_default\", \"perc_…\n\n\nNote que indicamos o nome da coluna na própria definição da entrada id. Assim, coluna series.name toma o nome de perc.default. Esta configuração é importante pois irá diferenciar os dados no caso da importação de diversas séries diferentes. O gráfico apresentado a seguir mostra o valor da série no tempo:\n\n\n\n\n\nComo podemos ver, a percentagem de inadimplência aumentou a partir de 2015. Para ter uma idéia mais clara do problema, vamos incluir no gráfico a percentagem para pessoa física e pessoa jurídica. Olhando novamente o sistema do BCB, vemos que o símbolos de interesse são 21083 e 21084, respectivamente. O próximo código baixa os dados das duas séries.\n\n# set ids\nid.series &lt;- c(credit_default_people = 21083,\n               credit_default_companies = 21084)\nfirst.date = '2010-01-01'\n\n# get series from bcb\ndf_cred &lt;- gbcbd_get_series(id = id.series,\n                            first.date = first.date,\n                            last.date = Sys.Date(), \n                            use.memoise = FALSE)\n\nR&gt; \nR&gt; Fetching credit_default_people [21083] from BCB-SGS from Online API \nR&gt;   Found 153 observations\nR&gt; Fetching credit_default_companies [21084] from BCB-SGS from Online API \nR&gt;   Found 153 observations\n\n# check output\nglimpse(df_cred)\n\nR&gt; Rows: 306\nR&gt; Columns: 4\nR&gt; $ ref.date    &lt;date&gt; 2011-03-01, 2011-04-01, 2011-05-01, 2…\nR&gt; $ value       &lt;dbl&gt; 1.96, 2.04, 2.15, 2.09, 2.18, 2.15, 2.…\nR&gt; $ id.num      &lt;dbl&gt; 21083, 21083, 21083, 21083, 21083, 210…\nR&gt; $ series.name &lt;chr&gt; \"credit_default_people\", \"credit_defau…\n\n\nA diferença na saída do código anterior é que agora temos duas séries temporais empilhadas no mesmo dataframe. Partimos então para a visualização das séries\n\n\n\n\n\nComo podemos ver, a inadimplência de crédito para pessoa física aumentou muito mais do que a para pessoa jurídica (empresas) nos últimos anos. Poderiámos, facilmente, integrar o código anterior para uma análise mais completa dos dados em algum problema de pesquisa.\n\n\n\n\n\n\nImportante\n\n\n\nO sistema BCB-SGS é local obrigatório para qualquer economista sério. A quantidade e variedade de dados é imensa. Podes usar os dados do sistema para automatizar qualquer tipo de relatório econômico."
  },
  {
    "objectID": "07-importacao-internet.html#pacote-getdfpdata2-r-getdfpdata2",
    "href": "07-importacao-internet.html#pacote-getdfpdata2-r-getdfpdata2",
    "title": "7  Importação de Dados via Pacotes",
    "section": "7.4 Pacote {GetDFPData2} (M. Perlin and Kirch 2023)",
    "text": "7.4 Pacote {GetDFPData2} (M. Perlin and Kirch 2023)\nPacote {GetDFPData2} (M. Perlin and Kirch 2023) (M. Perlin and Kirch 2023) é uma evolução do pacote GetDFPData (R-GetDFPData?) e fornece uma interface aberta para todas as demonstrações financeiras distribuídas pela B3 e pela CVM nos sistemas DFP (dados anuais) e ITR (dados trimestrais). Ele não só faz o download dos dados, mas também ajusta à inflação e torna as tabelas prontas para pesquisa dentro de um formato tabular. Os diferenciais do pacote em relação a outros distribuidores de dados comerciais são: livre acesso, facilidade para baixar dados em larga escala e a variedade de dados disponíveis.\n\n\n\n\n\n\nImportante\n\n\n\nDados históricos completos e atualizados a partir de 2010 do DFP e ITR estão disponibilizados na seção Data do meu site pessoal. Estes dados são atualizados anualmente.\n\n\nO ponto de partida no uso de {GetDFPData2} (M. Perlin and Kirch 2023) é baixar informações atuais sobre empresas disponíveis. O acesso a tabela é possível com a função get_info_companies: \n\nlibrary(GetDFPData2)\n\n# get info for companies in B3\ndf_info &lt;- get_info_companies()\n\nR&gt; Fetching info on B3 companies\n\n\nR&gt;  Dowloading file from CVM\n\n\nR&gt;  File not found, downloading it..\n\n\nR&gt;  Success\n\n\nR&gt;  Reading file from CVM\n\n\nR&gt;  Saving cache data\n\n\nR&gt;  Got 2595 lines for 2461 companies [Actives = 699 Inactives = 1774]\n\n# check it\nnames(df_info)\n\nR&gt;  [1] \"CNPJ\"               \"DENOM_SOCIAL\"      \nR&gt;  [3] \"DENOM_COMERC\"       \"DT_REG\"            \nR&gt;  [5] \"DT_CONST\"           \"DT_CANCEL\"         \nR&gt;  [7] \"MOTIVO_CANCEL\"      \"SIT_REG\"           \nR&gt;  [9] \"DT_INI_SIT\"         \"CD_CVM\"            \nR&gt; [11] \"SETOR_ATIV\"         \"TP_MERC\"           \nR&gt; [13] \"CATEG_REG\"          \"DT_INI_CATEG\"      \nR&gt; [15] \"SIT_EMISSOR\"        \"DT_INI_SIT_EMISSOR\"\nR&gt; [17] \"CONTROLE_ACIONARIO\" \"TP_ENDER\"          \nR&gt; [19] \"LOGRADOURO\"         \"COMPL\"             \nR&gt; [21] \"BAIRRO\"             \"MUN\"               \nR&gt; [23] \"UF\"                 \"PAIS\"              \nR&gt; [25] \"CEP\"                \"DDD_TEL\"           \nR&gt; [27] \"TEL\"                \"DDD_FAX\"           \nR&gt; [29] \"FAX\"                \"EMAIL\"             \nR&gt; [31] \"TP_RESP\"            \"RESP\"              \nR&gt; [33] \"DT_INI_RESP\"        \"LOGRADOURO_RESP\"   \nR&gt; [35] \"COMPL_RESP\"         \"BAIRRO_RESP\"       \nR&gt; [37] \"MUN_RESP\"           \"UF_RESP\"           \nR&gt; [39] \"PAIS_RESP\"          \"CEP_RESP\"          \nR&gt; [41] \"DDD_TEL_RESP\"       \"TEL_RESP\"          \nR&gt; [43] \"DDD_FAX_RESP\"       \"FAX_RESP\"          \nR&gt; [45] \"EMAIL_RESP\"         \"CNPJ_AUDITOR\"      \nR&gt; [47] \"AUDITOR\"\n\n\nEssa tabela disponibiliza os identificadores numéricos das empresas, setores de atividades, atual segmento de governança, tickers negociados na bolsa e situação atual (ativa ou não). O número atual de empresas ativas e inativas, a partir de 2024-01-10, está disponível na coluna SIT_REG. Observa-se 781 empresas ativas e 1811 canceladas. Essa é uma excelente fonte de informação para um estudo exploratório. Pode-se facilmente filtrar empresas para datas, setores, tickers ou segmentos de governança corporativa.\nToda empresa no banco de dados é identificada pelo seu número único da CVM. Função search_company permite que o usuário procure o identificador de uma empresa através de seu nome. Dado um texto de entrada – o nome da empresa –, a função procurará uma correspondência parcial com os nomes de todas as empresas disponíveis no banco de dados. Em seu uso, caracteres latinos e maiúsculas e minúsculas são ignorados. Vamos encontrar o nome oficial nome da Grendene, uma das maiores empresas do Brasil. Para isso, basta usar o comando search_company('grendene').\n\ndf_search &lt;- search_company('grendene')\n\nprint(df_search)\n\nR&gt; # A tibble: 1 × 3\nR&gt;   CD_CVM DENOM_SOCIAL SIT_REG\nR&gt;    &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;  \nR&gt; 1  19615 GRENDENE SA  ATIVO\n\n\nVemos que existe um registro para a Grendene: “GRENDENE SA”, com código identificador equivalente a 19615. \nCom o identificador da empresa disponível, usamos a função principal do pacote, get_dfp_data, para baixar os dados. Definimos o nome oficial da empresa como entrada companies_cvm_codes e o período de tempo como entradas first_year e last_year.\n\n\nlibrary(GetDFPData2)\nlibrary(dplyr)\n\n# set options\nid_companies &lt;- 19615\nfirst_year &lt;- 2017\nlast_year  &lt;- 2018\n\n# download data\nl_dfp &lt;- get_dfp_data(companies_cvm_codes = id_companies,\n                      type_docs = '*', # get all docs  \n                      type_format = 'con', # consolidated\n                      first_year = first_year,\n                      last_year = last_year)\n\nAs mensagens de GetDFPData2::get_dfp_data relatam os estágios do processo, desde a aquisição de dados da tabela de referência ao download e leitura dos arquivos da B3. Observe que os arquivos de três sistemas são acessados: DFP (Demostrativos Financeiros Padronizados), FRE (Formulário de Referência) e FCA (Formulário Cadastral). Observe também o uso de um sistema de cache, o qual acelera significativamente o uso do software ao salvar localmente as informações importadas.\nExplicando as demais entradas da função GetDFPData2::get_dfp_data:\n\ncompanies_cvm_codes\n\nCódigo numérico das empresas (encontrado via GetDFPData2::search_company('ambev'))\n\ntype_docs\n\nSímbolo do tipo de documento financeiro a ser retornado. Definições: ’*’ = retorna todos documentos, ‘BPA’ = Ativo, ‘BPP’ = passivo, ‘DRE’ = demonstrativo de resultados do exercício, ‘DFC_MD’ = fluxo de caixa pelo metodo direto, ‘DFC_MI’ = fluxo de caixa pelo metodo indireto, ‘DMPL’ = mutacoes do patrimonio liquido, ‘DVA’ = demonstrativo de valor agregado.\n\ntype_format\n\nTipo de formato dos documentos: consolidado (‘con’) ou individual (‘ind’). Como regra, dê preferência ao tipo consolidado, o qual incluirá dados completos de subsidiárias.\n\nfirst_year\n\nPrimeiro ano para os dados\n\nlast_year\n\nÚltimo ano para os dados\n\n\nO objeto resultante de get_dfp_data é uma lista com diversas tabelas. Vamos dar uma olhada no conteúdo de l_dfp ao buscar os nomes dos itens da lista, limitando o número de caracteres:\n\nstringr::str_sub(names(l_dfp), 1, 40)\n\nR&gt; [1] \"DF Consolidado - Balanço Patrimonial Ati\"\nR&gt; [2] \"DF Consolidado - Balanço Patrimonial Pas\"\nR&gt; [3] \"DF Consolidado - Demonstração das Mutaçõ\"\nR&gt; [4] \"DF Consolidado - Demonstração de Valor A\"\nR&gt; [5] \"DF Consolidado - Demonstração do Fluxo d\"\nR&gt; [6] \"DF Consolidado - Demonstração do Resulta\"\n\n\nComo podemos ver, os dados retornados são vastos. Cada item da lista em l_dfp é um tabela indexada ao tempo. A explicação de cada coluna não cabe aqui mas, para fins de exemplo, vamos dar uma olhada no balanço patrimonial da empresa, disponível em l_dfp$\"DF Consolidado - Balanço Patrimonial Ativo\":\n\n# save assets in df\nfr_assets &lt;- l_dfp$`DF Consolidado - Balanço Patrimonial Ativo`\n\n# check it\ndplyr::glimpse(fr_assets)\n\nR&gt; Rows: 122\nR&gt; Columns: 16\nR&gt; $ CNPJ_CIA     &lt;chr&gt; \"89.850.341/0001-60\", \"89.850.341/000…\nR&gt; $ CD_CVM       &lt;dbl&gt; 19615, 19615, 19615, 19615, 19615, 19…\nR&gt; $ DT_REFER     &lt;date&gt; 2017-12-31, 2017-12-31, 2017-12-31, …\nR&gt; $ DT_INI_EXERC &lt;date&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, …\nR&gt; $ DT_FIM_EXERC &lt;date&gt; 2017-12-31, 2017-12-31, 2017-12-31, …\nR&gt; $ DENOM_CIA    &lt;chr&gt; \"GRENDENE S.A.\", \"GRENDENE S.A.\", \"GR…\nR&gt; $ VERSAO       &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\nR&gt; $ GRUPO_DFP    &lt;chr&gt; \"DF Consolidado - Balanço Patrimonial…\nR&gt; $ MOEDA        &lt;chr&gt; \"REAL\", \"REAL\", \"REAL\", \"REAL\", \"REAL…\nR&gt; $ ESCALA_MOEDA &lt;chr&gt; \"MIL\", \"MIL\", \"MIL\", \"MIL\", \"MIL\", \"M…\nR&gt; $ ORDEM_EXERC  &lt;chr&gt; \"ÚLTIMO\", \"ÚLTIMO\", \"ÚLTIMO\", \"ÚLTIMO…\nR&gt; $ CD_CONTA     &lt;chr&gt; \"1\", \"1.01\", \"1.01.01\", \"1.01.02\", \"1…\nR&gt; $ DS_CONTA     &lt;chr&gt; \"Ativo Total\", \"Ativo Circulante\", \"C…\nR&gt; $ VL_CONTA     &lt;dbl&gt; 3576008, 2846997, 30119, 1537477, 836…\nR&gt; $ COLUNA_DF    &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\nR&gt; $ source_file  &lt;chr&gt; \"dfp_cia_aberta_BPA_con_2017.csv\", \"d…\n\n\nA exportação dos dados para o Excel também é fácil, basta usar função GetDFPData2::export_xlsx: \n\ntemp_xlsx &lt;- tempfile(fileext = '.xlsx')\n\nexport_xlsx(l_dfp = l_dfp, f_xlsx = temp_xlsx)\n\nR&gt; Warning in writexl::write_xlsx(x = l_dfp, path = f_xlsx):\nR&gt; Truncating sheet name(s) to 31 characters\n\n\nR&gt; Warning in writexl::write_xlsx(x = l_dfp, path = f_xlsx):\nR&gt; Deduplicating sheet names\n\n\nO arquivo Excel resultante conterá cada tabela de l_dpf em uma aba diferente da planilha, com uma truncagem nos nomes. Podemos checar o resultado com função readxl::excel_sheets:\n\nreadxl::excel_sheets(temp_xlsx)\n\nR&gt; [1] \"DF Consolidado - Balanço Pat\"  \nR&gt; [2] \"DF Consolidado - Balanço Pat_1\"\nR&gt; [3] \"DF Consolidado - Demonstraçã\"  \nR&gt; [4] \"DF Consolidado - Demonstraçã_1\"\nR&gt; [5] \"DF Consolidado - Demonstraçã_2\"\nR&gt; [6] \"DF Consolidado - Demonstraçã_3\""
  },
  {
    "objectID": "07-importacao-internet.html#pacote-getfredata-r-getfredata",
    "href": "07-importacao-internet.html#pacote-getfredata-r-getfredata",
    "title": "7  Importação de Dados via Pacotes",
    "section": "7.5 Pacote {GetFREData} (M. Perlin and Kirch 2022)",
    "text": "7.5 Pacote {GetFREData} (M. Perlin and Kirch 2022)\nO pacote {GetFREData} (M. Perlin and Kirch 2022) importa dados do sistema FRE – Formulário de Referência – da bolsa Brasileira, incluindo eventos e informações corporativas tal como composição do conselho e diretoria, remuneração dos conselhos, entre outras.\nA estrutura de uso e a saída das funções de {GetFREData} (M. Perlin and Kirch 2022) são muito semelhante as do pacote {GetDFPData2} (M. Perlin and Kirch 2023). Veja a seguir um exemplo de uso.\n\nlibrary(GetFREData)\n\n# set options\nid_companies &lt;- 23264\nfirst_year &lt;- 2021\nlast_year  &lt;- 2022\n\n# download data\nl_fre &lt;- get_fre_data(companies_cvm_codes = id_companies,\n                      first_year = first_year,\n                      last_year = last_year)\n\nNote que o tempo de execução de get_fre_data é significativo. Isto deve-se ao download e leitura dos arquivos do sistema FRE direto da bolsa. Cada tabela do FRE é importada na lista de saída:\n\nnames(l_fre)\n\nR&gt;  [1] \"df_stockholders\"            \nR&gt;  [2] \"df_capital\"                 \nR&gt;  [3] \"df_stock_values\"            \nR&gt;  [4] \"df_mkt_value\"               \nR&gt;  [5] \"df_increase_capital\"        \nR&gt;  [6] \"df_capital_reduction\"       \nR&gt;  [7] \"df_compensation\"            \nR&gt;  [8] \"df_compensation_summary\"    \nR&gt;  [9] \"df_transactions_related\"    \nR&gt; [10] \"df_other_events\"            \nR&gt; [11] \"df_stock_repurchases\"       \nR&gt; [12] \"df_debt_composition\"        \nR&gt; [13] \"df_board_composition\"       \nR&gt; [14] \"df_committee_composition\"   \nR&gt; [15] \"df_family_relations\"        \nR&gt; [16] \"df_family_related_companies\"\nR&gt; [17] \"df_auditing\"                \nR&gt; [18] \"df_responsible_docs\"        \nR&gt; [19] \"df_stocks_details\"          \nR&gt; [20] \"df_dividends_details\"       \nR&gt; [21] \"df_intangible_details\"\n\n\nPor exemplo, vamos verificar conteúdo da tabela df_board_composition, a qual contém informações sobre os componentes dos conselhos das empresas:\n\nglimpse(l_fre$df_board_composition)\n\nR&gt; Rows: 65\nR&gt; Columns: 22\nR&gt; $ CNPJ_CIA                 &lt;chr&gt; \"07.526.557/0001-00\", \"07…\nR&gt; $ DENOM_CIA                &lt;chr&gt; \"AMBEV S.A.\", \"AMBEV S.A.…\nR&gt; $ DT_REFER                 &lt;date&gt; 2021-01-01, 2021-01-01, …\nR&gt; $ CD_CVM                   &lt;dbl&gt; 23264, 23264, 23264, 2326…\nR&gt; $ ID_DOC                   &lt;dbl&gt; 114809, 114809, 114809, 1…\nR&gt; $ VERSAO                   &lt;dbl&gt; 12, 12, 12, 12, 12, 12, 1…\nR&gt; $ person.name              &lt;chr&gt; \"Leticia Rudge Barbosa Ki…\nR&gt; $ person.cpf               &lt;dbl&gt; 25572648817, 7234352783, …\nR&gt; $ person.profession        &lt;chr&gt; \"Advogada\", \"Engenheiro C…\nR&gt; $ person.cv                &lt;chr&gt; \"Ocupa o cargo de Diretor…\nR&gt; $ person.dob               &lt;date&gt; 1976-06-12, 1977-01-15, …\nR&gt; $ code.type.board          &lt;chr&gt; \"1\", \"1\", \"1\", \"1\", \"1\", …\nR&gt; $ desc.type.board          &lt;chr&gt; \"Director\", \"Director\", \"…\nR&gt; $ desc.type.board2         &lt;chr&gt; \"Diretora Vice-Presidente…\nR&gt; $ code.type.job            &lt;chr&gt; \"19\", \"19\", \"19\", \"19\", \"…\nR&gt; $ desc.job                 &lt;chr&gt; \"Não aplicável, uma vez q…\nR&gt; $ date.election            &lt;date&gt; 2021-12-22, 2021-12-22, …\nR&gt; $ date.effective           &lt;date&gt; 2022-01-01, 2022-01-01, …\nR&gt; $ mandate.duration         &lt;chr&gt; \"31/12/2024\", \"31/12/2024…\nR&gt; $ ellected.by.controller   &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, F…\nR&gt; $ qtd.consecutive.mandates &lt;dbl&gt; 2, 2, 1, 2, 3, 1, 3, 2, 3…\nR&gt; $ percentage.participation &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0…\n\n\nComo podemos ver, para um pesquisador de finanças corporativas, o sistema FRE oferece uma série de informações interessantes. Discutir o conteúdo de cada tabela, porém, vai muito além do propósito dessa seção. Aos interessados, mais detalhes sobre as tabelas do FRE estão disponíveis em (perlin2018accessing?).\n\n\n\n\n\n\nImportante\n\n\n\nNote que a importação dos dados do FRE inclui uma versão dos arquivos. Toda vez que uma empresa modifica as informações oficiais no sistema da B3, uma nova versão do FRE é criada. Devido a isso, é bastante comum que os dados de um ano para uma empresa possua diferentes versões. Para resolver este problema, o código do {GetFREData} (M. Perlin and Kirch 2022), por default, importa a versão mais antiga para cada ano. Caso o usuário queira mudar, basta utilizar a entrada fre_to_read."
  },
  {
    "objectID": "07-importacao-internet.html#outros-pacotes",
    "href": "07-importacao-internet.html#outros-pacotes",
    "title": "7  Importação de Dados via Pacotes",
    "section": "7.6 Outros Pacotes",
    "text": "7.6 Outros Pacotes\nNas seções anteriores destacamos os principais pacotes gratuitos para aquisição de dados financeiros e econômicos no Brasil. Muitos desses foram escritos pelo próprio autor do livro e representam uma pequena parcela da totalidade. Não seria justo ignorar o trabalho de outros autores. Assim, reporto abaixo uma seleção de pacotes que vale a pena conhecer:\n\n7.6.1 Pacotes de Acesso Gratuito\n\nBETS (R-BETS?)\n\nPacote construído e mantido pela equipe da FGV. Permite o acesso aos dados do BCB (Banco Central do Brasil) e IBGE (Instituto Brasileiro de Geografia e Estatística). Também inclui ferramentas para a administração, análise e manipulação dos dados em relatórios técnicos.\n\nsimfinapi (R-simfinapi?)\n\nPacote para acesso ao projeto simfin, incluindo dados financeiros de diversas empresas internacionais. O acesso livre é restrito a um número de chamadas diárias.\n\n\n\n\n7.6.2 Pacotes Comerciais\n\nRblpapi (R-Rblpapi?)\n\nPermite acesso aos dados da Bloomberg, sendo necessário uma conta comercial.\n\nIBrokers (R-IBrokers?)\n\nAPI para o acesso aos dados da Interactive Brokers. Também é necessário uma conta comercial.\n\n\nNo CRAN você encontrará muitos outros. A interface para fontes de dados comerciais também é possível. Várias empresas fornecem APIs para facilitar o envio de dados aos seus clientes. Se a empresa de fornecimento de dados que você usa no trabalho não for apresentada aqui, a lista de pacotes CRAN pode ajudá-lo a encontrar uma alternativa viável."
  },
  {
    "objectID": "07-importacao-internet.html#acessando-dados-de-páginas-na-internet-webscraping",
    "href": "07-importacao-internet.html#acessando-dados-de-páginas-na-internet-webscraping",
    "title": "7  Importação de Dados via Pacotes",
    "section": "7.7 Acessando Dados de Páginas na Internet (Webscraping)",
    "text": "7.7 Acessando Dados de Páginas na Internet (Webscraping)\nOs pacotes destacados anteriormente são muito úteis pois facilitam a importação de dados específicos diretamente da internet. Em muitos casos, porém, os dados de interesse não estão disponíveis via API formal, mas sim em uma página na internet - geralmente no formato de uma tabela. O processo de extrair informações de páginas da internet chama-se webscraping (raspagem de dados). Dependendo da estrutura e da tecnologia da página da web acessada, importar essas informações diretamente para o R pode ser um procedimento trivial – mas também pode se tornar um processo extremamente trabalhoso. Como um exemplo, a seguir vamos raspar dados do Wikipedia sobre a composição do índice SP500.\n\n7.7.1 Raspando Dados do Wikipedia\nEm seu site, a Wikipedia oferece uma seção2 com os componentes do Índice SP500. Essas informações são apresentadas em um formato tabular, Figura @ref(fig:SP500-wikipedia).\n\n\n\n\n\nImagem da página do Wikipedia\n\n\n\n\nAs informações desta página são constantemente atualizadas, e podemos utilizá-las para importar informações sobre as ações pertencentes ao índice SP500. Antes de nos aprofundarmos no código R, precisamos entender como uma página da web funciona. Resumidamente, uma página da web nada mais é do que uma árvore com nódulos, representada por um código HTML (Hypertext Markup Language) extenso interpretado pelo seu navegador. Um valor numérico ou texto apresentado no site geralmente pode ser encontrado dentro do próprio código. Este código tem uma estrutura particular em forma de árvore com ramificações, classes, nomes e identificadores. Além disso, cada elemento de uma página da web possui um endereço, denominado xpath. Nos navegadores Chrome e Firefox, você pode ver o código HTML de uma página da web usando o mouse. Para isto, basta clicar com o botão direito em qualquer parte da página e selecionar View Page Source (ou “Ver Código Fonte”).\nA primeira etapa do processo de raspagem de dados é descobrir a localização das informações de que você precisa. No navegador Chrome, você pode fazer isso clicando com o botão direito no local específico do número/texto no site e selecionando inspect. Isso abrirá uma janela extra no navegador a direita. Depois de fazer isso, clique com o botão direito na seleção e escolha copy e copy xpath. Na Figura @ref(fig:SP500-Wikipedia-webscraping), vemos um espelho do que você deve estar vendo em seu navegador.\n\n\n\n\n\nEncontrando o xpath da tabela\n\n\n\n\nAqui, o texto copiado é:\n\n'//*[@id=\"mw-content-text\"]/table[1]/thead/tr/th[2]'\n\nEste é o endereço do cabeçalho da tabela. Para todo o conteúdo da tabela, incluindo cabeçalho, linhas e colunas, precisamos definir um nível superior da árvore. Isso é equivalente ao endereço //*[@id =\" mw-content-text\"]/table[1].\nAgora que temos a localização do que queremos, vamos carregar o pacote rvest (R-rvest?) e usar as funções read_html, html_nodes ehtml_table para importar a tabela desejada para o R: \n\nlibrary(rvest)\n\n# set url and xpath\nmy_url &lt;- 'https://en.wikipedia.org/wiki/List_of_S%26P_500_companies'\nmy_xpath &lt;- '//*[@id=\"mw-content-text\"]/div/table[1]'\n\n# get nodes from html\nout_nodes &lt;- html_nodes(read_html(my_url),\n                        xpath = my_xpath)\n\n# get table from nodes (each element in \n# list is a table)\ndf_SP500_comp &lt;- html_table(out_nodes)\n\n# isolate it \ndf_SP500_comp &lt;- df_SP500_comp[[1]]\n\n# change column names (remove space)\nnames(df_SP500_comp) &lt;- make.names(names(df_SP500_comp))\n\n# print it\nglimpse(df_SP500_comp)\n\nR&gt; Rows: 503\nR&gt; Columns: 8\nR&gt; $ Symbol                &lt;chr&gt; \"MMM\", \"AOS\", \"ABT\", \"ABBV\",…\nR&gt; $ Security              &lt;chr&gt; \"3M\", \"A. O. Smith\", \"Abbott…\nR&gt; $ GICS.Sector           &lt;chr&gt; \"Industrials\", \"Industrials\"…\nR&gt; $ GICS.Sub.Industry     &lt;chr&gt; \"Industrial Conglomerates\", …\nR&gt; $ Headquarters.Location &lt;chr&gt; \"Saint Paul, Minnesota\", \"Mi…\nR&gt; $ Date.added            &lt;chr&gt; \"1957-03-04\", \"2017-07-26\", …\nR&gt; $ CIK                   &lt;int&gt; 66740, 91142, 1800, 1551152,…\nR&gt; $ Founded               &lt;chr&gt; \"1902\", \"1916\", \"1888\", \"201…\n\n\nO objeto df_SP500_comp contém um espelho dos dados do site da Wikipedia. Os nomes das colunas requerem algum trabalho de limpeza, mas o principal está ali. Observe como a saída é semelhante aos dados da função BatchGetSymbols::GetSP500Stocks. A razão é simples, ambas buscaram a informação na mesma origem. A diferença é que função GetSP500Stocks vai um passo além, limpando os dados importados."
  },
  {
    "objectID": "07-importacao-internet.html#exerc-importacao-pacotes",
    "href": "07-importacao-internet.html#exerc-importacao-pacotes",
    "title": "7  Importação de Dados via Pacotes",
    "section": "7.8 Exercícios",
    "text": "7.8 Exercícios\n\n\n\n\nPerlin, Marcelo. 2022. GetBCBData: Imports Datasets from BCB (Central Bank of Brazil) Using Its Official API. https://github.com/msperlin/GetBCBData/.\n\n\n———. 2023a. GetTDData: Get Data for Brazilian Bonds (Tesouro Direto). https://github.com/msperlin/GetTDData/.\n\n\n———. 2023b. yfR: Downloads and Organizes Financial Data from Yahoo Finance. https://github.com/ropensci/yfR.\n\n\nPerlin, Marcelo S. 2023. GetQuandlData: Fast and Cached Import of Data from Quandl Using the Json API. https://github.com/msperlin/GetQuandlData/.\n\n\nPerlin, Marcelo, and Guilherme Kirch. 2022. GetFREData: Reading FRE Corporate Data of Public Traded Companies from B3. https://github.com/msperlin/GetFREData/.\n\n\n———. 2023. GetDFPData2: Reading Annual and Quarterly Financial Reports from B3. https://github.com/msperlin/GetDFPData2/.\n\n\nWickham, Hadley. 2023. Tidyverse: Easily Install and Load the Tidyverse. https://tidyverse.tidyverse.org."
  },
  {
    "objectID": "07-importacao-internet.html#footnotes",
    "href": "07-importacao-internet.html#footnotes",
    "title": "7  Importação de Dados via Pacotes",
    "section": "",
    "text": "O cupom é um pagamento intermediário pago periodicamente durante a validade do contrato financeiro.↩︎\nhttps://en.wikipedia.org/wiki/List_of_S%26P_500_companies↩︎"
  },
  {
    "objectID": "08-objetos-armazenamento.html#dataframes",
    "href": "08-objetos-armazenamento.html#dataframes",
    "title": "8  Dataframes e outros Objetos",
    "section": "8.1 Dataframes",
    "text": "8.1 Dataframes\nTraduzindo para o português, dataframe significa “estrutura ou organização de dados”. Grosso modo, um objeto da classe dataframe nada mais é do que uma tabela com linhas e colunas. Sem dúvida, o dataframe é o principal objeto utilizado no trabalho com o R e o mais importante de se estudar. Dados externos são, grande maioria dos casos, importados para o R no formato de tabelas. É na manipulação desses que gastará maior parte do tempo realizando a sua análise. Internamente, um dataframe é um tipo especial de lista, onde cada coluna é um vetor atômico com o mesmo número de elementos, porém com sua própria classe. Podemos organizar em um dataframe dados de texto juntamente com números, por exemplo.\nNote que o formato tabular força a sincronização dos dados no sentido de linhas, isto é, cada caso de cada variável deve ser pareado com casos de outras variáveis. Apesar de simples, esse tipo de estruturação de dados é intuitiva e pode acomodar uma variedade de informações. Cada acréscimo de dados (informações) incrementa as linhas e cada novo tipo de informação incrementa as colunas da tabela.\nUm dos pontos positivos na utilização do dataframe para a acomodação de dados é que funções de diferentes pacotes irão funcionar a partir dessa classe de objetos. Por exemplo, o pacote de manipulação de dados {dplyr} (Wickham et al. 2023), assim como o pacote de criação de figuras ggplot2, funcionam a partir de um dataframe. Esse objeto, portanto, está no centro de uma série de funcionalidades do R e, sem dúvida, é uma classe de objeto extremamente importante para aprender a utilizar corretamente.\nO objeto dataframe é uma das classes nativas do R e vem implementado no pacote {base} (R Core Team 2023). Entretanto, o universe {tidyverse} (Wickham 2023) oferece sua própria versão de um dataframe, chamada tibble, a qual é utilizada sistematicamente em todos pacotes do {tidyverse} (Wickham 2023). A conversão de um dataframe para tibble é interna e automática. O tibble possui propriedades mais flexíveis que dataframes nativos, facilitando de forma significativa o seu uso. Seguindo a nossa preferência para o {tidyverse} (Wickham 2023), a partir de agora iremos utilizar tibbles como representantes de dataframes.\n\n8.1.1 Criando dataframes\nA criação de um dataframe do tipo tibble ocorre a partir da função tibble. Note que a criação de um dataframe nativo ocorre com a função data.frame() , enquanto a criação do tibble parte da função tibble::tibble ou dplyr::tibble() . Para manter o código mais limpo, iremos dar preferência a dplyr::tibble() e utilizar o nome dataframe para se referir a um tibble. Veja o exemplo a seguir, onde criamos uma tabela correspondente a dados financeiros de diferentes ações.\n\n# set tickers\nticker &lt;- c(rep('ABEV3',4),\n            rep('BBAS3', 4),\n            rep('BBDC3', 4))\n\n# set dates\nref_date &lt;- as.Date(rep(c('2010-01-01', '2010-01-04',\n                          '2010-01-05', '2010-01-06'),\n                        3) )\n\n# set prices\nprice &lt;- c(736.67, 764.14, 768.63, 776.47,\n           59.4  , 59.8  , 59.2  , 59.28,\n           29.81 , 30.82 , 30.38 , 30.20)\n\n# create tibble/dataframe\nmy_df &lt;- tibble::tibble(ticker, ref_date , price)\n\n# print it\nprint(my_df)\n\nR&gt; # A tibble: 12 × 3\nR&gt;    ticker ref_date   price\nR&gt;    &lt;chr&gt;  &lt;date&gt;     &lt;dbl&gt;\nR&gt;  1 ABEV3  2010-01-01 737. \nR&gt;  2 ABEV3  2010-01-04 764. \nR&gt;  3 ABEV3  2010-01-05 769. \nR&gt;  4 ABEV3  2010-01-06 776. \nR&gt;  5 BBAS3  2010-01-01  59.4\nR&gt;  6 BBAS3  2010-01-04  59.8\nR&gt;  7 BBAS3  2010-01-05  59.2\nR&gt;  8 BBAS3  2010-01-06  59.3\nR&gt;  9 BBDC3  2010-01-01  29.8\nR&gt; 10 BBDC3  2010-01-04  30.8\nR&gt; 11 BBDC3  2010-01-05  30.4\nR&gt; 12 BBDC3  2010-01-06  30.2\n\n\nObserve que utilizamos a função rep() para replicar e facilitar a criação dos dados do dataframe anterior. Assim, não é necessário repetir os valores múltiplas vezes. Destaca-se que, no uso dos dataframes, podemos salvar todos os nossos dados em um único objeto, facilitando o acesso e a organização do código resultante.\n\n\n\n\n\n\nDica\n\n\n\nO conteúdo de dataframes também pode ser visualizado no próprio RStudio. Para isso, basta clicar no nome do objeto na aba environment, canto superior direito da tela. Após isso, um visualizador aparecerá na tela principal do programa. Essa operação é nada mais que uma chamada a função View() . Portanto, poderíamos visualizar o dataframe anterior executando o comando View(my_df).\n\n\n\n\n8.1.2 Inspecionando um dataframe\nApós a criação do dataframe, o segundo passo é conhecer o seu conteúdo. Particularmente, é importante tomar conhecimento dos seguintes itens em ordem de importância:\n\nNúmero de linhas e colunas\n\nO número de linhas e colunas da tabela resultante indicam se a operação de importação foi executada corretamente. Caso os valores forem diferentes do esperado, deve-se checar o arquivo de importação dos dados e se as opções de importação fazem sentido para o arquivo.\n\nNomes das colunas\n\nÉ importante que a tabela importada tenha nomes que façam sentido e que sejam fáceis de acessar. Portanto, o segundo passo na inspeção de um dataframe é analisar os nomes das colunas e seus respectivos conteúdos. Confirme que cada coluna realmente apresenta um nome intuitivo e relacionado ao problema.\n\nClasses das colunas\n\nCada coluna de um dataframe tem sua própria classe. É de suma importância que as classes dos dados estejam corretamente especificadas. Caso contrário, operações futuras podem resultar em um erro. Por exemplo, caso um vetor de valores numéricos seja importado com a classe de texto (character), qualquer operação matemática nesse vetor irá resultar em um erro no R.\n\nExistência de dados omissos (NA)\n\nDevemos também verificar o número de valores NA (not available) nas diferentes colunas. Sempre que você encontrar uma grande proporção de valores NA na tabela importada, você deve descobrir o que está acontecendo e se a informação está sendo importada corretamente. Conforme mencionado no capítulo anterior, os valores NA são contagiosos e transformarão qualquer objeto que interagir com um NA, também se tornará um NA.\n\n\nUma das funções mais recomendadas para se familiarizar com um dataframe é dplyr::glimpse() . Essa mostra na tela o nome e a classe das colunas, além do número de linhas/colunas. Abusamos dessa função nos capítulos anteriores. Veja um exemplo simples a seguir:\n\nlibrary(dplyr)\n\n# check content of my_df\nglimpse(my_df)\n\nR&gt; Rows: 12\nR&gt; Columns: 3\nR&gt; $ ticker   &lt;chr&gt; \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS…\nR&gt; $ ref_date &lt;date&gt; 2010-01-01, 2010-01-04, 2010-01-05, 2010…\nR&gt; $ price    &lt;dbl&gt; 736.67, 764.14, 768.63, 776.47, 59.40, 59…\n\n\nEm muitas situações, o uso de dplyr::glimpse() é suficiente para entender se o processo de importação de dados ocorreu de forma satisfatória. Porém, uma análise mais profunda é entender qual a variação de cada coluna nos dados importados. Aqui entra o papel da função summary() :\n\n# check variation my_df\nsummary(my_df)\n\nR&gt;     ticker             ref_date              price       \nR&gt;  Length:12          Min.   :2010-01-01   Min.   : 29.81  \nR&gt;  Class :character   1st Qu.:2010-01-03   1st Qu.: 30.71  \nR&gt;  Mode  :character   Median :2010-01-04   Median : 59.34  \nR&gt;                     Mean   :2010-01-04   Mean   :283.73  \nR&gt;                     3rd Qu.:2010-01-05   3rd Qu.:743.54  \nR&gt;                     Max.   :2010-01-06   Max.   :776.47\n\n\nNote que summary() interpreta cada coluna de forma diferente. Para o primeiro caso, coluna ticker, mostra apenas o tamanho do vetor. No caso de datas e valores numéricos, essa apresenta o máximo, mínimo, mediana e quartis. Por exemplo, uma observação extrema (outlier) poderia ser facilmente identificada na análise da saída textual de summary() .\nUma alternativa moderna para summary() é skimr::skim() , que fornece mais detalhes sobre os dados:\n\n# Check content of my_df\nskimr::skim(my_df)\n\nVocê não só obtém as classes das colunas, mas também mais informações sobre as diferentes classes de dados:\n\nPara a coluna tickers, você obtém o número de casos ausentes, valores únicos e mais;\nPara a coluna dates, você obtém o mínimo e o máximo de dados, bem como o número de datas disponíveis;\nPara colunas de valores numéricos, você obtém média, desvio padrão e quantis e mais;\n\nEmbora não seja suficiente, uma simples chamada a skimr::skim() pode fornecer uma grande quantidade de informações sobre os dados sendo importados.\n\n\n\n\n\n\nDica\n\n\n\nToda vez que se deparar com um novo dataframe no R, pegue o hábito de verificar o seu conteúdo com funções dplyr::glimpse() e skimr::skim() . Assim, poderá perceber problemas de importação e/ou conteúdo dos arquivos lidos. Com experiência irás perceber que muitos erros futuros em código podem ser sanados por uma simples inspeção das tabelas importadas.\n\n\n\n\n8.1.3 Operador de pipeline\nO operador de pipeline (ou sequenciamento, em tradução livre) é uma ferramenta fundamental na análise de dados com R. Resumidamente, ele permite que operações de dados sejam realizadas sequencialmente e de forma modular, aumentando a legibilidade e a facilidade de manutenção do código resultante. O operador é amplamente utilizado no pacote {tidyverse} (Wickham 2023) e foi proposto pela primeira vez no pacote r cite_pkg(“magrittr”) com o símbolo %&gt;%. Recentemente, na versão 4.1 do R, lançada em 18 de maio de 2021, um novo operador pipe (nativo) foi introduzido (|&gt;), facilitando seu uso por todos.\nPara explicar melhor, imagine uma situação onde temos três funções para aplicar nos dados salvos em um dataframe. Cada função depende da saída de outra função. Isso requer o encadeamento de suas chamadas. Usando o operador de pipeline, podemos escrever o procedimento de manipulação dataframe com o seguinte código:\n\nmy_tab &lt;- my_df |&gt;\n  fct1(arg1) |&gt;\n  fct2(arg2) |&gt;\n  fct3(arg3)\n\nUsamos símbolo |&gt; no final de cada linha para vincular as operações. As funções fct* são operações realizadas em cada etapa. O resultado de cada linha é passado para a próxima função de forma sequencial. Assim, não há necessidade de criar objetos intermediários. Veja a seguir duas formas alternativas de realizar a mesma operação sem o operador de pipeline:\n\n# version 1\nmy_tab &lt;- fct3(fct2(fct1(my_df,\n                         arg1),\n                    arg2),\n               arg1)\n\n# version 2\ntemp1 &lt;- fct1(my_df, arg1)\ntemp2 &lt;- fct2(temp1, arg2)\nmy_tab &lt;- fct3(temp1, arg3)\n\nObserve como as alternativas formam um código com estrutura estranha e passível a erros. Provavelmente não deves ter notado, mas ambos os códigos possuem erros de digitação. Para o primeiro, o último arg1 deveria ser arg3 e, no segundo, a função fct3 está usando o dataframe temp1 e não temp2. Este exemplo deixa claro como o uso de pipelines torna o código mais elegante e legível. A partir de agora iremos utilizar o operador |&gt; de forma extensiva.\n\n\n8.1.4 Acessando Colunas\nUm objeto do tipo dataframe utiliza-se de diversos comandos e símbolos que também são usados em matrizes e listas. Para descobrir os nomes das colunas de um dataframe, temos duas funções: names() ou colnames() :\n\n# check names of df\nnames(my_df)\n\nR&gt; [1] \"ticker\"   \"ref_date\" \"price\"\n\ncolnames(my_df)\n\nR&gt; [1] \"ticker\"   \"ref_date\" \"price\"\n\n\nAmbas também podem ser usadas para modificar os nomes das colunas:\n\n# set temp df\ntemp_df &lt;- my_df\n\n# check names\nnames(temp_df)\n\nR&gt; [1] \"ticker\"   \"ref_date\" \"price\"\n\n# change names\nnames(temp_df) &lt;- paste0('Col', 1:ncol(temp_df))\n\n# check names\nnames(temp_df)\n\nR&gt; [1] \"Col1\" \"Col2\" \"Col3\"\n\n\nDestaca-se que a forma de usar names() é bastante distinta das demais funções do R. Nesse caso, utilizamos a função ao lado esquerdo do símbolo de assign (&lt;-). Internamente, o que estamos fazendo é definindo um atributo do objeto temp_df, o nome de suas colunas.\nPara acessar uma determinada coluna, podemos utilizar o nome da mesma de diversas formas:\n\n# isolate columns of df\nmy_ticker &lt;- my_df$ticker\nmy_prices &lt;- my_df[['price']]\n\n# print contents\nprint(my_ticker)\n\nR&gt;  [1] \"ABEV3\" \"ABEV3\" \"ABEV3\" \"ABEV3\" \"BBAS3\" \"BBAS3\" \"BBAS3\"\nR&gt;  [8] \"BBAS3\" \"BBDC3\" \"BBDC3\" \"BBDC3\" \"BBDC3\"\n\nprint(my_prices)\n\nR&gt;  [1] 736.67 764.14 768.63 776.47  59.40  59.80  59.20  59.28\nR&gt;  [9]  29.81  30.82  30.38  30.20\n\n\n\n\n\n\n\n\nCuidado!\n\n\n\nToda vez que estiver acessando colunas de um dataframe, o resultado é um vetor atômico com os dados da coluna. Isso é importante saber pois as propriedades do objeto se modificam.\n\n\nNote o uso do duplo colchetes ([[]]) para selecionar colunas. Vale apontar que, no R, um objeto da classe dataframe é representado internamente como uma lista, onde cada elemento é uma coluna. Isso é importante saber, pois alguns comandos de listas também funcionam para dataframes. Um exemplo é o uso de duplo colchetes ([[]]) para selecionar colunas por posição:\n\nprint(my_df[[2]])\n\nR&gt;  [1] \"2010-01-01\" \"2010-01-04\" \"2010-01-05\" \"2010-01-06\"\nR&gt;  [5] \"2010-01-01\" \"2010-01-04\" \"2010-01-05\" \"2010-01-06\"\nR&gt;  [9] \"2010-01-01\" \"2010-01-04\" \"2010-01-05\" \"2010-01-06\"\n\n\nPara acessar linhas e colunas específicas de um dataframe, basta utilizar colchetes simples:\n\nprint(my_df[1:5,2])\n\nR&gt; # A tibble: 5 × 1\nR&gt;   ref_date  \nR&gt;   &lt;date&gt;    \nR&gt; 1 2010-01-01\nR&gt; 2 2010-01-04\nR&gt; 3 2010-01-05\nR&gt; 4 2010-01-06\nR&gt; 5 2010-01-01\n\n\n\nprint(my_df[1:5,c(1,2)])\n\nR&gt; # A tibble: 5 × 2\nR&gt;   ticker ref_date  \nR&gt;   &lt;chr&gt;  &lt;date&gt;    \nR&gt; 1 ABEV3  2010-01-01\nR&gt; 2 ABEV3  2010-01-04\nR&gt; 3 ABEV3  2010-01-05\nR&gt; 4 ABEV3  2010-01-06\nR&gt; 5 BBAS3  2010-01-01\n\n\n\nprint(my_df[1:5, ])\n\nR&gt; # A tibble: 5 × 3\nR&gt;   ticker ref_date   price\nR&gt;   &lt;chr&gt;  &lt;date&gt;     &lt;dbl&gt;\nR&gt; 1 ABEV3  2010-01-01 737. \nR&gt; 2 ABEV3  2010-01-04 764. \nR&gt; 3 ABEV3  2010-01-05 769. \nR&gt; 4 ABEV3  2010-01-06 776. \nR&gt; 5 BBAS3  2010-01-01  59.4\n\n\nEssa seleção de colunas também pode ser realizada utilizando o nome das mesmas da seguinte forma:\n\nprint(my_df[1:3, c('ticker','price')])\n\nR&gt; # A tibble: 3 × 2\nR&gt;   ticker price\nR&gt;   &lt;chr&gt;  &lt;dbl&gt;\nR&gt; 1 ABEV3   737.\nR&gt; 2 ABEV3   764.\nR&gt; 3 ABEV3   769.\n\n\nou, pelo operador de pipeline e a função dplyr::select() :\n\nlibrary(dplyr)\n\nmy.temp &lt;- my_df |&gt;\n  select(ticker, price) |&gt;\n  glimpse()\n\nR&gt; Rows: 12\nR&gt; Columns: 2\nR&gt; $ ticker &lt;chr&gt; \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS3\"…\nR&gt; $ price  &lt;dbl&gt; 736.67, 764.14, 768.63, 776.47, 59.40, 59.8…\n\n\n\n\n8.1.5 Modificando um dataframe\nPara criar novas colunas em um dataframe, basta utilizar a função dplyr::mutate() . Aqui iremos abusar do operador de pipeline (|&gt;) para sequenciar as operações:\n\nlibrary(dplyr)\n\n# add columns with mutate\nmy_df &lt;- my_df |&gt;\n  mutate(ret = price/lag(price) -1,\n         my_seq1 = 1:nrow(my_df),\n         my_seq2 =  my_seq1 +9) |&gt;\n  glimpse()\n\nR&gt; Rows: 12\nR&gt; Columns: 6\nR&gt; $ ticker   &lt;chr&gt; \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS…\nR&gt; $ ref_date &lt;date&gt; 2010-01-01, 2010-01-04, 2010-01-05, 2010…\nR&gt; $ price    &lt;dbl&gt; 736.67, 764.14, 768.63, 776.47, 59.40, 59…\nR&gt; $ ret      &lt;dbl&gt; NA, 0.037289424, 0.005875887, 0.010199966…\nR&gt; $ my_seq1  &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nR&gt; $ my_seq2  &lt;dbl&gt; 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2…\n\n\nNote que precisamos indicar o dataframe de origem dos dados, nesse caso o objeto my_df, e as colunas são definidas como argumentos em dplyr::mutate() . Observe também que usamos a coluna price na construção de ret, o retorno aritmético dos preços. Um caso especial é a construção de my_seq2 com base em my_seq1, isto é, antes mesmo dela ser explicitamente calculada já é possível utilizar a nova coluna para criar outra. Vale salientar que a nova coluna deve ter exatamente o mesmo número de elementos que as demais. Caso contrário, o R retorna uma mensagem de erro.\nA maneira mais tradicional, e comumente encontrada em código, para criar novas colunas é utilizar o símbolo $:\n\n# add new column with base R\nmy_df$my_seq3 &lt;- 1:nrow(my_df)\n\n# check it\nglimpse(my_df)\n\nR&gt; Rows: 12\nR&gt; Columns: 7\nR&gt; $ ticker   &lt;chr&gt; \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS…\nR&gt; $ ref_date &lt;date&gt; 2010-01-01, 2010-01-04, 2010-01-05, 2010…\nR&gt; $ price    &lt;dbl&gt; 736.67, 764.14, 768.63, 776.47, 59.40, 59…\nR&gt; $ ret      &lt;dbl&gt; NA, 0.037289424, 0.005875887, 0.010199966…\nR&gt; $ my_seq1  &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nR&gt; $ my_seq2  &lt;dbl&gt; 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2…\nR&gt; $ my_seq3  &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n\n\nPortanto, o operador $ vale tanto para acessar quanto para criar novas colunas.\nPara remover colunas de um dataframe, basta usar dplyr::select() com operador negativo para o nome das colunas indesejadas:\n\n# removing columns\nmy_df_temp &lt;- my_df |&gt;\n  select(-my_seq1, -my_seq2, -my_seq3) |&gt;\n  glimpse()\n\nR&gt; Rows: 12\nR&gt; Columns: 4\nR&gt; $ ticker   &lt;chr&gt; \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS…\nR&gt; $ ref_date &lt;date&gt; 2010-01-01, 2010-01-04, 2010-01-05, 2010…\nR&gt; $ price    &lt;dbl&gt; 736.67, 764.14, 768.63, 776.47, 59.40, 59…\nR&gt; $ ret      &lt;dbl&gt; NA, 0.037289424, 0.005875887, 0.010199966…\n\n\nNo uso de funções nativas do R, a maneira tradicional de remover colunas é alocar o valor nulo (NULL):\n\n# set temp df\ntemp_df &lt;- my_df\n\n# remove cols\ntemp_df$price &lt;- NULL\ntemp_df$ref_date  &lt;- NULL\n\n# check it\nglimpse(temp_df)\n\nR&gt; Rows: 12\nR&gt; Columns: 5\nR&gt; $ ticker  &lt;chr&gt; \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS3…\nR&gt; $ ret     &lt;dbl&gt; NA, 0.037289424, 0.005875887, 0.010199966,…\nR&gt; $ my_seq1 &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nR&gt; $ my_seq2 &lt;dbl&gt; 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20…\nR&gt; $ my_seq3 &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n\n\n\n\n8.1.6 Filtrando um dataframe\nUma operação bastante comum no R é filtrar linhas de uma tabela de acordo com uma ou mais condições. Por exemplo, caso quiséssemos apenas os dados da ação ABEV3, poderíamos utilizar a função dplyr::filter() para filtrar a tabela:\n\nlibrary(dplyr)\n\n# filter df for single stock\nmy_df_temp &lt;- my_df |&gt;\n  filter(ticker == 'ABEV3') |&gt;\n  glimpse()\n\nR&gt; Rows: 4\nR&gt; Columns: 7\nR&gt; $ ticker   &lt;chr&gt; \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\"\nR&gt; $ ref_date &lt;date&gt; 2010-01-01, 2010-01-04, 2010-01-05, 2010-…\nR&gt; $ price    &lt;dbl&gt; 736.67, 764.14, 768.63, 776.47\nR&gt; $ ret      &lt;dbl&gt; NA, 0.037289424, 0.005875887, 0.010199966\nR&gt; $ my_seq1  &lt;int&gt; 1, 2, 3, 4\nR&gt; $ my_seq2  &lt;dbl&gt; 10, 11, 12, 13\nR&gt; $ my_seq3  &lt;int&gt; 1, 2, 3, 4\n\n\nA função também aceita mais de uma condição. Veja a seguir onde filtramos os dados para 'ABEV3' em datas após ou igual a '2010-01-05':\n\nlibrary(dplyr)\n# filter df for single stock and date\nmy_df_temp &lt;- my_df |&gt;\n  filter(ticker == 'ABEV3',\n         ref_date &gt;= as.Date('2010-01-05')) |&gt;\n  glimpse()\n\nR&gt; Rows: 2\nR&gt; Columns: 7\nR&gt; $ ticker   &lt;chr&gt; \"ABEV3\", \"ABEV3\"\nR&gt; $ ref_date &lt;date&gt; 2010-01-05, 2010-01-06\nR&gt; $ price    &lt;dbl&gt; 768.63, 776.47\nR&gt; $ ret      &lt;dbl&gt; 0.005875887, 0.010199966\nR&gt; $ my_seq1  &lt;int&gt; 3, 4\nR&gt; $ my_seq2  &lt;dbl&gt; 12, 13\nR&gt; $ my_seq3  &lt;int&gt; 3, 4\n\n\nAqui utilizamos o símbolo == para testar uma igualdade. Iremos estudar mais profundamente a classe de testes lógicos no capítulo Chapter 9.\n\n\n8.1.7 Ordenando um dataframe\nApós a criação ou importação de um dataframe, pode-se ordenar seus componentes de acordo com os valores de alguma coluna. Um caso bastante comum em que é necessário realizar uma ordenação explícita é quando importamos dados financeiros em que as datas não estão em ordem crescente. Na grande maioria das situações, dados temporais devem estar ordenados de acordo com a antiguidade, isto é, dados mais recentes são alocados na última linha da tabela. Essa operação é realizada através do uso da função order() ou dplyr::arrange() .\nComo exemplo, considere a criação de um dataframe com os valores a seguir:\n\nlibrary(tidyverse)\n\n# set df\nmy_df &lt;- tibble(col1 = c(4,1,2),\n                col2 = c(1,1,3),\n                col3 = c('a','b','c'))\n\n# print it\nprint(my_df)\n\nR&gt; # A tibble: 3 × 3\nR&gt;    col1  col2 col3 \nR&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1     4     1 a    \nR&gt; 2     1     1 b    \nR&gt; 3     2     3 c\n\n\nA função order() retorna os índices relativos à ordenação dos valores dados como entrada. Para o caso da primeira coluna de my_df, os índices dos elementos formadores do novo vetor, com seus valores ordenados em forma crescente, são:\n\nidx &lt;- order(my_df$col1)\nprint(idx)\n\nR&gt; [1] 2 3 1\n\n\nPortanto, ao utilizar a saída da função order() como indexador do dataframe, acaba-se ordenando o mesmo de acordo com os valores da coluna col1. Veja a seguir:\n\nmy_df_2 &lt;- my_df[order(my_df$col1), ]\nprint(my_df_2)\n\nR&gt; # A tibble: 3 × 3\nR&gt;    col1  col2 col3 \nR&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1     1     1 b    \nR&gt; 2     2     3 c    \nR&gt; 3     4     1 a\n\n\nEssa operação de ordenamento também pode ser realizada levando em conta mais de uma coluna. Veja o exemplo a seguir, onde se ordena o dataframe pelas colunas col2 e col1.\n\nidx &lt;- order(my_df$col2, my_df$col1)\nmy_df_3 &lt;- my_df[idx, ]\nprint(my_df_3)\n\nR&gt; # A tibble: 3 × 3\nR&gt;    col1  col2 col3 \nR&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1     1     1 b    \nR&gt; 2     4     1 a    \nR&gt; 3     2     3 c\n\n\nNo {tidyverse} (Wickham 2023), a forma de ordenar dataframes é pelo uso da função dplyr::arrange() . No caso de ordenamento decrescente, encapsulamos o nome das colunas com desc:\n\n# sort ascending, by col1 and col2\nmy_df &lt;- my_df |&gt;\n  arrange(col1, col2) |&gt;\n  print()\n\nR&gt; # A tibble: 3 × 3\nR&gt;    col1  col2 col3 \nR&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1     1     1 b    \nR&gt; 2     2     3 c    \nR&gt; 3     4     1 a\n\n# sort descending, col1 and col2\nmy_df &lt;- my_df |&gt;\n  arrange(desc(col1), desc(col2)) |&gt;\n  print()\n\nR&gt; # A tibble: 3 × 3\nR&gt;    col1  col2 col3 \nR&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1     4     1 a    \nR&gt; 2     2     3 c    \nR&gt; 3     1     1 b\n\n\nO resultado prático no uso de dplyr::arrange() é o mesmo de order() . Um dos seus benefícios é a possibilidade de encadeamento de operações através do uso do pipeline.\n\n\n8.1.8 Combinando e Agregando dataframes\nEm muitas situações de análise de dados será necessário juntar dataframes distintos em um único objeto. Tabelas diferentes são importadas no R e, antes de analisar os dados, precisamos combinar as informações em um único objeto. Nos casos mais simples, onde as tabelas a serem agregadas possuem o mesmo formato, nós as juntamos de acordo com as linhas, verticalmente, ou colunas, horizontalmente. Para esse fim, temos as funções dplyr::bind_rows() e dplyr::bind_cols() no tidyverse e rbind() e cbind() nas funções nativas do R. Observe o exemplo a seguir.\n\nlibrary(dplyr)\n\n# set dfs\nmy_df_1 &lt;- tibble(col1 = 1:5,\n                  col2 = rep('a', 5))\n\nmy_df_2 &lt;- tibble(col1 = 6:10,\n                  col2 = rep('b', 5),\n                  col3 = rep('c', 5))\n\n# bind by row\nmy_df &lt;- bind_rows(my_df_1, my_df_2) |&gt;\n  glimpse()\n\nR&gt; Rows: 10\nR&gt; Columns: 3\nR&gt; $ col1 &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\nR&gt; $ col2 &lt;chr&gt; \"a\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"b\", …\nR&gt; $ col3 &lt;chr&gt; NA, NA, NA, NA, NA, \"c\", \"c\", \"c\", \"c\", \"c\"\n\n\nNote que, no exemplo anterior, os nomes das colunas são os mesmos. De fato, a função dplyr::bind_rows() procura os nomes iguais em ambos os objetos para fazer a junção dos dataframes corretamente. As colunas que não ocorrem em ambos objetos, tal como col3 no exemplo, saem como NA no objeto final. Já para o caso de dplyr::bind_cols() , os nomes das colunas devem ser diferentes, porém o número de linhas deve ser o mesmo.\n\n# set dfs\nmy_df_1 &lt;- tibble(col1 = 1:5, col2 = rep('a', 5))\nmy_df_2 &lt;- tibble(col3 = 6:10, col4 = rep('b', 5))\n\n# bind by column\nmy_df &lt;- bind_cols(my_df_1, my_df_2) |&gt;\n  glimpse()\n\nR&gt; Rows: 5\nR&gt; Columns: 4\nR&gt; $ col1 &lt;int&gt; 1, 2, 3, 4, 5\nR&gt; $ col2 &lt;chr&gt; \"a\", \"a\", \"a\", \"a\", \"a\"\nR&gt; $ col3 &lt;int&gt; 6, 7, 8, 9, 10\nR&gt; $ col4 &lt;chr&gt; \"b\", \"b\", \"b\", \"b\", \"b\"\n\n\nPara casos mais complexos, onde a junção deve ser realizada de acordo com algum índice tal como uma data, é possível juntar dataframes diferentes com o uso das funções da família dplyr::join* tal como dplyr::inner_join() , dplyr::left_join() , dplyr::right_join() , entre outras. A descrição de todas elas não cabe aqui. Iremos descrever apenas o caso mais provável, dplyr::inner_join() . Essa combina os dados, mantendo apenas os casos onde existe o índice em ambos.\n\n# set df\nmy_df_1 &lt;- tibble(date = as.Date('2016-01-01')+0:10,\n                  x = 1:11)\n\nmy_df_2 &lt;- tibble(date = as.Date('2016-01-05')+0:10,\n                  y = seq(20,30, length.out = 11))\n\nNote que os dataframes criados possuem uma coluna em comum, date. A partir desta coluna que agregamos as tabelas com dplyr::inner_join() :\n\n# aggregate tables\nmy_df &lt;- inner_join(my_df_1, my_df_2)\n\nR&gt; Joining with `by = join_by(date)`\n\nglimpse(my_df)\n\nR&gt; Rows: 7\nR&gt; Columns: 3\nR&gt; $ date &lt;date&gt; 2016-01-05, 2016-01-06, 2016-01-07, 2016-01-…\nR&gt; $ x    &lt;int&gt; 5, 6, 7, 8, 9, 10, 11\nR&gt; $ y    &lt;dbl&gt; 20, 21, 22, 23, 24, 25, 26\n\n\nO R automaticamente verifica a existência de colunas com mesmo nome nos dataframes e realiza a junção por essas. Caso quiséssemos juntar dataframes onde os nomes das colunas para utilizar o índice não são iguais, temos duas soluções: modificar os nomes das colunas ou então utilizar argumento by em dplyr::inner_join() . Veja a seguir:\n\n# set df\nmy_df_3 &lt;- tibble(ref_date = as.Date('2016-01-01')+0:10,\n                  x = 1:11)\n\nmy_df_4 &lt;- tibble(my_date = as.Date('2016-01-05')+0:10,\n                  y = seq(20,30, length.out = 11))\n\n# join by my_df_3$ref_date and my_df_4$my_date\nmy_df &lt;- inner_join(my_df_3, my_df_4,\n                    by = c('ref_date' = 'my_date'))\n\nglimpse(my_df)\n\nR&gt; Rows: 7\nR&gt; Columns: 3\nR&gt; $ ref_date &lt;date&gt; 2016-01-05, 2016-01-06, 2016-01-07, 2016…\nR&gt; $ x        &lt;int&gt; 5, 6, 7, 8, 9, 10, 11\nR&gt; $ y        &lt;dbl&gt; 20, 21, 22, 23, 24, 25, 26\n\n\nPara o caso de uso da função nativa de agregação de dataframes, merge() , temos que indicar explicitamente o nome da coluna com argumento by:\n\n# aggregation with base R\nmy_df &lt;- merge(my_df_1, my_df_2, by = 'date')\n\nglimpse(my_df)\n\nR&gt; Rows: 7\nR&gt; Columns: 3\nR&gt; $ date &lt;date&gt; 2016-01-05, 2016-01-06, 2016-01-07, 2016-01-…\nR&gt; $ x    &lt;int&gt; 5, 6, 7, 8, 9, 10, 11\nR&gt; $ y    &lt;dbl&gt; 20, 21, 22, 23, 24, 25, 26\n\n\nNote que, nesse caso, o dataframe resultante manteve apenas as informações compartilhadas entre ambos os objetos, isto é, aquelas linhas onde as datas em date eram iguais. Esse é o mesmo resultado quando no uso do dplyr::inner_join() .\nAs demais funções de agregação de tabelas – dplyr::left_join() , dplyr::right_join() e dplyr::full_join() – funcionam de forma muito semelhante a dplyr::inner_join() , exceto na escolha da saída. Por exemplo, dplyr::full_join() retorna todos os casos/linhas entre tabela 1 e 2, incluindo aqueles onde não tem o índice compartilhado. Para estes casos, a coluna do índice sairá como NA. Veja o exemplo a seguir:\n\n# set df\nmy_df_5 &lt;- tibble(ref_date = as.Date('2016-01-01')+0:10,\n                  x = 1:11)\n\nmy_df_6 &lt;- tibble(ref_date = as.Date('2016-01-05')+0:10,\n                  y = seq(20,30, length.out = 11))\n\n# combine with full_join\nmy_df &lt;- full_join(my_df_5, my_df_6)\n\nR&gt; Joining with `by = join_by(ref_date)`\n\n# print it\nprint(my_df)\n\nR&gt; # A tibble: 15 × 3\nR&gt;    ref_date       x     y\nR&gt;    &lt;date&gt;     &lt;int&gt; &lt;dbl&gt;\nR&gt;  1 2016-01-01     1    NA\nR&gt;  2 2016-01-02     2    NA\nR&gt;  3 2016-01-03     3    NA\nR&gt;  4 2016-01-04     4    NA\nR&gt;  5 2016-01-05     5    20\nR&gt;  6 2016-01-06     6    21\nR&gt;  7 2016-01-07     7    22\nR&gt;  8 2016-01-08     8    23\nR&gt;  9 2016-01-09     9    24\nR&gt; 10 2016-01-10    10    25\nR&gt; 11 2016-01-11    11    26\nR&gt; 12 2016-01-12    NA    27\nR&gt; 13 2016-01-13    NA    28\nR&gt; 14 2016-01-14    NA    29\nR&gt; 15 2016-01-15    NA    30\n\n\n\n\n8.1.9 Extensões ao dataframe\nComo já foi relatado nos capítulos anteriores, um dos grandes benefícios no uso do R é a existência de pacotes para lidar com os problemas específicos dos usuários. Enquanto um objeto tabular do tipo tibble é suficiente para a maioria dos casos, existem benefícios no uso de uma classe alternativa. Ao longo do tempo, diversas soluções foram disponibilizadas por desenvolvedores.\nPor exemplo, é muito comum trabalharmos com dados exclusivamente numéricos que são indexados ao tempo. Isto é, situações onde cada informação pertence a um índice temporal - um objeto da classe data/tempo. As linhas dessa tabela representam um ponto no tempo, enquanto as colunas indicam variáveis numéricas de interesse. Nesse caso, faria sentido representarmos os nossos dados como objetos do tipo {xts} (R-xts?). O grande benefício dessa opção é que a agregação e a manipulação de variáveis em função do tempo é muito fácil. Por exemplo, podemos transformar dados de frequência diária para a frequência semanal com apenas uma linha de comando. Além disso, diversas outras funções reconhecem automaticamente que os dados são indexados ao tempo. Um exemplo é a criação de uma figura com esses dados. Nesse caso, o eixo horizontal da figura é automaticamente organizado com as datas.\nVeja um caso a seguir, onde carregamos os dados anteriores como um objeto {xts} (R-xts?):\n\nlibrary(xts)\n\nR&gt; Loading required package: zoo\n\n\nR&gt; \nR&gt; Attaching package: 'zoo'\n\n\nR&gt; The following objects are masked from 'package:base':\nR&gt; \nR&gt;     as.Date, as.Date.numeric\n\n\nR&gt; \nR&gt; ######################### Warning from 'xts' package ##########################\nR&gt; #                                                                             #\nR&gt; # The dplyr lag() function breaks how base R's lag() function is supposed to  #\nR&gt; # work, which breaks lag(my_xts). Calls to lag(my_xts) that you type or       #\nR&gt; # source() into this session won't work correctly.                            #\nR&gt; #                                                                             #\nR&gt; # Use stats::lag() to make sure you're not using dplyr::lag(), or you can add #\nR&gt; # conflictRules('dplyr', exclude = 'lag') to your .Rprofile to stop           #\nR&gt; # dplyr from breaking base R's lag() function.                                #\nR&gt; #                                                                             #\nR&gt; # Code in packages is not affected. It's protected by R's namespace mechanism #\nR&gt; # Set `options(xts.warn_dplyr_breaks_lag = FALSE)` to suppress this warning.  #\nR&gt; #                                                                             #\nR&gt; ###############################################################################\n\n\nR&gt; \nR&gt; Attaching package: 'xts'\n\n\nR&gt; The following objects are masked from 'package:dplyr':\nR&gt; \nR&gt;     first, last\n\n# set data\nticker &lt;- c('ABEV3', 'BBAS3','BBDC3')\n\ndate &lt;- as.Date(c('2010-01-01', '2010-01-04',\n                  '2010-01-05', '2010-01-06'))\n\nprice_ABEV3 &lt;- c(736.67, 764.14, 768.63, 776.47)\nprice_BBAS3 &lt;- c(59.4, 59.8, 59.2, 59.28)\nprice_BBDC3 &lt;- c(29.81, 30.82, 30.38, 30.20)\n\n# build matrix\nmy_mat &lt;- matrix(c(price_BBDC3, price_BBAS3, price_ABEV3),\n                 nrow = length(date) )\n\n# set xts object\nmy_xts &lt;- xts(my_mat,\n              order.by = date)\n\n# set correct colnames\ncolnames(my_xts) &lt;- ticker\n\n# check it!\nprint(my_xts)\n\nR&gt;            ABEV3 BBAS3  BBDC3\nR&gt; 2010-01-01 29.81 59.40 736.67\nR&gt; 2010-01-04 30.82 59.80 764.14\nR&gt; 2010-01-05 30.38 59.20 768.63\nR&gt; 2010-01-06 30.20 59.28 776.47\n\n\nO código anterior pode dar a impressão de que o objeto my_xts é semelhante a um dataframe, porém, não se engane. Por estar indexado a um vetor de tempo, objeto my_xts pode ser utilizado para uma série de procedimentos temporais, tal como uma agregação por período temporal. Veja o exemplo a seguir, onde agregamos duas variáveis de tempo através do cálculo de uma média a cada semana.\n\nN &lt;- 500\n\nmy_mat &lt;- matrix(c(seq(1, N), seq(N, 1)), nrow=N)\n\nmy_xts &lt;- xts(my_mat, order.by = as.Date('2016-01-01')+1:N)\n\nmy_xts.weekly.mean &lt;- apply.weekly(my_xts, mean)\n\nprint(head(my_xts.weekly.mean))\n\nR&gt;             X.1   X.2\nR&gt; 2016-01-03  1.5 499.5\nR&gt; 2016-01-10  6.0 495.0\nR&gt; 2016-01-17 13.0 488.0\nR&gt; 2016-01-24 20.0 481.0\nR&gt; 2016-01-31 27.0 474.0\nR&gt; 2016-02-07 34.0 467.0\n\n\nEm Finanças e Economia, as agregações com objetos {xts} (R-xts?) são extremamente úteis quando se trabalha com dados em frequências de tempo diferentes. Por exemplo, é muito comum que se agregue dados de transação no mercado financeiro em alta frequência para intervalos maiores. Assim, dados que ocorrem a cada segundo são agregados para serem representados de 15 em 15 minutos. Esse tipo de procedimento é facilmente realizado no R através da correta representação dos dados como objetos {xts} (R-xts?). Existem diversas outras funcionalidades desse pacote. Encorajo os usuários a ler o manual e aprender o que pode ser feito.\nIndo além, existem diversos outros tipos de dataframes customizados. Por exemplo, o dataframe proposto pelo pacote {data.table} (R-data.table?) prioriza o tempo de operação nos dados e o uso de uma notação compacta para acesso e processamento. O {tibbletime} (R-tibbletime?) é uma versão orientada pelo tempo para tibbles. Caso o usuário esteja necessitando realizar operações de agregação de tempo, o uso deste pacote é fortemente recomendado.\n\n\n8.1.10 Outras Funções Úteis\nhead - Retorna os primeiros n elementos de um dataframe.\n\nmy_df &lt;- tibble(col1 = 1:5000, col2 = rep('a', 5000))\nhead(my_df, 5)\n\nR&gt; # A tibble: 5 × 2\nR&gt;    col1 col2 \nR&gt;   &lt;int&gt; &lt;chr&gt;\nR&gt; 1     1 a    \nR&gt; 2     2 a    \nR&gt; 3     3 a    \nR&gt; 4     4 a    \nR&gt; 5     5 a\n\n\ntail - Retorna os últimos n elementos de um dataframe.\n\ntail(my_df, 5)\n\nR&gt; # A tibble: 5 × 2\nR&gt;    col1 col2 \nR&gt;   &lt;int&gt; &lt;chr&gt;\nR&gt; 1  4996 a    \nR&gt; 2  4997 a    \nR&gt; 3  4998 a    \nR&gt; 4  4999 a    \nR&gt; 5  5000 a\n\n\ncomplete.cases - Retorna um vetor lógico que testa se as linhas contêm apenas valores existentes e nenhum NA.\n\nmy_x &lt;- c(1:5, NA, 10)\nmy_y &lt;- c(5:10, NA)\nmy_df &lt;- tibble(my_x, my_y)\n\nprint(my_df)\n\nR&gt; # A tibble: 7 × 2\nR&gt;    my_x  my_y\nR&gt;   &lt;dbl&gt; &lt;int&gt;\nR&gt; 1     1     5\nR&gt; 2     2     6\nR&gt; 3     3     7\nR&gt; 4     4     8\nR&gt; 5     5     9\nR&gt; 6    NA    10\nR&gt; 7    10    NA\n\nprint(complete.cases(my_df))\n\nR&gt; [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\n\nprint(which(!complete.cases(my_df)))\n\nR&gt; [1] 6 7\n\n\nna.omit - Retorna um dataframe sem as linhas onde valores NA são encontrados.\n\nprint(na.omit(my_df))\n\nR&gt; # A tibble: 5 × 2\nR&gt;    my_x  my_y\nR&gt;   &lt;dbl&gt; &lt;int&gt;\nR&gt; 1     1     5\nR&gt; 2     2     6\nR&gt; 3     3     7\nR&gt; 4     4     8\nR&gt; 5     5     9\n\n\nunique - Retorna um dataframe onde todas as linhas duplicadas são eliminadas e somente os casos únicos são mantidos.\n\nmy_df &lt;- tibble(col1 = c(1,1,2,3,3,4,5),\n                col2 = c('A','A','A','C','C','B','D'))\n\nprint(my_df)\n\nR&gt; # A tibble: 7 × 2\nR&gt;    col1 col2 \nR&gt;   &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1     1 A    \nR&gt; 2     1 A    \nR&gt; 3     2 A    \nR&gt; 4     3 C    \nR&gt; 5     3 C    \nR&gt; 6     4 B    \nR&gt; 7     5 D\n\nprint(unique(my_df))\n\nR&gt; # A tibble: 5 × 2\nR&gt;    col1 col2 \nR&gt;   &lt;dbl&gt; &lt;chr&gt;\nR&gt; 1     1 A    \nR&gt; 2     2 A    \nR&gt; 3     3 C    \nR&gt; 4     4 B    \nR&gt; 5     5 D"
  },
  {
    "objectID": "08-objetos-armazenamento.html#listas",
    "href": "08-objetos-armazenamento.html#listas",
    "title": "8  Dataframes e outros Objetos",
    "section": "8.2 Listas",
    "text": "8.2 Listas\nUma lista (list) é uma classe de objeto extremamente flexível e já tivemos contato com ela nos capítulos anteriores. Ao contrário de vetores atômicos, a lista não apresenta restrição alguma em relação aos tipos de elementos nela contidos. Podemos agrupar valores numéricos com caracteres, fatores com datas e até mesmo listas dentro de listas. Quando agrupamos vetores, também não é necessário que os mesmos tenham um número igual de elementos. Além disso, podemos dar um nome a cada elemento. Essas propriedades fazem da lista o objeto mais flexível para o armazenamento e estruturação de dados no R. Não é acidental o fato de que listas são muito utilizadas como retorno de funções.\n\n8.2.1 Criando Listas\nUma lista pode ser criada através do comando list() , seguido por seus elementos separados por vírgula:\n\nlibrary(dplyr)\n\n# create list\nmy_l &lt;- list(c(1, 2, 3),\n             c('a', 'b'),\n             factor('A', 'B', 'C'),\n             tibble(col1 = 1:5))\n\n# use base::print\nprint(my_l)\n\nR&gt; [[1]]\nR&gt; [1] 1 2 3\nR&gt; \nR&gt; [[2]]\nR&gt; [1] \"a\" \"b\"\nR&gt; \nR&gt; [[3]]\nR&gt; [1] &lt;NA&gt;\nR&gt; Levels: C\nR&gt; \nR&gt; [[4]]\nR&gt; # A tibble: 5 × 1\nR&gt;    col1\nR&gt;   &lt;int&gt;\nR&gt; 1     1\nR&gt; 2     2\nR&gt; 3     3\nR&gt; 4     4\nR&gt; 5     5\n\n# use dplyr::glimpse\nglimpse(my_l)\n\nR&gt; List of 4\nR&gt;  $ : num [1:3] 1 2 3\nR&gt;  $ : chr [1:2] \"a\" \"b\"\nR&gt;  $ : Factor w/ 1 level \"C\": NA\nR&gt;  $ : tibble [5 × 1] (S3: tbl_df/tbl/data.frame)\nR&gt;   ..$ col1: int [1:5] 1 2 3 4 5\n\n\nNote que juntamos no mesmo objeto um vetor atômico numérico, outro de texto, um fator e um tibble. A apresentação de listas com o comando print() é diferente dos casos anteriores. Os elementos são separados verticalmente e os seus índices aparecem com duplo colchete ([[ ]]). Conforme será explicado logo a seguir, é dessa forma que os elementos de uma lista são armazenados e acessados.\nAssim como para os demais tipos de objeto, os elementos de uma lista também podem ter nomes, o que facilita o entendimento e a interpretação das informações do problema em análise. Por exemplo, considere o caso de uma base de dados com informações sobre determinada ação negociada na bolsa. Nesse caso, podemos definir uma lista como:\n\n# set named list\nmy_named_l &lt;- list(ticker = 'TICK4',\n                   market = 'Bovespa',\n                   df_prices = tibble(P = c(1,1.5,2,2.3),\n                                      ref_date = Sys.Date()+0:3))\n\n# check content\nglimpse(my_named_l)\n\nR&gt; List of 3\nR&gt;  $ ticker   : chr \"TICK4\"\nR&gt;  $ market   : chr \"Bovespa\"\nR&gt;  $ df_prices: tibble [4 × 2] (S3: tbl_df/tbl/data.frame)\nR&gt;   ..$ P       : num [1:4] 1 1.5 2 2.3\nR&gt;   ..$ ref_date: Date[1:4], format: \"2024-01-10\" ...\n\n\n\n\n\n\n\n\nDica\n\n\n\nToda vez que for trabalhar com listas, facilite a sua vida ao nomear todos os elementos de forma intuitiva. Isso facilita o acesso aos elementos e evita possíveis erros no código.\n\n\n\n\n8.2.2 Acessando os Elementos de uma Lista\nOs elementos de uma lista podem ser acessados através do uso de duplo colchete ([[ ]]), tal como em:\n\n# accessing elements from list\nprint(my_named_l[[2]])\n\nR&gt; [1] \"Bovespa\"\n\nprint(my_named_l[[3]])\n\nR&gt; # A tibble: 4 × 2\nR&gt;       P ref_date  \nR&gt;   &lt;dbl&gt; &lt;date&gt;    \nR&gt; 1   1   2024-01-10\nR&gt; 2   1.5 2024-01-11\nR&gt; 3   2   2024-01-12\nR&gt; 4   2.3 2024-01-13\n\n\nTambém é possível acessar os elementos com um colchete simples ([ ]), porém, tome cuidado com essa operação, pois o resultado não vai ser o objeto em si, mas uma outra lista. Esse é um equívoco muito fácil de passar despercebido, resultando em erros no código. Veja a seguir:\n\n# set list\nmy_l &lt;- list('a',\n             c(1,2,3),\n             factor('a','b'))\n\n# check classes\nclass(my_l[[2]])\n\nR&gt; [1] \"numeric\"\n\nclass(my_l[2])\n\nR&gt; [1] \"list\"\n\n\nCaso tentarmos somar um elemento a my_l[2], teremos uma mensagem de erro:\n\nmy_l[2] + 1\n\nR&gt; Error in my_l[2] + 1: non-numeric argument to binary operator\n\n\nEsse erro ocorre devido ao fato de que uma lista não tem operador de soma. Para corrigir, basta utilizar o duplo colchete, tal como em my_l[[2]]+1. O acesso a elementos de uma lista com colchete simples somente é útil quando estamos procurando uma sublista dentro de uma lista maior. No exemplo anterior, caso quiséssemos obter o primeiro e o segundo elemento da lista my_l, usaríamos:\n\n# set new list\nmy_new_l &lt;- my_l[c(1,2)]\n\n# check contents\nprint(my_new_l)\n\nR&gt; [[1]]\nR&gt; [1] \"a\"\nR&gt; \nR&gt; [[2]]\nR&gt; [1] 1 2 3\n\nclass(my_new_l)\n\nR&gt; [1] \"list\"\n\n\nNo caso de listas com elementos nomeados, os mesmos podem ser acessados por seu nome através do uso do símbolo $ tal como em my_named_l$df_prices ou [['nome']], tal como em my_named_l[['df_prices']]. Em geral, essa é uma forma mais eficiente e recomendada de interagir com os elementos de uma lista. Como regra geral no uso do R, sempre dê preferência ao acesso de elementos através de seus nomes, seja em listas, vetores ou dataframes. Isso evita erros, pois, ao modificar os dados e adicionar algum outro objeto na lista, é possível que o ordenamento interno mude e, portanto, a posição de determinado objeto pode acabar sendo modificada.\n\n\n\n\n\n\nDica\n\n\n\nSaiba que a ferramenta de autocomplete do RStudio também funciona para listas. Para usar, digite o nome da lista seguido de $ e aperte tab. Uma caixa de diálogo com todos os elementos disponíveis na lista irá aparecer. A partir disso, basta selecionar apertando enter.\n\n\nVeja os exemplos a seguir, onde são apresentadas as diferentes formas de se acessar uma lista.\n\n# different ways to access a list\nmy_named_l$ticker\nmy_named_l$price\nmy_named_l[['ticker']]\nmy_named_l[['price']]\n\nVale salientar que também é possível acessar diretamente os elementos de um vetor que esteja dentro de uma lista através de colchetes encadeados. Veja a seguir:\n\n# accessing elements of a vector in a list\nmy_l &lt;- list(c(1,2,3),\n             c('a', 'b'))\n\nprint(my_l[[1]][2])\n\nR&gt; [1] 2\n\nprint(my_l[[2]][1])\n\nR&gt; [1] \"a\"\n\n\nTal operação é bastante útil quando interessa apenas um elemento dentro de um objeto maior criado por alguma função.\n\n\n8.2.3 Adicionando e Removendo Elementos de uma Lista\nA remoção, adição e substituição de elementos de uma lista também são procedimentos fáceis. Para adicionar ou substituir, basta definir um novo objeto na posição desejada da lista:\n\n# set list\nmy_l &lt;- list('a', 1, 3)\ndplyr::glimpse(my_l)\n\nR&gt; List of 3\nR&gt;  $ : chr \"a\"\nR&gt;  $ : num 1\nR&gt;  $ : num 3\n\n# add new elements to list\nmy_l[[4]] &lt;- c(1:5)\nmy_l[[2]] &lt;- c('b')\n\n# print result\ndplyr::glimpse(my_l)\n\nR&gt; List of 4\nR&gt;  $ : chr \"a\"\nR&gt;  $ : chr \"b\"\nR&gt;  $ : num 3\nR&gt;  $ : int [1:5] 1 2 3 4 5\n\n\nA operação também é possível com o uso de nomes e operador $:\n\n# set list\nmy_l &lt;- list(elem1 = 'a', name1=5)\n\n# set new element\nmy_l$name2 &lt;- 10\ndplyr::glimpse(my_l)\n\nR&gt; List of 3\nR&gt;  $ elem1: chr \"a\"\nR&gt;  $ name1: num 5\nR&gt;  $ name2: num 10\n\n\nPara remover elementos de uma lista, basta definir o elemento para o símbolo reservado NULL (nulo):\n\n# set list\nmy_l &lt;- list(text = 'b', num1 = 2, num2 = 4)\ndplyr::glimpse(my_l)\n\nR&gt; List of 3\nR&gt;  $ text: chr \"b\"\nR&gt;  $ num1: num 2\nR&gt;  $ num2: num 4\n\n# remove elements\nmy_l[[3]] &lt;- NULL\ndplyr::glimpse(my_l)\n\nR&gt; List of 2\nR&gt;  $ text: chr \"b\"\nR&gt;  $ num1: num 2\n\nmy_l$num1 &lt;- NULL\ndplyr::glimpse(my_l)\n\nR&gt; List of 1\nR&gt;  $ text: chr \"b\"\n\n\nOutra maneira de retirar elementos de uma lista é utilizando um índice negativo para os elementos indesejados. Observe a seguir, onde eliminamos o segundo elemento de uma lista:\n\n# set list\nmy_l &lt;- list(a = 1, b = 'texto')\n\n# remove second element\ndplyr::glimpse(my_l[[-2]])\n\nR&gt;  num 1\n\n\nAssim como no caso de vetores atômicos, essa remoção também pode ser realizada por condições lógicas. Veja a seguir:\n\n# set list\nmy_l &lt;- list(1, 2, 3, 4)\n\n# remove elements by condition\nmy_l[my_l &gt; 2] &lt;- NULL\ndplyr::glimpse(my_l)\n\nR&gt; List of 2\nR&gt;  $ : num 1\nR&gt;  $ : num 2\n\n\nPorém, note que esse atalho só funciona porque todos os elementos de my_l são numéricos.\n\n\n8.2.4 Processando os Elementos de uma Lista\nUm ponto importante a ser destacado a respeito de listas é que os seus elementos podem ser processados e manipulados individualmente através de funções específicas. Este é um tópico particular de programação com o R, mas que vale a apresentação aqui.\nPor exemplo, imagine uma lista com vetores numéricos de diferentes tamanhos, tal como a seguir:\n\n# set list\nmy_l_num &lt;- list(c(1, 2, 3),\n                 seq(1:50),\n                 seq(-5, 5, by = 0.5))\n\nCaso quiséssemos calcular a média de cada elemento de my_l_num e apresentar o resultado na tela como um vetor, poderíamos fazer isso através de um procedimento simples, processando cada elemento individualmente:\n\n# calculate mean of vectors\nmean_1 &lt;- mean(my_l_num[[1]])\nmean_2 &lt;- mean(my_l_num[[2]])\nmean_3 &lt;- mean(my_l_num[[3]])\n\n# print it\nprint(c(mean_1, mean_2, mean_3))\n\nR&gt; [1]  2.0 25.5  0.0\n\n\nO código anterior funciona, porém não é recomendado devido sua falta de escabilidade. Isto é, caso aumentássemos o volume de dados ou objetos, o código não funcionaria corretamente. Se, por exemplo, tivéssemos um quarto elemento em my_l_num e quiséssemos manter essa estrutura do código, teríamos que adicionar uma nova linha mean_4 &lt;- mean(my_l_num[[4]]) e modificar o comando de saída na tela para print(c(mean_1, mean_2, mean_3, mean_4)).\nUma maneira mais fácil, elegante e inteligente seria utilizar a função sapply() . Nela, basta indicar o nome do objeto de tipo lista e a função que queremos utilizar para processar cada elemento. Internamente, os cálculos são realizados automaticamente. Veja a seguir:\n\n# using sapply\nmy_mean &lt;- sapply(my_l_num, mean)\n\n# print result\nprint(my_mean)\n\nR&gt; [1]  2.0 25.5  0.0\n\n\nO uso da função sapply() é preferível por ser mais compacto e eficiente do que a alternativa – a criação de mean_1, mean_2 e mean_3. Note que o primeiro código, com médias individuais, só funciona para uma lista com três elementos. A função sapply() , ao contrário, funcionaria da mesma forma em listas de qualquer tamanho. Caso tivéssemos mais elementos, nenhuma modificação seria necessária no código anterior, o que o torna extensível a chegada de novos dados.\nEssa visão e implementação de código voltado a procedimentos genéricos é um dos lemas para tornar o uso do R mais eficiente. A regra é simples: sempre escreva códigos que sejam adaptáveis a chegada de novos dados. Em inglês, isso é chamado de regra DRY (don’t repeat yourself). Caso você esteja repetindo códigos e abusando do control + c/control + v, como no exemplo anterior, certamente existe uma solução mais elegante e flexível que poderia ser utilizada. No R, existem diversas outras funções da família apply para esse objetivo. Essas funções serão explicadas com maiores detalhes no capítulo Chapter 10.\n\n\n8.2.5 Outras Funções Úteis\nunlist - Retorna os elementos de uma lista em um único vetor atômico.\n\nmy_named_l &lt;- list(ticker = 'XXXX4',\n                   price = c(1,1.5,2,3),\n                   market = 'Bovespa')\nmy_unlisted &lt;- unlist(my_named_l)\nprint(my_unlisted)\n\nR&gt;    ticker    price1    price2    price3    price4    market \nR&gt;   \"XXXX4\"       \"1\"     \"1.5\"       \"2\"       \"3\" \"Bovespa\"\n\nclass(my_unlisted)\n\nR&gt; [1] \"character\"\n\n\nas.list - Converte um objeto para uma lista, tornando cada elemento um elemento da lista.\n\nmy_x &lt;- 10:13\nmy_x_as_list &lt;- as.list(my_x)\nprint(my_x_as_list)\n\nR&gt; [[1]]\nR&gt; [1] 10\nR&gt; \nR&gt; [[2]]\nR&gt; [1] 11\nR&gt; \nR&gt; [[3]]\nR&gt; [1] 12\nR&gt; \nR&gt; [[4]]\nR&gt; [1] 13\n\n\nnames - Retorna ou define os nomes dos elementos de uma lista. Assim como para o caso de nomear elementos de um vetor atômico, usa-se a função names() alocada ao lado esquerdo do símbolo &lt;-.\n\nmy_l &lt;- list(value1 = 1, value2 = 2, value3 = 3)\nprint(names(my_l))\n\nR&gt; [1] \"value1\" \"value2\" \"value3\"\n\nmy_l &lt;- list(1,2,3)\nnames(my_l) &lt;- c('num1', 'num2', 'num3')\nprint(my_l)\n\nR&gt; $num1\nR&gt; [1] 1\nR&gt; \nR&gt; $num2\nR&gt; [1] 2\nR&gt; \nR&gt; $num3\nR&gt; [1] 3"
  },
  {
    "objectID": "08-objetos-armazenamento.html#exerc-classe-estrutura",
    "href": "08-objetos-armazenamento.html#exerc-classe-estrutura",
    "title": "8  Dataframes e outros Objetos",
    "section": "8.3 Exercícios",
    "text": "8.3 Exercícios\n\n\n\n\nR Core Team. 2023. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/.\n\n\nWickham, Hadley. 2023. Tidyverse: Easily Install and Load the Tidyverse. https://tidyverse.tidyverse.org.\n\n\nWickham, Hadley, Romain François, Lionel Henry, Kirill Müller, and Davis Vaughan. 2023. Dplyr: A Grammar of Data Manipulation. https://dplyr.tidyverse.org."
  },
  {
    "objectID": "09-objetos-basicos.html#objetos-numéricos",
    "href": "09-objetos-basicos.html#objetos-numéricos",
    "title": "9  As Classes Básicas de Objetos",
    "section": "9.1 Objetos Numéricos",
    "text": "9.1 Objetos Numéricos\nUma das classes mais utilizadas em pesquisa empírica. Os valores numéricos são representações de uma quantidade. Por exemplo: o preço de uma ação em determinada data, o volume negociado de um contrato financeiro em determinado dia, a inflação anual de um país, entre várias outras possibilidades.\n\n9.1.1 Criando e Manipulando Vetores Numéricos\nA criação e manipulação de valores numéricos é fácil e direta. Os símbolos de operações matemáticas seguem o esperado, tal como soma (+), diminuição (-), divisão (/) e multiplicação (*). Todas as operações matemáticas são efetuadas com a orientação de elemento para elemento e possuem notação vetorial. Isso significa, por exemplo, que podemos manipular vetores inteiros em uma única linha de comando. Veja a seguir, onde se cria dois vetores e realiza-se diversas operações entre eles.\n\n# create numeric vectors\nx &lt;- 1:5\ny &lt;- 2:6\n\n# print sum\nprint(x+y)\n\nR&gt; [1]  3  5  7  9 11\n\n# print multiplication\nprint(x*y)\n\nR&gt; [1]  2  6 12 20 30\n\n# print division\nprint(x/y)\n\nR&gt; [1] 0.5000000 0.6666667 0.7500000 0.8000000 0.8333333\n\n# print exponentiation\nprint(x^y)\n\nR&gt; [1]     1     8    81  1024 15625\n\n\nUm diferencial do R em relação a outras linguagens é que, nele, são aceitas operações entre vetores diferentes. Por exemplo, podemos somar um vetor numérico de quatro elementos com outro de apenas dois. Nesse caso, aplica-se a chamada regra de reciclagem (recycling rule). Ela define que, se dois vetores de tamanho diferente estão interagindo, o vetor menor é repetido tantas vezes quantas forem necessárias para obter-se o mesmo número de elementos do vetor maior. Veja o exemplo a seguir:\n\n# set x with 4 elements and y with 2\nx &lt;- 1:4\ny &lt;- 2:1\n\n# print sum\nprint(x + y)\n\nR&gt; [1] 3 3 5 5\n\n\nO resultado de x + y é equivalente a 1:4 + c(2, 1, 2, 1). Caso interagirmos vetores em que o tamanho do maior não é múltiplo do menor, o R realiza o mesmo procedimento de reciclagem, porém emite uma mensagem de warning:\n\n# set x = 4 elements and y with 3\nx &lt;- c(1, 2, 3, 4)\ny &lt;- c(1, 2, 3)\n\n# print sum (recycling rule)\nprint(x +y)\n\nR&gt; Warning in x + y: longer object length is not a multiple of\nR&gt; shorter object length\n\n\nR&gt; [1] 2 4 6 5\n\n\nOs três primeiros elementos de x foram somados aos três primeiros elementos de y. O quarto elemento de x foi somado ao primeiro elemento de y. Uma vez que não havia um quarto elemento em y, o ciclo reinicia, resgatando o primeiro elemento de y e resultando em uma soma igual a 5.\nOs elementos de um vetor numérico também podem ser nomeados quando na criação do vetor:\n\n# create named vector\nx &lt;- c(item1 = 10,\n       item2 = 14,\n       item3 = 9,\n       item4 = 2)\n\n# print it\nprint(x)\n\nR&gt; item1 item2 item3 item4 \nR&gt;    10    14     9     2\n\n\nPara nomear os elementos após a criação, podemos utilizar a função names() . Veja a seguir:\n\n# create unnamed vector\nx &lt;- c(10, 14, 9, 2)\n\n# set names of elements\nnames(x) &lt;- c('item1', 'item2', 'item3', 'item4')\n\n# print it\nprint(x)\n\nR&gt; item1 item2 item3 item4 \nR&gt;    10    14     9     2\n\n\nVetores numéricos vazios também podem ser criados. Em algumas situações de desenvolvimento de código faz sentido pré-alocar o vetor antes de preenchê-lo com valores. Nesse caso, utilize a função numeric() :\n\n# create empty numeric vector of length 10\nmy_x &lt;- numeric(length = 10)\n\n# print it\nprint(my_x)\n\nR&gt;  [1] 0 0 0 0 0 0 0 0 0 0\n\n\nObserve que, nesse caso, os valores de my_x são definidos como zero.\n\n9.1.1.1 Criando Sequências de Valores\nExistem duas maneiras de criar uma sequência de valores no R. A primeira, que já foi utilizada nos exemplos anteriores, é o uso do operador :. Por exemplo, my_seq &lt;- 1:10 ou my_seq &lt;- -5:5. Esse método é bastante prático, pois a notação é clara e direta.\nPorém, o uso do operador : limita as possibilidades. A diferença entre os valores adjacentes é sempre 1 para sequências ascendentes e -1 para sequências descendentes. Uma versão mais poderosa para a criação de sequências é o uso da função seq() . Com ela, é possível definir os intervalos entre cada valor com o argumento by. Veja a seguir: \n\n# set sequence\nmy_seq &lt;- seq(from = -10, to = 10, by = 2)\n\n# print it\nprint(my_seq)\n\nR&gt;  [1] -10  -8  -6  -4  -2   0   2   4   6   8  10\n\n\nOutro atributo interessante da função seq() é a possibilidade de criar vetores com um valor inicial, um valor final e o número de elementos desejado. Isso é realizado com o uso da opção length.out. Observe o código a seguir, onde cria-se um vetor de 0 até 10 com 20 elementos:\n\n# set sequence with fixed size\nmy_seq &lt;- seq(from = 0, to = 10, length.out = 20)\n\n# print it\nprint(my_seq)\n\nR&gt;  [1]  0.0000000  0.5263158  1.0526316  1.5789474  2.1052632\nR&gt;  [6]  2.6315789  3.1578947  3.6842105  4.2105263  4.7368421\nR&gt; [11]  5.2631579  5.7894737  6.3157895  6.8421053  7.3684211\nR&gt; [16]  7.8947368  8.4210526  8.9473684  9.4736842 10.0000000\n\n\nNo caso anterior, o tamanho final do vetor foi definido e a própria função se encarregou de descobrir qual a variação necessária entre cada valor de my_seq.\n\n\n9.1.1.2 Criando Vetores com Elementos Repetidos\nOutra função interessante é a que cria vetores com o uso de repetição. Por exemplo: imagine que estamos interessado em um vetor preenchido com o valor 1 dez vezes. Para isso, basta utilizar a função rep() : \n\n# repeat vector three times\nmy_x &lt;- rep(x = 1, times = 10)\n\n# print it\nprint(my_x)\n\nR&gt;  [1] 1 1 1 1 1 1 1 1 1 1\n\n\nA função também funciona com vetores. Considere uma situação onde temos um vetor com os valores c(1,2) e gostaríamos de criar um vetor maior com os elementos c(1, 2, 1, 2, 1, 2) - isto é, repetindo o vetor menor três vezes. Veja o resultado a seguir:\n\n# repeat vector three times\nmy_x &lt;- rep(x = c(1, 2), times = 3)\n\n# print it\nprint(my_x)\n\nR&gt; [1] 1 2 1 2 1 2\n\n\n\n\n9.1.1.3 Criando Vetores com Números Aleatórios\nEm muitas situações será necessário a criação de números aleatórios. Esse procedimento numérico é bastante utilizado para simular modelos matemáticos em Finanças. Por exemplo, o método de simulação de preços de ativos de Monte Carlo parte da simulação de números aleatórios (mcleish2011monte?). No R, existem diversas funções que criam números aleatórios para diferentes distribuições estatísticas. As mais utilizadas, porém, são as funções rnorm() e runif() . \nA função rnorm() gera números aleatórios da distribuição Normal, com opções para a média (tendência) e o desvio padrão (variabilidade). Veja o seu uso a seguir:\n\n# generate 10000 random numbers from a Normal distribution\nmy_rnd_vec &lt;- rnorm(n = 10000,\n                    mean = 0,\n                    sd = 1)\n\n# print first 20 elements\nprint(my_rnd_vec[1:20])\n\nR&gt;  [1] -2.26366410 -0.55699445  1.38329681 -1.13970892\nR&gt;  [5]  1.72186300 -0.73779108 -1.11632186  0.39170836\nR&gt;  [9]  0.46777794  0.86666395 -1.15874728 -0.43591060\nR&gt; [13]  0.89437223 -0.05233283  0.83999886  0.66663530\nR&gt; [17] -1.23731647 -0.02421145 -0.16612844 -0.60344177\n\n\nO código anterior gera uma grande quantidade de números aleatórios de uma distribuição Normal com média zero e desvio padrão igual a um. Podemos verificar a distribuição dos números gerados com um histograma:\n\n\n\n\n\nComo esperado, temos o formato de sino que caracteriza uma distribuição do tipo Normal. Como exercício, podes trocar as entradas mean() e sd() e confirmar como isso afeta a figura gerada.\nJá a função runif() gera valores aleatórios da distribuição uniforme entre um valor máximo e um valor mínimo. Ela é geralmente utilizada para simular probabilidades. A função runif() tem três parâmetros de entrada: o número de valores aleatórios desejado, o valor mínimo e o valor máximo. Veja exemplo a seguir:\n\n# create a random vector with minimum and maximum\nmy_rnd_vec &lt;- runif(n = 10,\n                    min = -5,\n                    max = 5)\n\n# print it\nprint(my_rnd_vec)\n\nR&gt;  [1]  3.3836844  0.3221582 -0.4130585  1.0049171  4.4777498\nR&gt;  [6]  2.3969230 -4.7666913  1.5617563 -1.3845389 -4.8410415\n\n\nObserve que ambas as funções anteriores são limitadas à sua respectiva distribuição. Uma maneira alternativa e flexível de gerar valores aleatórios é utilizar a função sample() . Essa tem como entrada um vetor qualquer e retorna uma versão embaralhada de seus elementos. A sua flexibilidade reside no fato de que o vetor de entrada pode ser qualquer coisa. Por exemplo, caso quiséssemos criar um vetor aleatório com os números c(0, 5, 15, 20, 25) apenas, poderíamos fazê-lo da seguinte forma: \n\n# create sequence\nmy_vec &lt;- seq(from = 0, to = 25, by=5)\n\n# sample sequence\nmy_rnd_vec &lt;- sample(my_vec)\n\n# print it\nprint(my_rnd_vec)\n\nR&gt; [1]  5 10 25  0 15 20\n\n\nA função sample() também permite a seleção aleatória de um certo número de termos. Por exemplo, caso quiséssemos selecionar aleatoriamente apenas um elemento de my_vec, escreveríamos o código da seguinte maneira:\n\n# sample one element of my_vec\nmy_rnd_vec &lt;- sample(my_vec, size = 1)\n\n# print it\nprint(my_rnd_vec)\n\nR&gt; [1] 25\n\n\nCaso quiséssemos dois elementos, escreveríamos:\n\n# sample two elements of my_vec\nmy_rnd_vec &lt;- sample(my_vec, size = 2)\n\n# print it\nprint(my_rnd_vec)\n\nR&gt; [1]  5 10\n\n\nTambém é possível selecionar valores de uma amostra menor para a criação de um vetor maior. Por exemplo, considere o caso em que se tem um vetor com os números c(10, 15, 20) e deseja-se criar um vetor aleatório com dez elementos retirados desse vetor menor, com repetição. Para isso, podemos utilizar a opção replace = TRUE.\n\n# create vector\nmy_vec &lt;- c(5, 10, 15)\n\n# sample\nmy_rnd_vec &lt;- sample(x = my_vec, size = 10, replace = TRUE)\nprint(my_rnd_vec)\n\nR&gt;  [1] 10  5 10 15 15 10 15  5  5  5\n\n\nVale destacar que a função sample() funciona para qualquer tipo ou objeto, não sendo, portanto, exclusiva para vetores numéricos. Poderíamos, também, escolher elementos aleatórios de um vetor de texto ou então uma lista:\n\n# example of sample with characters\nprint(sample(c('elem 1', 'elem 2', 'elem 3'),\n             size = 1))\n\nR&gt; [1] \"elem 1\"\n\n# example of sample with list\nprint(sample(list(x = c(1,1,1),\n                  y = c('a', 'b')),\n             size = 1))\n\nR&gt; $x\nR&gt; [1] 1 1 1\n\n\nÉ importante ressaltar que a geração de valores aleatórios no R (ou qualquer outro programa) não é totalmente aleatória! De fato, o próprio computador escolhe os valores dentre uma fila de valores possíveis. Cada vez que funções tal como rnorm() , runif() e sample() são utilizadas, o computador escolhe um lugar diferente dessa fila de acordo com vários parâmetros, incluindo a data e horário atual. Portanto, do ponto de vista do usuário, os valores são gerados de forma imprevisível. Para o computador, porém, essa seleção é completamente determinística e guiada por regras claras.\nUma propriedade interessante no R é a possibilidade de selecionar uma posição específica na fila de valores aleatórios utilizando função set.seed() . É ela que fixa a semente para gerar os valores. Na prática, o resultado é que todos os números e seleções aleatórias realizadas pelo código serão iguais em cada execução. O uso de set.seed() é bastante recomendado para manter a reprodutibilidade dos códigos envolvendo aleatoriedade. Veja o exemplo a seguir, onde utiliza-se essa função.\n\n# fix seed\nset.seed(seed = 10)\n\n# set vec and print\nmy_rnd_vec_1 &lt;- runif(5)\nprint(my_rnd_vec_1)\n\nR&gt; [1] 0.50747820 0.30676851 0.42690767 0.69310208 0.08513597\n\n# set vec and print\nmy_rnd_vec_2 &lt;- runif(5)\nprint(my_rnd_vec_2)\n\nR&gt; [1] 0.2254366 0.2745305 0.2723051 0.6158293 0.4296715\n\n\nNo código anterior, o valor de set.seed() é um inteiro escolhido pelo usuário. Após a chamada de set.seed() , todas as seleções e números aleatórios irão iniciar do mesmo ponto e, portanto, serão iguais. Motivo o leitor a executar o código anterior no R. Verás que os valores de my_rnd_vec_1 e my_rnd_vec_2 serão exatamente iguais aos valores colocados aqui.\nO uso de set.seed() também funciona para o caso de sample() . Veja a seguir:\n\n# fix seed\nset.seed(seed = 15)\n\n# print vectors\nprint(sample(1:10))\n\nR&gt;  [1]  5  2  1  6  8 10  3  7  9  4\n\nprint(sample(10:20))\n\nR&gt;  [1] 13 15 10 17 20 14 19 12 11 18 16\n\n\nNovamente, execute os comandos anteriores no R e verás que o resultado na tela bate com o apresentado aqui.\n\n\n\n9.1.2 Acessando Elementos de um Vetor Numérico\nTodos os elementos de um vetor numérico podem ser acessados através do uso de colchetes ([ ]). Por exemplo, caso quiséssemos apenas o primeiro elemento de x, teríamos:\n\n# set vector\nx &lt;- c(-1, 4, -9, 2)\n\n# get first element\nfirst_elem_x &lt;- x[1]\n\n# print it\nprint(first_elem_x)\n\nR&gt; [1] -1\n\n\nA mesma notação é válida para extrair porções de um vetor. Caso quiséssemos um subvetor de x com o primeiro e o segundo elemento, faríamos essa operação da seguinte forma:\n\n# sub-vector of x\nsub_x &lt;- x[1:2]\n\n# print it\nprint(sub_x)\n\nR&gt; [1] -1  4\n\n\nPara acessar elementos nomeados de um vetor numérico, basta utilizar seu nome junto aos colchetes.\n\n# set named vector\nx &lt;- c(item1 = 10, item2 = 14, item3 = -9, item4 = -2)\n\n# access elements by name\nprint(x['item2'])\n\nR&gt; item2 \nR&gt;    14\n\nprint(x[c('item2','item4')])\n\nR&gt; item2 item4 \nR&gt;    14    -2\n\n\nO acesso aos elementos de um vetor numérico também é possível através de testes lógicos. Por exemplo, caso tivéssemos interesse em saber quais os valores de x que são maiores do que 0, o código resultante seria da seguinte forma:\n\n# find all values of x higher than zero\nprint(x[x &gt; 0])\n\nR&gt; item1 item2 \nR&gt;    10    14\n\n\nOs usos de regras de segmentação dos dados de acordo com algum critério é chamado de indexação lógica. Os objetos do tipo logical serão tratados mais profundamente em seção futura deste capítulo.\n\n\n9.1.3 Modificando e Removendo Elementos de um Vetor Numérico\nA modificação de um vetor numérico é muito simples. Basta indicar a posição dos elementos e os novos valores com o símbolo de assign (&lt;-):\n\n# set vector\nmy_x &lt;- 1:4\n\n# modify first element to 5\nmy_x[1] &lt;- 5\n\n# print result\nprint(my_x)\n\nR&gt; [1] 5 2 3 4\n\n\nEssa modificação também pode ser realizada em bloco:\n\n# set vector\nmy_x &lt;- 0:5\n\n# set the first three elements to 5\nmy_x[1:3] &lt;- 5\n\n# print result\nprint(my_x)\n\nR&gt; [1] 5 5 5 3 4 5\n\n\nO uso de condições para definir elementos é realizada pela indexação:\n\n# set vector\nmy_x &lt;- -5:5\n\n# set any value lower than 2 to 0\nmy_x[my_x&lt;2] &lt;- 0\n\n# print result\nprint(my_x)\n\nR&gt;  [1] 0 0 0 0 0 0 0 2 3 4 5\n\n\nA remoção de elementos é realizada com o uso de índices negativos:\n\n# create vector\nmy_x &lt;- -5:5\n\n# remove first and second element of my_x\nmy_x &lt;- my_x[-(1:2)]\n\n# show result\nprint(my_x)\n\nR&gt; [1] -3 -2 -1  0  1  2  3  4  5\n\n\nNote como o uso do índice negativo em my_x[-(1:2)] retorna o vetor original sem o primeiro e segundo elemento.\n\n\n9.1.4 Criando Grupos\nEm algumas situações será necessário entender quantos casos da amostra estão localizados entre um determinado intervalo. Por exemplo, imagine o vetor dos retornos diários de uma ação, isto é, a variação percentual dos preços de fechamento entre um dia e outro. Uma possível análise de risco que pode ser realizada é dividir o intervalo de retornos em cinco partes e verificar o percentual de ocorrência dos valores em cada um dos intervalos. Essa análise numérica é bastante semelhante à construção e visualização de histogramas.\nA função cut() serve para criar grupos de intervalos a partir de um vetor numérico. Veja o exemplo a seguir, onde cria-se um vetor aleatório oriundo da distribuição Normal e cinco grupos a partir de intervalos definidos pelos dados.\n\n# set rnd vec\nmy_x &lt;- rnorm(10)\n\n# \"cut\" it into 5 pieces\nmy_cut &lt;- cut(x = my_x, breaks = 5)\nprint(my_cut)\n\nR&gt;  [1] (-1.57,-1.12]  (0.252,0.71]   (-1.12,-0.66] \nR&gt;  [4] (-0.204,0.252] (-0.66,-0.204] (-1.57,-1.12] \nR&gt;  [7] (0.252,0.71]   (-0.204,0.252] (0.252,0.71]  \nR&gt; [10] (-0.204,0.252]\nR&gt; 5 Levels: (-1.57,-1.12] (-1.12,-0.66] ... (0.252,0.71]\n\n\nObserve que os nomes dos elementos da variável my_cut são definidos pelos intervalos e o resultado é um objeto do tipo fator. Em seções futuras, iremos explicar melhor esse tipo de objeto e as suas propriedades.\nNo exemplo anterior, os intervalos para cada grupo foram definidos automaticamente. No uso da função cut() , também é possível definir quebras customizadas nos dados e nos nomes dos grupos. Veja a seguir:\n\n# set random vector\nmy_x &lt;- rnorm(10)\n\n# create groups with 5 breaks\nmy_cut &lt;- cut(x = my_x, breaks = 5)\n\n# print it!\nprint(my_cut)\n\nR&gt;  [1] (-1.3,-0.3]  (-0.3,0.697] (-0.3,0.697] (-2.3,-1.3] \nR&gt;  [5] (-0.3,0.697] (0.697,1.69] (0.697,1.69] (0.697,1.69]\nR&gt;  [9] (-1.3,-0.3]  (1.69,2.7]  \nR&gt; 5 Levels: (-2.3,-1.3] (-1.3,-0.3] ... (1.69,2.7]\n\n\nNote que os nomes dos elementos em my_cut foram definidos como intervalos e o resultado é um objeto do tipo fator. É possível também definir intervalos e nomes customizados para cada grupo com o uso dos argumentos labels e breaks:\n\n# create random vector\nmy_x &lt;- rnorm(10)\n\n# define breaks manually\nmy_breaks &lt;- c(min(my_x)-1, -1, 1, max(my_x)+1)\n\n# define labels manually\nmy_labels &lt;- c('Low','Normal', 'High')\n\n# create group from numerical vector\nmy_cut &lt;- cut(x = my_x, breaks = my_breaks, labels = my_labels)\n\n# print both!\nprint(my_x)\n\nR&gt;  [1]  0.5981759  1.6113647 -0.4373813  1.3526206  0.4705685\nR&gt;  [6]  0.4702481  0.3963088 -0.7304926  0.6531176  1.2279598\n\nprint(my_cut)\n\nR&gt;  [1] Normal High   Normal High   Normal Normal Normal Normal\nR&gt;  [9] Normal High  \nR&gt; Levels: Low Normal High\n\n\nComo podemos ver, os nomes dos grupos estão mais amigáveis para uma futura análise.\n\n\n9.1.5 Outras Funções Úteis\nas.numeric - Converte determinado objeto para numérico.\n\nmy_text &lt;- c('1', '2', '3')\nclass(my_text)\n\nR&gt; [1] \"character\"\n\nmy_x &lt;- as.numeric(my_text)\nprint(my_x)\n\nR&gt; [1] 1 2 3\n\nclass(my_x)\n\nR&gt; [1] \"numeric\"\n\n\nsum - Soma os elementos de um vetor.\n\nmy_x &lt;- 1:50\nmy_sum &lt;- sum(my_x)\nprint(my_sum)\n\nR&gt; [1] 1275\n\n\nmax - Retorna o máximo valor numérico do vetor.\n\nx &lt;- c(10, 14, 9, 2)\nmax_x &lt;- max(x)\nprint(max_x)\n\nR&gt; [1] 14\n\n\nmin - Retorna o mínimo valor numérico do vetor.\n\nx &lt;- c(12, 15, 9, 2)\nmin_x &lt;- min(x)\nprint(min_x)\n\nR&gt; [1] 2\n\n\nwhich.max - Retorna a posição do máximo valor numérico do vetor.\n\nx &lt;- c(100, 141, 9, 2)\nwhich.max_x &lt;- which.max(x)\ncat(paste('The position of the maximum value of x is ', which.max_x))\n\nR&gt; The position of the maximum value of x is  2\n\ncat(' and its value is ', x[which.max_x])\n\nR&gt;  and its value is  141\n\n\nwhich.min - Retorna a posição do mínimo valor numérico do vetor.\n\nx &lt;- c(10, 14, 9, 2)\nwhich.min_x &lt;- which.min(x)\ncat(paste('The position of the minimum value of x is ',\n          which.min_x, ' and its value is ', x[which.min_x]))\n\nR&gt; The position of the minimum value of x is  4  and its value is  2\n\n\nsort - Retorna uma versão ordenada de um vetor.\n\nx &lt;- runif(5)\nprint(sort(x, decreasing = FALSE))\n\nR&gt; [1] 0.1623069 0.8347800 0.8553657 0.9099027 0.9935257\n\nprint(sort(x, decreasing = TRUE))\n\nR&gt; [1] 0.9935257 0.9099027 0.8553657 0.8347800 0.1623069\n\n\ncumsum - Soma os elementos de um vetor de forma cumulativa.\n\nmy_x &lt;- 1:25\nmy_cumsum &lt;- cumsum(my_x)\nprint(my_cumsum)\n\nR&gt;  [1]   1   3   6  10  15  21  28  36  45  55  66  78  91 105\nR&gt; [15] 120 136 153 171 190 210 231 253 276 300 325\n\n\nprod - Realiza o produto de todos os elementos de um vetor.\n\nmy_x &lt;- 1:10\nmy_prod &lt;- prod(my_x)\nprint(my_prod)\n\nR&gt; [1] 3628800\n\n\ncumprod - Calcula o produto cumulativo de todos os elementos de um vetor.\n\nmy_x &lt;- 1:10\nmy_prod &lt;- cumprod(my_x)\nprint(my_prod)\n\nR&gt;  [1]       1       2       6      24     120     720    5040\nR&gt;  [8]   40320  362880 3628800"
  },
  {
    "objectID": "09-objetos-basicos.html#classe-de-caracteres-texto",
    "href": "09-objetos-basicos.html#classe-de-caracteres-texto",
    "title": "9  As Classes Básicas de Objetos",
    "section": "9.2 Classe de Caracteres (texto)",
    "text": "9.2 Classe de Caracteres (texto)\nA classe de caracteres, ou texto, serve para armazenar informações textuais. Um exemplo prático em Finanças seria o reconhecimento de uma ação através dos seus símbolos de identificação (tickers) ou então por sua classe de ação: ordinária ou preferencial. Este tipo de dado tem sido utilizado cada vez mais em pesquisa empírica (gentzkow2017text?), resultando em uma diversidade de pacotes.\nO R possui vários recursos que facilitam a criação e manipulação de objetos de tipo texto. As funções básicas fornecidas com a instalação de R são abrangentes e adequadas para a maioria dos casos. No entanto, pacote {stringr} (Wickham 2023b) do {tidyverse} (Wickham 2023c) fornece muitas funções que expandem a funcionalidade básica do R na manipulação de texto.\nUm aspecto positivo de {stringr} (Wickham 2023b) é que as funções começam com o nome str_ e possuem nomes informativos. Combinando isso com o recurso de preenchimento automático (autocomplete) pela tecla tab, fica fácil de localizar os nomes das funções do pacote. Seguindo a prioridade ao universo do {tidyverse} (Wickham 2023c), esta seção irá dar preferência ao uso das funções do pacote {stringr} (Wickham 2023b). As rotinas nativas de manipulação de texto serão apresentadas, porém de forma limitada.\n\n9.2.1 Criando um Objeto Simples de Caracteres\nTodo objeto de caracteres é criado através da encapsulação de um texto por aspas duplas (\" \") ou simples (' '). Para criar um vetor de caracteres com tickers de ações, podemos fazê-lo com o seguinte código:\n\nmy_assets &lt;- c('PETR3', 'VALE4', 'GGBR4')\nprint(my_assets)\n\nR&gt; [1] \"PETR3\" \"VALE4\" \"GGBR4\"\n\n\nConfirma-se a classe do objeto com a função class() :\n\nclass(my_assets)\n\nR&gt; [1] \"character\"\n\n\n\n\n9.2.2 Criando Objetos Estruturados de Texto\nEm muitos casos no uso do R, estaremos interessados em criar vetores de texto com algum tipo de estrutura própria. Por exemplo, o vetor c(\"text 1\", \"text 2\", ..., \"text 20\") possui um lógica de criação clara. Computacionalmente, podemos definir a sua estrutura como sendo a junção do texto text e um vetor de sequência, de 1 até 20.\nPara criar um vetor textual capaz de unir texto com número, utilizamos a função stringr::str_c() ou paste() . Veja o exemplo a seguir, onde replica-se o caso anterior com e sem espaço entre número e texto:\n\nlibrary(stringr)\n\n# create sequence\nmy_seq &lt;- 1:20\n\n# create character\nmy_text &lt;- 'text'\n\n# paste objects together (without space)\nmy_char &lt;- str_c(my_text, my_seq)\nprint(my_char)\n\nR&gt;  [1] \"text1\"  \"text2\"  \"text3\"  \"text4\"  \"text5\"  \"text6\" \nR&gt;  [7] \"text7\"  \"text8\"  \"text9\"  \"text10\" \"text11\" \"text12\"\nR&gt; [13] \"text13\" \"text14\" \"text15\" \"text16\" \"text17\" \"text18\"\nR&gt; [19] \"text19\" \"text20\"\n\n# paste objects together (with space)\nmy_char &lt;- str_c(my_text, my_seq, sep = ' ')\nprint(my_char)\n\nR&gt;  [1] \"text 1\"  \"text 2\"  \"text 3\"  \"text 4\"  \"text 5\" \nR&gt;  [6] \"text 6\"  \"text 7\"  \"text 8\"  \"text 9\"  \"text 10\"\nR&gt; [11] \"text 11\" \"text 12\" \"text 13\" \"text 14\" \"text 15\"\nR&gt; [16] \"text 16\" \"text 17\" \"text 18\" \"text 19\" \"text 20\"\n\n# paste objects together (with space)\nmy_char &lt;- paste(my_text, my_seq)\nprint(my_char)\n\nR&gt;  [1] \"text 1\"  \"text 2\"  \"text 3\"  \"text 4\"  \"text 5\" \nR&gt;  [6] \"text 6\"  \"text 7\"  \"text 8\"  \"text 9\"  \"text 10\"\nR&gt; [11] \"text 11\" \"text 12\" \"text 13\" \"text 14\" \"text 15\"\nR&gt; [16] \"text 16\" \"text 17\" \"text 18\" \"text 19\" \"text 20\"\n\n\nO mesmo procedimento também pode ser realizado com vetores de texto. Veja a seguir:\n\n# set character value\nmy_x &lt;- 'My name is'\n\n# set character vector\nmy_names &lt;- c('Marcelo', 'Ricardo', 'Tarcizio')\n\n# paste and print\nprint(str_c(my_x, my_names, sep = ' '))\n\nR&gt; [1] \"My name is Marcelo\"  \"My name is Ricardo\" \nR&gt; [3] \"My name is Tarcizio\"\n\n\nOutra possibilidade de construção de textos estruturados é a repetição do conteúdo de um objeto do tipo caractere. No caso de texto, utiliza-se a função stringr::str_dup() /strrep() para esse fim. Observe o exemplo a seguir:\n\nmy_char &lt;- str_dup(string = 'abc', times = 5)\nprint(my_char)\n\nR&gt; [1] \"abcabcabcabcabc\"\n\n\n\n\n9.2.3 Objetos Constantes de Texto\nO R também possibilita o acesso direto a todas as letras do alfabeto. Esses estão guardadas nos objetos reservados chamados letters e LETTERS:\n\n# print all letters in alphabet (no cap)\nprint(letters)\n\nR&gt;  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\"\nR&gt; [15] \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n\n# print all letters in alphabet (WITH CAP)\nprint(LETTERS)\n\nR&gt;  [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\"\nR&gt; [15] \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n\nObserve que em ambos os casos não é necessário criar os objetos. Por serem constantes embutidas automaticamente na área de trabalho do R, elas já estão disponíveis para uso. Podemos sobrescrever o nome do objeto com outro conteúdo, porém isso não é aconselhável. Nunca se sabe onde esse objeto constante está sendo usado. Outros objetos de texto constantes no R incluem month.abb e month.name. Veja a seguir o seu conteúdo:\n\n# print abreviation and full names of months\nprint(month.abb)\n\nR&gt;  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\"\nR&gt; [10] \"Oct\" \"Nov\" \"Dec\"\n\nprint(month.name)\n\nR&gt;  [1] \"January\"   \"February\"  \"March\"     \"April\"    \nR&gt;  [5] \"May\"       \"June\"      \"July\"      \"August\"   \nR&gt;  [9] \"September\" \"October\"   \"November\"  \"December\"\n\n\n\n\n9.2.4 Selecionando Pedaços de um Texto\nUm erro comum praticado por iniciantes é tentar selecionar pedaços de um texto através do uso de colchetes. Observe o código abaixo:\n\n# set char object\nmy_char &lt;- 'ABCDE'\n\n# print its second character: 'B' (WRONG - RESULT is NA)\nprint(my_char[2])\n\nR&gt; [1] NA\n\n\nO resultado NA indica que o segundo elemento de my_char não existe. Isso acontece porque o uso de colchetes refere-se ao acesso de elementos de um vetor atômico, e não de caracteres dentro de um texto maior. Observe o que acontece quando utilizamos my_char[1]:\n\nprint(my_char[1])\n\nR&gt; [1] \"ABCDE\"\n\n\nO resultado é simplesmente o texto ABCDE, que está localizado no primeiro item de my_char. Para selecionar pedaços de um texto, devemos utilizar a função específica stringr::str_sub() /substr() :\n\n# print third and fourth characters\nmy_substr &lt;- str_sub(string = my_char,\n                     start = 4,\n                     end = 4)\nprint(my_substr)\n\nR&gt; [1] \"D\"\n\n\nEssa função também funciona para vetores atômicos. Vamos assumir que você importou dados de texto e o conjunto de dados bruto contém um identificador de 3 dígitos de uma empresa, sempre na mesma posição do texto. Vamos simular a situação no R:\n\n# build char vec\nmy_char_vec &lt;- paste0(c('123','231','321'),\n                      ' - other ignorable text')\nprint(my_char_vec)\n\nR&gt; [1] \"123 - other ignorable text\"\nR&gt; [2] \"231 - other ignorable text\"\nR&gt; [3] \"321 - other ignorable text\"\n\n\nSó estamos interessados na informação das três primeiras letras de cada elemento em my_char_vec. Para selecioná-los, podemos usar as mesmas funções que antes.\n\n# get ids with stringr::str_sub\nids.vec &lt;- str_sub(my_char_vec, 1, 3)\nprint(ids.vec)\n\nR&gt; [1] \"123\" \"231\" \"321\"\n\n\n\n\n\n\n\n\nImportante\n\n\n\nOperações vetorizadas são comuns e esperadas no R. Quase tudo o que você pode fazer para um único elemento pode ser expandido para vetores. Isso facilita o desenvolvimento de rotinas pois pode-se facilmente realizar tarefas complicadas em uma série de elementos, em uma única linha de código.\n\n\n\n\n9.2.5 Localizando e Substituindo Pedaços de um Texto\nUma operação útil na manipulação de textos é a localização de letras e padrões específicos com funções stringr::str_locate() /regexpr() e stringr::str_locate_all() /gregexpr() . É importante destacar que, por default, essas funções utilizam de expressões do tipo regex - expressões regulares (thompson1968programming?). Essa é uma linguagem específica para processar textos. Diversos símbolos são utilizados para estruturar, procurar e isolar padrões textuais. Quando utilizada corretamente, o regex é bastante útil e de extrema valia.\nUsualmente, o caso mais comum em pesquisa é verificar a posição ou a existência de um texto menor dentro de um texto maior. Isto é, um padrão explícito e fácil de entender. Por isso, a localização e substituição de caracteres no próximo exemplo será do tipo fixo, sem o uso de regex. Tal informação pode ser passada às funções do pacote {stringr} (Wickham 2023b) através de outra função chamada stringr::fixed() .\nO exemplo a seguir mostra como encontrar o caractere D dentre uma série de caracteres.\n\nlibrary(stringr)\n\nmy_char &lt;- 'ABCDEF-ABCDEF-ABC'\npos = str_locate(string = my_char, pattern = fixed('D') )\nprint(pos)\n\nR&gt;      start end\nR&gt; [1,]     4   4\n\n\nObserve que a função stringr::str_locate() retorna apenas a primeira ocorrência de D. Para resgatar todas as ocorrências, devemos utilizar a função stringr::str_locate_all() :\n\n# set object\nmy_char &lt;- 'ABCDEF-ABCDEF-ABC'\n\n# find position of ALL 'D' using str_locate_all\npos = str_locate_all(string = my_char, pattern = fixed('D'))\nprint(pos)\n\nR&gt; [[1]]\nR&gt;      start end\nR&gt; [1,]     4   4\nR&gt; [2,]    11  11\n\n\nPara substituir caracteres em um texto, basta utilizar a função stringr::str_replace() ou sub() e stringr::str_locate_all() ou gsub() . Vale salientar que str_replace substitui a primeira ocorrência do caractere, enquanto stringr::str_locate_all() executa uma substituição global - isto é, aplica-se a todas as ocorrências. Veja a diferença a seguir:\n\n# set char object\nmy_char &lt;- 'ABCDEF-ABCDEF-ABC'\n\n# substitute the FIRST 'ABC' for 'XXX' with sub\nmy_char &lt;- sub(x = my_char,\n               pattern = 'ABC',\n               replacement = 'XXX')\nprint(my_char)\n\nR&gt; [1] \"XXXDEF-ABCDEF-ABC\"\n\n# substitute the FIRST 'ABC' for 'XXX' with str_replace\nmy_char &lt;- 'ABCDEF-ABCDEF-ABC'\nmy_char &lt;- str_replace(string = my_char,\n                       pattern = fixed('ABC'),\n                       replacement = 'XXX')\nprint(my_char)\n\nR&gt; [1] \"XXXDEF-ABCDEF-ABC\"\n\n\nE agora fazemos uma substituição global dos caracteres.\n\n# set char object\nmy_char &lt;- 'ABCDEF-ABCDEF-ABC'\n\n# substitute the FIRST 'ABC' for 'XXX' with str_replace\nmy_char &lt;- str_replace_all(string = my_char,\n                           pattern = 'ABC',\n                           replacement = 'XXX')\nprint(my_char)\n\nR&gt; [1] \"XXXDEF-XXXDEF-XXX\"\n\n\nMais uma vez, vale ressaltar que as operações de substituição também funcionam em vetores. Dê uma olhada no próximo exemplo.\n\n# set char object\nmy_char &lt;- c('ABCDEF','DBCFE','ABC')\n\n# create an example of vector\nmy_char_vec &lt;- str_c(sample(my_char, 5, replace = T),\n                     sample(my_char, 5, replace = T),\n                     sep = ' - ')\n\n# show it\nprint(my_char_vec)\n\nR&gt; [1] \"ABCDEF - ABC\"    \"ABCDEF - ABCDEF\" \"ABCDEF - ABC\"   \nR&gt; [4] \"ABCDEF - DBCFE\"  \"DBCFE - ABCDEF\"\n\n# substitute all occurrences of 'ABC'\nmy_char_vec &lt;- str_replace_all(string = my_char_vec,\n                               pattern = 'ABC',\n                               replacement = 'XXX')\n\n# print result\nprint(my_char_vec)\n\nR&gt; [1] \"XXXDEF - XXX\"    \"XXXDEF - XXXDEF\" \"XXXDEF - XXX\"   \nR&gt; [4] \"XXXDEF - DBCFE\"  \"DBCFE - XXXDEF\"\n\n\n\n\n9.2.6 Separando Textos\nEm algumas situações, principalmente no processamento de textos, é possível que se esteja interessado em quebrar um texto de acordo com algum separador. Por exemplo, o texto abc ; bcd ; adf apresenta informações demarcadas pelo símbolo ;. Para separar um texto em várias partes, utilizamos a função stringr::str_split() /strsplit() . Essas quebram o texto em diversas partes de acordo com algum caractere escolhido. Observe os exemplos a seguir:\n\n# set char\nmy_char &lt;- 'ABCXABCXBCD'\n\n# split it based on 'X' and using stringr::str_split\nsplit_char &lt;- str_split(my_char, 'X')\n\n# print result\nprint(split_char)\n\nR&gt; [[1]]\nR&gt; [1] \"ABC\" \"ABC\" \"BCD\"\n\n\nA saída dessa função é um objeto do tipo lista. Para acessar os elementos de uma lista, deve-se utilizar o operador [[ ]]. Por exemplo, para acessar o texto bcd da lista split_char, executa-se o seguinte código:\n\nprint(split_char[[1]][2])\n\nR&gt; [1] \"ABC\"\n\n\nPara visualizar um exemplo de dividir textos em vetores, veja o próximo código.\n\n# set char\nmy_char_vec &lt;- c('ABCDEF','DBCFE','ABFC','ACD')\n\n# split it based on 'B' and using stringr::strsplit\nsplit_char &lt;- str_split(my_char_vec, 'B')\n\n# print result\nprint(split_char)\n\nR&gt; [[1]]\nR&gt; [1] \"A\"    \"CDEF\"\nR&gt; \nR&gt; [[2]]\nR&gt; [1] \"D\"   \"CFE\"\nR&gt; \nR&gt; [[3]]\nR&gt; [1] \"A\"  \"FC\"\nR&gt; \nR&gt; [[4]]\nR&gt; [1] \"ACD\"\n\n\nObserve como, novamente, um objeto do tipo list é retornado. Cada elemento é correspondente ao processo de quebra de texto em my_char.\n\n\n9.2.7 Descobrindo o Número de Caracteres de um Texto\nPara descobrir o número de caracteres de um texto, utilizamos a função stringr::str_length() /nchar() . Ela também funciona para vetores atômicos de texto. Veja os exemplos mostrados a seguir:\n\n# set char\nmy_char &lt;- 'abcdef'\n\n# print number of characters using stringr::str_length\nprint(str_length(my_char))\n\nR&gt; [1] 6\n\n\nE agora um exemplo com vetores.\n\n#set char\nmy_char &lt;- c('a', 'ab', 'abc')\n\n# print number of characters using stringr::str_length\nprint(str_length(my_char))\n\nR&gt; [1] 1 2 3\n\n\n\n\n9.2.8 Gerando Combinações de Texto\nUm truque útil no R é usar as funções expand.grid() e tidyr::expand_grid() para criar todas as combinações possíveis de elementos em diferentes objetos. Isso é útil quando você quer criar um vetor de texto combinando todos os elementos possíveis de diferentes vetores. Por exemplo, se quisermos criar um vetor com todas as combinações entre dois vetores de texto, podemos escrever:\n\nlibrary(tidyverse)\n\n# set vectors\nmy_vec_1 &lt;- c('John ', 'Claire ', 'Adam ')\nmy_vec_2 &lt;- c('is fishing.', 'is working.')\n\n# create df with all combinations\nmy_df &lt;- tidyr::expand_grid(name = my_vec_1,\n                     verb = my_vec_2)\n\n# print df\nprint(my_df)\n\nR&gt; # A tibble: 6 × 2\nR&gt;   name      verb       \nR&gt;   &lt;chr&gt;     &lt;chr&gt;      \nR&gt; 1 \"John \"   is fishing.\nR&gt; 2 \"John \"   is working.\nR&gt; 3 \"Claire \" is fishing.\nR&gt; 4 \"Claire \" is working.\nR&gt; 5 \"Adam \"   is fishing.\nR&gt; 6 \"Adam \"   is working.\n\n# paste columns together in tibble\nmy_df &lt;- my_df |&gt;\n  mutate(phrase = paste0(name, verb) )\n\n# print result\nprint(my_df)\n\nR&gt; # A tibble: 6 × 3\nR&gt;   name      verb        phrase            \nR&gt;   &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt;             \nR&gt; 1 \"John \"   is fishing. John is fishing.  \nR&gt; 2 \"John \"   is working. John is working.  \nR&gt; 3 \"Claire \" is fishing. Claire is fishing.\nR&gt; 4 \"Claire \" is working. Claire is working.\nR&gt; 5 \"Adam \"   is fishing. Adam is fishing.  \nR&gt; 6 \"Adam \"   is working. Adam is working.\n\n\nAqui, usamos a função tidyr::expand_grid() para criar um dataframe contendo todas as combinações possíveis de my_vec_1 e my_vec_2. Posteriormente, colamos o conteúdo das colunas do dataframe usando stringr::str_c() .\n\n\n9.2.9 Codificação de Objetos character\nPara o R, um string de texto é apenas uma sequência de bytes. A tradução de bytes para caracteres é realizada de acordo com uma estrutura de codificação. Para a maioria dos casos de uso do R, especialmente em países de língua inglesa, a codificação de caracteres não é um problema pois os textos importados no R já possuem a codificação correta. Ao lidar com dados de texto em diferentes idiomas, tal como Português do Brasil, a codificação de caracteres é algo que você deve entender pois eventualmente precisará lidar com isso.\nVamos explorar um exemplo. Aqui, vamos importar dados de um arquivo de texto com a codificação 'ISO-8859-9' e verificar o resultado.\n\n# read text file\nmy_f &lt;- introR::data_path('CH07_FileWithLatinChar_Latin1.txt')\n\nmy_char &lt;- readr::read_lines(my_f)\n\n# print it\nprint(my_char)\n\nR&gt; [1] \"A casa \\xe9 bonita e tem muito espa\\xe7o\"\n\n\nO conteúdo original do arquivo é um texto em português. Como você pode ver, a saída de readr::read_lines() mostra todos os caracteres latinos com símbolos estranhos. Isso ocorre pois a codificação foi manualmente trocada no arquivo para 'ISO-8859-9', enquanto a função readr::read_lines() utiliza 'UTF-8' como default. A solução mais fácil e direta é modificar a codificação esperada do arquivo nas entradas de readr::read_lines() . Veja a seguir, onde importamos um arquivo com a codificação correta ('Latin1'):\n\nmy_char &lt;- readr::read_lines(my_f, \n                             locale = readr::locale(encoding='Latin1'))\n\n# print it\nprint(my_char)\n\nR&gt; [1] \"A casa é bonita e tem muito espaço\"\n\n\nOs caracteres latinos agora estão corretos pois a codificação em readr::read_lines() é a mesma do arquivo, 'Latin1'. Uma boa política neste tópico é sempre verificar a codificação de arquivos de texto importados e combiná-lo em R. A maioria das funções de importação tem uma opção para fazê-lo. Quando possível, sempre dê preferência para 'UTF-8'. Caso necessário, programas de edição de texto, tal como o notepad++, possuem ferramentas para verificar e trocar a codificação de um arquivo.\n\n\n9.2.10 Outras Funções Úteis\nstringr::str_to_lower/base::tolower - Converte um objeto de texto para letras minúsculas.\n\nprint(stringr::str_to_lower('ABC'))\n\nR&gt; [1] \"abc\"\n\n\nstringr::str_to_upper/base::toupper - Convertem um texto em letras maiúsculas.\n\nprint(toupper('abc'))\n\nR&gt; [1] \"ABC\"\n\nprint(stringr::str_to_upper('abc'))\n\nR&gt; [1] \"ABC\""
  },
  {
    "objectID": "09-objetos-basicos.html#fatores",
    "href": "09-objetos-basicos.html#fatores",
    "title": "9  As Classes Básicas de Objetos",
    "section": "9.3 Fatores",
    "text": "9.3 Fatores\nA classe de fatores (factor() ) é utilizada para representar grupos ou categorias dentro de uma base de dados no formato tabular. Por exemplo, imagine um banco de informações com os gastos de diferentes pessoas ao longo de um ano. Nessa base de dados existe um item que define o gênero do indivíduo: masculino ou feminino (M ou F). Essa respectiva coluna pode ser importada e representada como texto, porém, no R, a melhor maneira de representá-la é através do objeto fator, uma vez que a mesma representa uma categoria.\nA classe de fatores oferece um significado especial para denotar grupos dentro dos dados. Essa organização é integrada aos pacotes e facilita muito a vida do usuário. Por exemplo, caso quiséssemos criar um gráfico para cada grupo dentro da nossa base de dados, poderíamos fazer o mesmo simplesmente indicando a existência de uma variável de fator para a função de criação da figura. Outra possibilidade é determinar se as diferentes médias de uma variável numérica são estatisticamente diferentes para os grupos dos nossos dados. Podemos também estimar um determinado modelo estatístico para cada grupo. Quando os dados de categorias são representados apropriadamente, o uso das funções do R torna-se mais fácil e eficiente.\n\n9.3.1 Criando Fatores\nA criação de fatores dá-se através da função factor() :\n\nmy_factor &lt;- factor(c('M', 'F', 'M', 'M', 'F'))\nprint(my_factor)\n\nR&gt; [1] M F M M F\nR&gt; Levels: F M\n\n\nObserve, no exemplo anterior, que a apresentação de fatores com a função print() mostra os seus elementos e também o item chamado Levels. Esse último identifica os possíveis grupos que abrangem o vetor - nesse caso apenas M e F. Se tivéssemos um número maior de grupos, o item Levels aumentaria. Veja a seguir:\n\nmy_factor &lt;- factor(c('M','F','M','M','F','ND'))\nprint(my_factor)\n\nR&gt; [1] M  F  M  M  F  ND\nR&gt; Levels: F M ND\n\n\nUm ponto importante na criação de fatores é que os Levels são inferidos através dos dados criados, e isso pode não corresponder à realidade. Por exemplo, observe o seguinte exemplo:\n\nmy_status &lt;- factor(c('Solteiro', 'Solteiro', 'Solteiro'))\nprint(my_status)\n\nR&gt; [1] Solteiro Solteiro Solteiro\nR&gt; Levels: Solteiro\n\n\nNota-se que, por ocasião, os dados mostram apenas uma categoria: Solteiro. Entretanto, sabe-se que outra categoria do tipo Casado é esperada. No caso de utilizarmos o objeto my_status da maneira que foi definida anteriormente, omitiremos a informação de outros gêneros, e isso pode ocasionar problemas no futuro tal como a criação de gráficos incompletos. Nessa situação, o correto é definir os Levels manualmente da seguinte maneira:\n\nmy_status &lt;- factor(c('Solteiro', 'Solteiro', 'Solteiro'),\n                    levels = c('Solteiro', 'Casado'))\nprint(my_status)\n\nR&gt; [1] Solteiro Solteiro Solteiro\nR&gt; Levels: Solteiro Casado\n\n\n\n\n9.3.2 Modificando Fatores\nUm ponto importante sobre os objetos do tipo fator é que seus Levels são imutáveis e não atualizam-se com a entrada de novos dados. Em outras palavras, não é possível modificar os valores dos Levels após a criação do objeto. Toda nova informação que não for compatível com os Levels do objeto será transformada em NA (Not available) e uma mensagem de warning irá aparecer na tela. Essa limitação pode parecer estranha a primeira vista porém, na prática, ela evita possíveis erros no código. Veja o exemplo a seguir:\n\n# set factor\nmy_factor &lt;- factor(c('a', 'b', 'a', 'b'))\n\n# change first element of a factor to 'c'\nmy_factor[1] &lt;- 'c'\n\nR&gt; Warning in `[&lt;-.factor`(`*tmp*`, 1, value = \"c\"): invalid\nR&gt; factor level, NA generated\n\n# print result\nprint(my_factor)\n\nR&gt; [1] &lt;NA&gt; b    a    b   \nR&gt; Levels: a b\n\n\nNesse caso, a maneira correta de proceder é primeiro transformar o objeto da classe fator para a classe caractere e depois realizar a conversão:\n\n# set factor\nmy_factor &lt;- factor(c('a', 'b', 'a', 'b'))\n\n# change factor to character\nmy_char &lt;- as.character(my_factor)\n\n# change first element\nmy_char[1] &lt;- 'c'\n\n# mutate it back to class factor\nmy_factor &lt;- factor(my_char)\n\n# show result\nprint(my_factor)\n\nR&gt; [1] c b a b\nR&gt; Levels: a b c\n\n\nUtilizando essas etapas temos o resultado desejado no vetor my_factor, com a definição de três Levels: a, b e c.\nO universo {tidyverse} (Wickham 2023c) também possui um pacote próprio para manipular fatores, o {forcats} (Wickham 2023a). Para o problema atual de modificação de fatores, podemos utilizar função forcats::fct_recode() . Veja um exemplo a seguir, onde trocamos as siglas dos fatores:\n\nlibrary(forcats)\n\n# set factor\nmy.fct &lt;- factor(c('A', 'B', 'C', 'A', 'C', 'M', 'N'))\n\n# modify factors\nmy.fct &lt;- fct_recode(my.fct,\n                     'D' = 'A',\n                     'E' = 'B',\n                     'F' = 'C')\n\n# print result\nprint(my.fct)\n\nR&gt; [1] D E F D F M N\nR&gt; Levels: D E F M N\n\n\nObserve como o uso da função forcats::fct_recode() é intuitivo. Basta indicar o novo nome dos grupos com o operador de igualdade.\n\n\n9.3.3 Convertendo Fatores para Outras Classes\nOutro ponto importante no uso de fatores é a sua conversão para outras classes, especialmente a numérica. Quando convertemos um objeto de tipo fator para a classe caractere, o resultado é o esperado:\n\n# create factor\nmy_char &lt;-factor(c('a', 'b', 'c'))\n\n# convert and print\nprint(as.character(my_char))\n\nR&gt; [1] \"a\" \"b\" \"c\"\n\n\nPorém, quando fazemos o mesmo procedimento para a classe numérica, o que o R retorna é longe do esperado:\n\n# set factor\nmy_values &lt;- factor(5:10)\n\n# convert to numeric (WRONG)\nprint(as.numeric(my_values))\n\nR&gt; [1] 1 2 3 4 5 6\n\n\nEsse resultado pode ser explicado pelo fato de que, internamente, fatores são armazenados como índices, indo de 1 até o número total de Levels. Essa simplificação minimiza o uso da memória do computador. Quando pedimos ao R para transformar esses fatores em números, ele entende que buscamos o número do índice e não do valor. Para contornar, é fácil: basta transformar o objeto fator em caractere e, depois, em numérico, conforme mostrado a seguir:\n\n# converting factors to character and then to numeric\nprint(as.numeric(as.character(my_values)))\n\nR&gt; [1]  5  6  7  8  9 10\n\n\n\n\n\n\n\n\nCuidado\n\n\n\nTenha muito cuidado ao transformar fatores em números. Lembre-se sempre de que o retorno da conversão direta serão os índices dos levels e não os valores em si. Esse é um bug bem particular que pode ser difícil de identificar em um código complexo.\n\n\n\n\n9.3.4 Criando Tabelas de Contingência\nApós a criação de um fator, podemos calcular a ocorrência de cada fator com a função table() . Essa também é chamada de tabela de contingência. Em um caso simples, com apenas um fator, a função table() conta o número de ocorrências de cada categoria, como a seguir:\n\n# create factor\nmy_factor &lt;- factor(sample(c('Pref', 'Ord'),\n                           size = 20,\n                           replace = TRUE))\n\n# print contingency table\nprint(table(my_factor))\n\nR&gt; my_factor\nR&gt;  Ord Pref \nR&gt;    9   11\n\n\nUm caso mais avançado do uso de table() é utilizar mais de um fator para a criação da tabela. Veja o exemplo a seguir:\n\n# set factors\nmy_factor_1 &lt;- factor(sample(c('Pref', 'Ord'),\n                             size = 20,\n                             replace = TRUE))\n\nmy_factor_2 &lt;- factor(sample(paste('Grupo', 1:3),\n                             size = 20,\n                             replace = TRUE))\n\n# print contingency table with two factors\nprint(table(my_factor_1, my_factor_2))\n\nR&gt;            my_factor_2\nR&gt; my_factor_1 Grupo 1 Grupo 2 Grupo 3\nR&gt;        Ord        2       4       3\nR&gt;        Pref       3       4       4\n\n\nA tabela criada anteriormente mostra o número de ocorrências para cada combinação de fator. Essa é uma ferramenta descritiva simples, mas bastante informativa para a análise de grupos de dados.\n\n\n9.3.5 Outras Funções\nlevels - Retorna os Levels de um objeto da classe fator.\n\nmy_factor &lt;- factor(c('A', 'A', 'B', 'C', 'B'))\nprint(levels(my_factor))\n\nR&gt; [1] \"A\" \"B\" \"C\"\n\n\nas.factor - Transforma um objeto para a classe fator.\n\nmy_y &lt;- c('a','b', 'c', 'c', 'a')\nmy_factor &lt;- as.factor(my_y)\nprint(my_factor)\n\nR&gt; [1] a b c c a\nR&gt; Levels: a b c\n\n\nsplit - Com base em um objeto de fator, cria uma lista com valores de outro objeto. Esse comando é útil para separar dados de grupos diferentes e aplicar alguma função com sapply() ou lapply.\n\nmy_factor &lt;- factor(c('A','B','C','C','C','B'))\nmy_x &lt;- 1:length(my_factor)\n\nmy_l &lt;- split(x = my_x, f = my_factor)\n\nprint(my_l)\n\nR&gt; $A\nR&gt; [1] 1\nR&gt; \nR&gt; $B\nR&gt; [1] 2 6\nR&gt; \nR&gt; $C\nR&gt; [1] 3 4 5"
  },
  {
    "objectID": "09-objetos-basicos.html#valores-lógicos",
    "href": "09-objetos-basicos.html#valores-lógicos",
    "title": "9  As Classes Básicas de Objetos",
    "section": "9.4 Valores Lógicos",
    "text": "9.4 Valores Lógicos\nTestes lógicos em dados são centrais no uso do R. Em uma única linha de código podemos testar condições para uma grande quantidade de casos. Esse cálculo é muito utilizado para encontrar casos extremos nos dados (outliers) e também para separar diferentes amostras de acordo com algum critério.\n\n9.4.1 Criando Valores Lógicos\nEm uma sequência de 1 até 10, podemos verificar quais são os elementos maiores que 5 com o seguinte código:\n\n# set numerical\nmy_x &lt;- 1:10\n\n# print a logical test\nprint(my_x &gt; 5)\n\nR&gt;  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\nR&gt; [10]  TRUE\n\n# print position of elements from logical test\nprint(which(my_x &gt; 5))\n\nR&gt; [1]  6  7  8  9 10\n\n\nA função which() do exemplo anterior retorna os índices onde a condição é verdadeira (TRUE). O uso do which() é recomendado quando se quer saber a posição de elementos que satisfazem alguma condição.\nPara realizar testes de igualdade, basta utilizar o símbolo de igualdade duas vezes (==).\n\n# create char\nmy_char &lt;- rep(c('abc','bcd'), 5)\n\n# print its contents\nprint(my_char)\n\nR&gt;  [1] \"abc\" \"bcd\" \"abc\" \"bcd\" \"abc\" \"bcd\" \"abc\" \"bcd\" \"abc\"\nR&gt; [10] \"bcd\"\n\n# print logical test\nprint(my_char == 'abc')\n\nR&gt;  [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\nR&gt; [10] FALSE\n\n\nPara o teste de inigualdades, utilizamos o símbolo !=:\n\n# print inequality test\nprint(my_char != 'abc')\n\nR&gt;  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE\nR&gt; [10]  TRUE\n\n\nDestaca-se que também é possível testar condições múltiplas, isto é, a ocorrência simultânea de eventos. Utilizamos o operador & para esse propósito. Por exemplo: se quiséssemos verificar quais são os valores de uma sequência de 1 a 10 que são maiores que 4 e menores que 7, escreveríamos:\n\nmy_x &lt;- 1:10\n\n# print logical for values higher than 4 and lower than 7\nprint((my_x &gt; 4)&(my_x &lt; 7) )\n\nR&gt;  [1] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE\nR&gt; [10] FALSE\n\n# print the actual values\nidx &lt;- which( (my_x &gt; 4)&(my_x &lt; 7) )\nprint(my_x[idx])\n\nR&gt; [1] 5 6\n\n\nPara testar condições não simultâneas, isto é, ocorrências de um ou outro evento, utilizamos o operador |. Por exemplo: considerando a sequência anterior, acharíamos os valores maiores que 7 ou menores que 4 escrevendo:\n\n# location of elements higher than 7 or lower than 4\nidx &lt;- which( (my_x &gt; 7)|(my_x &lt; 4) )\n\n# print elements from previous condition\nprint(my_x[idx])\n\nR&gt; [1]  1  2  3  8  9 10\n\n\nObserve que, em ambos os casos de uso de testes lógicos, utilizamos parênteses para encapsular as condições lógicas. Poderíamos ter escrito idx &lt;- which( my_x &gt; 7|my_x &lt; 4 ), porém o uso do parênteses deixa o código mais claro ao isolar os testes de condições e sinalizar que o resultado da operação será um vetor lógico. Em alguns casos, porém, o uso do parênteses indica hierarquia na ordem das operações e portanto não pode ser ignorado.\nOutro uso interessante de objetos lógicos é o teste para saber se um item ou mais pertence a um vetor ou não. Para isso utilizamos o operador %in%. Por exemplo, imagine que tens os tickers de duas ações, c('ABC', 'DEF') e queres saber se é possível encontrar esses tickers na coluna de outra base de dados. Essa é uma operação semelhante ao uso do teste de igualdade, porém em notação vetorial. Veja um exemplo a seguir:\n\nlibrary(dplyr)\n# location of elements higher than 7 or lower than 4\nmy_tickers &lt;- c('ABC', 'DEF')\n\n# set df\nn_obs &lt;- 100\ndf_temp &lt;- tibble(tickers = sample(c('ABC', 'DEF', 'GHI', 'JKL'),\n                                   size = n_obs,\n                                   replace = TRUE),\n                  ret = rnorm(n_obs, sd = 0.05) )\n\n# find rows with selected tickers\nidx &lt;- df_temp$tickers %in% my_tickers\n\n# print elements from previous condition\nglimpse(df_temp[idx, ])\n\nR&gt; Rows: 43\nR&gt; Columns: 2\nR&gt; $ tickers &lt;chr&gt; \"ABC\", \"ABC\", \"ABC\", \"DEF\", \"DEF\", \"ABC\", …\nR&gt; $ ret     &lt;dbl&gt; 0.042864781, 0.017056405, 0.011198439, 0.0…\n\n\nO dataframe mostrado na tela possui dados apenas para ações em my_tickers."
  },
  {
    "objectID": "09-objetos-basicos.html#datas-e-tempo",
    "href": "09-objetos-basicos.html#datas-e-tempo",
    "title": "9  As Classes Básicas de Objetos",
    "section": "9.5 Datas e Tempo",
    "text": "9.5 Datas e Tempo\nA representação e manipulação de datas é um importante aspecto das pesquisas em Finanças e Economia. Manipular datas e horários de forma correta, levando em conta mudanças decorridas de horário de verão, feriados locais, em diferentes zonas de tempo, não é uma tarefa fácil! Felizmente, o R fornece um grande suporte para qualquer tipo de operação com datas e tempo.\nNesta seção estudaremos as funções e classes nativas que representam e manipulam o tempo em R. Aqui, daremos prioridade as funções do pacote {lubridate} (Spinu, Grolemund, and Wickham 2023). Existem, no entanto, muitos pacotes que podem ajudar o usuário a processar objetos do tipo data e tempo de forma mais avançada. Caso alguma operação com data e tempo não for encontrada aqui, sugiro o estudo dos pacotes {chron} (R-chron?), {timeDate} (R-timeDate?) e {bizdays} (R-bizdays?).\nAntes de começarmos, vale relembrar que toda data no R segue o formato ISO 8601 (YYYY-MM-DD), onde YYYY é o ano em quatro números, MM é o mês e DD é o dia. Por exemplo, uma data em ISO 8601 é 2024-01-10. Deves familiarizar-se com esse formato pois toda importação de dados com formato de datas diferente desta notação exigirá conversão. Felizmente, essa operação é bastante simples de executar com o {lubridate} (Spinu, Grolemund, and Wickham 2023).\n\n9.5.1 Criando Datas Simples\nNo R, existem diversas classes que podem representar datas. A escolha entre uma classe de datas e outra baseia-se na necessidade da pesquisa. Em muitas situações não é necessário saber o horário, enquanto que em outras isso é extremamente pertinente pois os dados são coletados ao longo de um dia.\nA classe mais básica de datas é Date. Essa indica dia, mês e ano, apenas. No {lubridate} (Spinu, Grolemund, and Wickham 2023), criamos datas verificando o formato da data de entrada e as funções lubridate::ymd() (year-month-date), lubridate::dmy() (day-month-year) e lubridate::mdy() (month-day-year). Veja a seguir:\n\nlibrary(lubridate)\n\n# set Date object\nprint(ymd('2021-06-24'))\n\nR&gt; [1] \"2021-06-24\"\n\n# set Date object\nprint(dmy('24-06-2021'))\n\nR&gt; [1] \"2021-06-24\"\n\n# set Date object\nprint(mdy('06-24-2021'))\n\nR&gt; [1] \"2021-06-24\"\n\n\nNote que as funções retornam exatamente o mesmo objeto. A diferença no uso é somente pela forma que a data de entrada está estruturada com a posição do dia, mês e ano.\nUm benefício no uso das funções do pacote {lubridate} (Spinu, Grolemund, and Wickham 2023) é que as mesmas são inteligentes ao lidar com formatos diferentes. Observe no caso anterior que definimos os elementos das datas com o uso do traço (-) como separador e valores numéricos. Outros formatos também são automaticamente reconhecidos:\n\n# set Date object\nprint(ymd('2021/06/24'))\n\nR&gt; [1] \"2021-06-24\"\n\n# set Date object\nprint(ymd('2021&06&24'))\n\nR&gt; [1] \"2021-06-24\"\n\n# set Date object\nprint(ymd('2021 june 24'))\n\nR&gt; [1] \"2021-06-24\"\n\n# set Date object\nprint(dmy('24 of june 2021'))\n\nR&gt; [1] \"2021-06-24\"\n\n\nIsso é bastante útil pois o formato de datas no Brasil é dia/mês/ano (DD/MM/YYYY). Ao usar lubridate::dmy() para uma data brasileira, a conversão é correta:\n\n# set Date from dd/mm/yyyy\nmy_date &lt;- dmy('24/06/2021')\n\n# print result\nprint(my_date)\n\nR&gt; [1] \"2021-06-24\"\n\n\nJá no pacote {base} (R Core Team 2023), a função correspondente é as.Date() . O formato da data, porém, deve ser explicitamente definido com argumento format() , conforme mostrado a seguir:\n\n# set Date from dd/mm/yyyy with the definition of format\nmy_date &lt;- as.Date('24/06/2021', format = '%d/%m/%Y')\n\n# print result\nprint(my_date)\n\nR&gt; [1] \"2021-06-24\"\n\n\nOs símbolos utilizados na entrada format() , tal como %d e %Y, são indicadores de formato, os quais definem a forma em que a data a ser convertida está estruturada. Nesse caso, os símbolos %Y, %m e %d definem ano, mês e dia, respectivamente. Existem diversos outros símbolos que podem ser utilizados para processar datas em formatos específicos. Um panorama das principais codificações é apresentado a seguir:\n\n\n\nCódigo\nValor\nExemplo\n\n\n\n\n%d\ndia do mês (decimal)\n0\n\n\n%m\nmês (decimal)\n12\n\n\n%b\nmês (abreviado)\nAbr\n\n\n%B\nmês (nome completo)\nAbril\n\n\n%y\nano (2 dígitos)\n16\n\n\n%Y\nano (4 dígitos)\n2021\n\n\n\nOs símbolos anteriores permitem a criação de datas a partir de variados formatos. Observe como a utilização das funções do {lubridate} (Spinu, Grolemund, and Wickham 2023), em relação a {base} (R Core Team 2023), são mais simples e fáceis de utilizar, justificando a nossa escolha.\n\n\n9.5.2 Criando Sequências de Datas\nUm aspecto interessante no uso de objetos do tipo Date é que eles interagem com operações de adição de valores numéricos e com testes lógicos de comparação de datas. Por exemplo: caso quiséssemos adicionar um dia à data my_date criada anteriormente, bastaria somar o valor 1 ao objeto:\n\n# create date\nmy_date &lt;- ymd('2021-06-24')\n\n# find next day\nmy_date_2 &lt;- my_date + 1\n\n# print result\nprint(my_date_2)\n\nR&gt; [1] \"2021-06-25\"\n\n\nA propriedade também funciona com vetores, o que deixa a criação de sequências de datas muito fácil. Nesse caso, o próprio R encarrega-se de verificar o número de dias em cada mês.\n\n# create a sequence of Dates\nmy_date_vec &lt;- my_date + 0:15\n\n# print it\nprint(my_date_vec)\n\nR&gt;  [1] \"2021-06-24\" \"2021-06-25\" \"2021-06-26\" \"2021-06-27\"\nR&gt;  [5] \"2021-06-28\" \"2021-06-29\" \"2021-06-30\" \"2021-07-01\"\nR&gt;  [9] \"2021-07-02\" \"2021-07-03\" \"2021-07-04\" \"2021-07-05\"\nR&gt; [13] \"2021-07-06\" \"2021-07-07\" \"2021-07-08\" \"2021-07-09\"\n\n\nUma maneira mais customizável de criar sequências de datas é utilizar a função seq() . Com ela, é possível definir intervalos diferentes de tempo e até mesmo o tamanho do vetor de saída. Caso quiséssemos uma sequência de datas de dois em dois dias, poderíamos utilizar o seguinte código: \n\n# set first and last Date\nmy_date_1 &lt;- ymd('2021-03-07')\nmy_date_2 &lt;- ymd('2021-03-20')\n\n# set sequence\nmy_date_date &lt;- seq(from = my_date_1,\n                    to = my_date_2,\n                    by = '2 days')\n\n# print result\nprint(my_date_date)\n\nR&gt; [1] \"2021-03-07\" \"2021-03-09\" \"2021-03-11\" \"2021-03-13\"\nR&gt; [5] \"2021-03-15\" \"2021-03-17\" \"2021-03-19\"\n\n\nCaso quiséssemos de duas em duas semanas, escreveríamos:\n\n# set first and last Date\nmy_date_1 &lt;- ymd('2021-03-07')\nmy_date_2 &lt;- ymd('2021-04-20')\n\n# set sequence\nmy_date_date &lt;- seq(from = my_date_1,\n                    to = my_date_2,\n                    by = '2 weeks')\n\n# print result\nprint(my_date_date)\n\nR&gt; [1] \"2021-03-07\" \"2021-03-21\" \"2021-04-04\" \"2021-04-18\"\n\n\nOutra forma de utilizar seq() é definir o tamanho desejado do objeto de saída. Por exemplo, caso quiséssemos um vetor de datas com 10 elementos, usaríamos:\n\n# set first and last Date\nmy_date_1 &lt;- ymd('2021-03-07')\nmy_date_2 &lt;- ymd('2021-10-20')\n\n# set sequence\nmy_date_vec &lt;- seq(from = my_date_1,\n                    to = my_date_2,\n                    length.out = 10)\n\n# print result\nprint(my_date_vec)\n\nR&gt;  [1] \"2021-03-07\" \"2021-04-01\" \"2021-04-26\" \"2021-05-21\"\nR&gt;  [5] \"2021-06-15\" \"2021-07-11\" \"2021-08-05\" \"2021-08-30\"\nR&gt;  [9] \"2021-09-24\" \"2021-10-20\"\n\n\nO intervalo entre as datas em my_date_vec é definido automaticamente pelo R.\n\n\n9.5.3 Operações com Datas\nÉ possível descobrir a diferença de dias entre datas simplesmente diminuindo uma data da outra:\n\n# set dates\nmy_date_1 &lt;- ymd('2015-06-24')\nmy_date_2 &lt;- ymd('2016-06-24')\n\n# calculate difference\ndiff_date &lt;- my_date_2 - my_date_1\n\n# print result\nprint(diff_date)\n\nR&gt; Time difference of 366 days\n\n\nA saída da operação de subtração é um objeto da classe diffdate, o qual possui a classe de lista como sua estrutura básica. Destaca-se que a notação de acesso aos elementos da classe diffdate é a mesma utilizada para listas. O valor numérico do número de dias está contido no primeiro elemento de diff_date:\n\n# print difference of days as numerical value\nprint(diff_date[[1]])\n\nR&gt; [1] 366\n\n\nPodemos testar se uma data é maior do que outra com o uso das operações de comparação:\n\n# set date and vector\nmy_date_1 &lt;- ymd('2016-06-20')\nmy_date_vec &lt;- ymd('2016-06-20') + seq(-5,5)\n\n# test which elements of my_date_vec are older than my_date_1\nmy_test &lt;- (my_date_vec &gt; my_date_1)\n\n# print result\nprint(my_test)\n\nR&gt;  [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\nR&gt; [10]  TRUE  TRUE\n\n\nA operação anterior é bastante útil quando se está buscando filtrar um determinado período de tempo nos dados. Nesse caso, basta buscar nas datas o período específico em que estamos interessados e utilizar o objeto lógico da comparação para selecionar os elementos. Veja o exemplo a seguir:\n\nlibrary(dplyr)\nlibrary(lubridate)\n\n# set first and last dates\nfirst_date &lt;- ymd('2016-06-01')\nlast_date &lt;- ymd('2016-06-15')\n\n# create `dataframe` and glimpse it\nmy_temp_df &lt;- tibble(date_vec = ymd('2016-05-25') + seq(0,30),\n                     prices=seq(1,10,\n                                length.out = length(date_vec)))\n\nglimpse(my_temp_df)\n\nR&gt; Rows: 31\nR&gt; Columns: 2\nR&gt; $ date_vec &lt;date&gt; 2016-05-25, 2016-05-26, 2016-05-27, 2016…\nR&gt; $ prices   &lt;dbl&gt; 1.0, 1.3, 1.6, 1.9, 2.2, 2.5, 2.8, 3.1, 3…\n\n# find dates that are between the first and last date\nmy_idx &lt;- (my_temp_df$date_vec &gt;= first_date) &\n  (my_temp_df$date_vec &lt;= last_date)\n\n# use index to filter `dataframe`\nmy_temp_df_filtered &lt;- my_temp_df |&gt;\n  filter(my_idx) |&gt;\n  glimpse()\n\nR&gt; Rows: 15\nR&gt; Columns: 2\nR&gt; $ date_vec &lt;date&gt; 2016-06-01, 2016-06-02, 2016-06-03, 2016…\nR&gt; $ prices   &lt;dbl&gt; 3.1, 3.4, 3.7, 4.0, 4.3, 4.6, 4.9, 5.2, 5…\n\n\nNesse caso, o vetor final de preços da coluna prices contém apenas informações para o período entre first_date e last_date.\n\n\n9.5.4 Lidando com Data e Tempo\nO uso da classe Date é suficiente quando se está lidando apenas com datas. Em casos em que é necessário levar em consideração o horário, temos que utilizar um objeto do tipo datetime.\nNo pacote {base} (R Core Team 2023), uma das classes utilizadas para esse fim é a POSIXlt, a qual armazena o conteúdo de uma data na forma de uma lista. Outra classe que também é possível utilizar é a POSIXct, que armazena as datas como segundos contados a partir de 1970-01-01. Devido ao seu formato de armazenamento, a classe POSIXct ocupa menos memória do computador. Junto ao {lubridate} (Spinu, Grolemund, and Wickham 2023), a classe utilizada para representar data-tempo é POSIXct e portanto daremos prioridade a essa. Vale destacar que todos os exemplos apresentados aqui também podem ser replicados para objetos do tipo POSIXlt.\nO formato tempo/data também segue a norma ISO 8601, sendo representado como ano-mês-dia horas:minutos:segundos zonadetempo (YYYY-MM-DD HH:mm:SS TMZ). Veja o exemplo a seguir:\n\n# creating a POSIXct object\nmy_timedate &lt;- as.POSIXct('2021-01-01 16:00:00')\n\n# print result\nprint(my_timedate)\n\nR&gt; [1] \"2021-01-01 16:00:00 -03\"\n\n\nO pacote {lubridate} (Spinu, Grolemund, and Wickham 2023) também oferece funções inteligentes para a criação de objetos do tipo data-tempo. Essas seguem a mesma linha de raciocínio que as funções de criar datas. Veja a seguir:\n\nlibrary(lubridate)\n\n# creating a POSIXlt object\nmy_timedate &lt;- ymd_hms('2021-01-01 16:00:00')\n\n# print it\nprint(my_timedate)\n\nR&gt; [1] \"2021-01-01 16:00:00 UTC\"\n\n\nDestaca-se que essa classe adiciona automaticamente o fuso horário. Caso seja necessário representar um fuso diferente, é possível fazê-lo com o argumento tz:\n\n# creating a POSIXlt object with custom timezone\nmy_timedate_tz &lt;- ymd_hms('2021-01-01 16:00:00',\n                          tz = 'GMT')\n\n# print it\nprint(my_timedate_tz)\n\nR&gt; [1] \"2021-01-01 16:00:00 GMT\"\n\n\nÉ importante ressaltar que, para o caso de objetos do tipo POSIXlt e POSIXct, as operações de soma e diminuição referem-se a segundos e não dias, como no caso do objeto da classe Date.\n\n# Adding values (seconds) to a POSIXlt object and printing it\nprint(my_timedate_tz + 30)\n\nR&gt; [1] \"2021-01-01 16:00:30 GMT\"\n\n\nAssim como para a classe Date, existem símbolos específicos para lidar com componentes de um objeto do tipo data/tempo. Isso permite a formatação customizada de datas. A seguir, apresentamos um quadro com os principais símbolos e os seus respectivos significados.\n\n\n\nCódigo\nValor\nExemplo\n\n\n\n\n%H\nHora (decimal, 24 horas)\n23\n\n\n%I\nHora (decimal, 12 horas)\n11\n\n\n%M\nMinuto (decimal, 0-59)\n12\n\n\n%p\nIndicador AM/PM\nAM\n\n\n%S\nSegundos (decimal, 0-59)\n50\n\n\n\nA seguir veremos como utilizar essa tabela para customizar datas.\n\n\n9.5.5 Personalizando o Formato de Datas\nA notação básica para representar datas e data/tempo no R pode não ser a ideal em algumas situações. No Brasil, por exemplo, indicar datas no formato YYYY-MM-DD pode gerar bastante confusão em um relatório formal. É recomendado, portanto, modificar a representação das datas para o formato esperado, isto é, DD/MM/YYYY.\nPara formatar uma data, utilizamos a função format() . Seu uso baseia-se nos símbolos de data e de horário apresentados anteriormente. A partir desses, pode-se criar qualquer customização. Veja o exemplo a seguir, onde apresenta-se a modificação de um vetor de datas para o formato brasileiro:\n\n# create vector of dates\nmy_dates &lt;- seq(from = ymd('2021-01-01'),\n                to = ymd('2021-01-15'),\n                by = '1 day')\n\n# change format\nmy_dates_br &lt;- format(my_dates, '%d/%m/%Y')\n\n# print result\nprint(my_dates_br)\n\nR&gt;  [1] \"01/01/2021\" \"02/01/2021\" \"03/01/2021\" \"04/01/2021\"\nR&gt;  [5] \"05/01/2021\" \"06/01/2021\" \"07/01/2021\" \"08/01/2021\"\nR&gt;  [9] \"09/01/2021\" \"10/01/2021\" \"11/01/2021\" \"12/01/2021\"\nR&gt; [13] \"13/01/2021\" \"14/01/2021\" \"15/01/2021\"\n\n\nO mesmo procedimento pode ser realizado para objetos do tipo data/tempo (POSIXct):\n\n# create vector of date-time\nmy_datetime &lt;- ymd_hms('2021-01-01 12:00:00') + seq(0,560,60)\n\n# change to Brazilian format\nmy_dates_br &lt;- format(my_datetime, '%d/%m/%Y %H:%M:%S')\n\n# print result\nprint(my_dates_br)\n\nR&gt;  [1] \"01/01/2021 12:00:00\" \"01/01/2021 12:01:00\"\nR&gt;  [3] \"01/01/2021 12:02:00\" \"01/01/2021 12:03:00\"\nR&gt;  [5] \"01/01/2021 12:04:00\" \"01/01/2021 12:05:00\"\nR&gt;  [7] \"01/01/2021 12:06:00\" \"01/01/2021 12:07:00\"\nR&gt;  [9] \"01/01/2021 12:08:00\" \"01/01/2021 12:09:00\"\n\n\nPode-se também customizar para formatos bem específicos. Veja a seguir:\n\n# set custom format\nmy_dates_custom &lt;- format(my_dates,\n                          'Year=%Y | Month=%m | Day=%d')\n\n# print result\nprint(my_dates_custom)\n\nR&gt;  [1] \"Year=2021 | Month=01 | Day=01\"\nR&gt;  [2] \"Year=2021 | Month=01 | Day=02\"\nR&gt;  [3] \"Year=2021 | Month=01 | Day=03\"\nR&gt;  [4] \"Year=2021 | Month=01 | Day=04\"\nR&gt;  [5] \"Year=2021 | Month=01 | Day=05\"\nR&gt;  [6] \"Year=2021 | Month=01 | Day=06\"\nR&gt;  [7] \"Year=2021 | Month=01 | Day=07\"\nR&gt;  [8] \"Year=2021 | Month=01 | Day=08\"\nR&gt;  [9] \"Year=2021 | Month=01 | Day=09\"\nR&gt; [10] \"Year=2021 | Month=01 | Day=10\"\nR&gt; [11] \"Year=2021 | Month=01 | Day=11\"\nR&gt; [12] \"Year=2021 | Month=01 | Day=12\"\nR&gt; [13] \"Year=2021 | Month=01 | Day=13\"\nR&gt; [14] \"Year=2021 | Month=01 | Day=14\"\nR&gt; [15] \"Year=2021 | Month=01 | Day=15\"\n\n\n\n\n9.5.6 Extraindo Elementos de uma Data\nPara extrair elementos de datas tal como o ano, mês, dia, hora, minuto e segundo, uma alternativa é utilizar função format() . Observe o próximo exemplo, onde recuperamos apenas as horas de um objeto POSIXct: \n\nlibrary(lubridate)\n\n# create vector of date-time\nmy_datetime &lt;- seq(from = ymd_hms('2021-01-01 12:00:00'),\n                   to = ymd_hms('2021-01-01 18:00:00'),\n                   by = '1 hour')\n\n# get hours from POSIXlt\nmy_hours &lt;- as.numeric(format(my_datetime, '%H'))\n\n# print result\nprint(my_hours)\n\nR&gt; [1] 12 13 14 15 16 17 18\n\n\nDa mesma forma, poderíamos utilizar os símbolos %M e %S para recuperar facilmente minutos e segundos de um vetor de objetos POSIXct.\n\n# create vector of date-time\nmy_datetime &lt;- seq(from = ymd_hms('2021-01-01 12:00:00'),\n                   to = ymd_hms('2021-01-01 18:00:00'),\n                   by = '15 min')\n\n# get minutes from POSIXlt\nmy_minutes &lt;- as.numeric(format(my_datetime, '%M'))\n\n# print result\nprint(my_minutes)\n\nR&gt;  [1]  0 15 30 45  0 15 30 45  0 15 30 45  0 15 30 45  0 15\nR&gt; [19] 30 45  0 15 30 45  0\n\n\nOutra forma é utilizar as funções do {lubridate} (Spinu, Grolemund, and Wickham 2023), tal como lubridate::hour() e lubridate::minute() :\n\n# get hours with lubridate\nprint(hour(my_datetime))\n\nR&gt;  [1] 12 12 12 12 13 13 13 13 14 14 14 14 15 15 15 15 16 16\nR&gt; [19] 16 16 17 17 17 17 18\n\n# get minutes with lubridate\nprint(minute(my_datetime))\n\nR&gt;  [1]  0 15 30 45  0 15 30 45  0 15 30 45  0 15 30 45  0 15\nR&gt; [19] 30 45  0 15 30 45  0\n\n\nOutras funções também estão disponíveis para os demais elementos de um objeto data-hora.\n\n\n9.5.7 Conhecendo o Horário e a Data Atual\nO R inclui várias funções que permitem o usuário utilizar no seu código o horário e data atual do sistema. Isso é bastante útil quando se está criando registros e é importante que a data e horário de execução do código seja conhecida futuramente.\nPara conhecer o dia atual, basta utilizarmos a função Sys.Date() ou lubridate::today() :\n\nlibrary(lubridate)\n\n# get today\nprint(Sys.Date())\n\nR&gt; [1] \"2024-01-10\"\n\n# print it\nprint(today())\n\nR&gt; [1] \"2024-01-10\"\n\n\nPara descobrir a data e horário, utilizamos a função Sys.time() ou lubridate::now() :\n\n# get time!\nprint(Sys.time())\n\nR&gt; [1] \"2024-01-10 16:21:32 -03\"\n\n# get time!\nprint(now())\n\nR&gt; [1] \"2024-01-10 16:21:32 -03\"\n\n\nCom base nessas, podemos escrever:\n\nlibrary(stringr)\n\n# example of log message\nmy_str &lt;- str_c('This code was executed in ', now())\n\n# print it\nprint(my_str)\n\nR&gt; [1] \"This code was executed in 2024-01-10 16:21:32.803666\"\n\n\n\n\n9.5.8 Outras Funções Úteis\nweekdays - Retorna o dia da semana de uma ou várias datas.\n\n# set date vector\nmy_dates &lt;- seq(from = ymd('2021-01-01'),\n                to = ymd('2021-01-5'),\n                by = '1 day')\n\n# find corresponding weekdays\nmy_weekdays &lt;- weekdays(my_dates)\n\n# print it\nprint(my_weekdays)\n\nR&gt; [1] \"Friday\"   \"Saturday\" \"Sunday\"   \"Monday\"   \"Tuesday\"\n\n\nmonths - Retorna o mês de uma ou várias datas.\n\n# create date vector\nmy_dates &lt;- seq(from = ymd('2021-01-01'),\n                to = ymd('2021-12-31'),\n                by = '1 month')\n\n# find months\nmy_months &lt;- months(my_dates)\n\n# print result\nprint(my_months)\n\nR&gt;  [1] \"January\"   \"February\"  \"March\"     \"April\"    \nR&gt;  [5] \"May\"       \"June\"      \"July\"      \"August\"   \nR&gt;  [9] \"September\" \"October\"   \"November\"  \"December\"\n\n\nquarters - Retorna a localização de uma ou mais datas dentro dos quartis do ano.\n\n# get quartiles of the year\nmy_quarters &lt;- quarters(my_dates)\nprint(my_quarters)\n\nR&gt;  [1] \"Q1\" \"Q1\" \"Q1\" \"Q2\" \"Q2\" \"Q2\" \"Q3\" \"Q3\" \"Q3\" \"Q4\" \"Q4\"\nR&gt; [12] \"Q4\"\n\n\nOlsonNames - Retorna um vetor com as zonas de tempo disponíveis no R. No total, são mais de 500 itens. Aqui, apresentamos apenas os primeiros cinco elementos.\n\n# get possible timezones\npossible_tz &lt;- OlsonNames()\n\n# print it\nprint(possible_tz[1:5])\n\nR&gt; [1] \"Africa/Abidjan\"     \"Africa/Accra\"      \nR&gt; [3] \"Africa/Addis_Ababa\" \"Africa/Algiers\"    \nR&gt; [5] \"Africa/Asmara\"\n\n\nSys.timezone - Retorna a zona de tempo do sistema.\n\n# get current timezone\nprint(Sys.timezone())\n\nR&gt; [1] \"America/Sao_Paulo\"\n\n\ncut - Retorna um fator a partir da categorização de uma classe de data e tempo.\n\n# set example date vector\nmy_dates &lt;- seq(from = ymd('2021-01-01'),\n                to = ymd('2021-03-01'),\n                by = '5 days')\n\n# group vector based on monthly breaks\nmy_month_cut &lt;- cut(x = my_dates,\n                    breaks = 'month')\n\n# print result\nprint(my_month_cut)\n\nR&gt;  [1] 2021-01-01 2021-01-01 2021-01-01 2021-01-01 2021-01-01\nR&gt;  [6] 2021-01-01 2021-01-01 2021-02-01 2021-02-01 2021-02-01\nR&gt; [11] 2021-02-01 2021-02-01\nR&gt; Levels: 2021-01-01 2021-02-01\n\n\n\n# set example datetime vector\nmy_datetime &lt;- as.POSIXlt('2021-01-01 12:00:00') + seq(0,250,15)\n\n# set groups for each 30 seconds\nmy_cut &lt;- cut(x = my_datetime, breaks = '30 secs')\n\n# print result\nprint(my_cut)\n\nR&gt;  [1] 2021-01-01 12:00:00 2021-01-01 12:00:00\nR&gt;  [3] 2021-01-01 12:00:30 2021-01-01 12:00:30\nR&gt;  [5] 2021-01-01 12:01:00 2021-01-01 12:01:00\nR&gt;  [7] 2021-01-01 12:01:30 2021-01-01 12:01:30\nR&gt;  [9] 2021-01-01 12:02:00 2021-01-01 12:02:00\nR&gt; [11] 2021-01-01 12:02:30 2021-01-01 12:02:30\nR&gt; [13] 2021-01-01 12:03:00 2021-01-01 12:03:00\nR&gt; [15] 2021-01-01 12:03:30 2021-01-01 12:03:30\nR&gt; [17] 2021-01-01 12:04:00\nR&gt; 9 Levels: 2021-01-01 12:00:00 ... 2021-01-01 12:04:00"
  },
  {
    "objectID": "09-objetos-basicos.html#dados-omissos---na-not-available",
    "href": "09-objetos-basicos.html#dados-omissos---na-not-available",
    "title": "9  As Classes Básicas de Objetos",
    "section": "9.6 Dados Omissos - NA (Not available)",
    "text": "9.6 Dados Omissos - NA (Not available)\nUma das principais inovações do R em relação a outras linguagens de programação é a representação de dados omissos através de objetos da classe NA (Not Available). A falta de dados pode ter inúmeros motivos, tal como a falha na coleta de informações ou simplesmente a não existência dos mesmos. Esses casos são tratados por meio da remoção ou da substituição dos dados omissos antes realizar uma análise mais profunda. A identificação desses casos, portanto, é de extrema importância.\n\n9.6.1 Definindo Valores NA\nPara definirmos os casos omissos nos dados, basta utilizar o símbolo NA:\n\n# a vector with NA\nmy_x &lt;- c(1, 2, NA, 4, 5)\n\n# print it\nprint(my_x)\n\nR&gt; [1]  1  2 NA  4  5\n\n\nVale destacar que a operação de qualquer valor NA com outro sempre resultará em NA.\n\n# example of NA interacting with other objects\nprint(my_x + 1)\n\nR&gt; [1]  2  3 NA  5  6\n\n\nIsso exige cuidado quando se está utilizando alguma função com cálculo recursivo, tal como cumsum() e cumprod() . Nesses casos, todo valor consecutivo ao NA será transformado em NA. Veja os exemplos a seguir com as duas funções:\n\n# set vector with NA\nmy_x &lt;- c(1:5, NA, 5:10)\n\n# print cumsum (NA after sixth element)\nprint(cumsum(my_x))\n\nR&gt;  [1]  1  3  6 10 15 NA NA NA NA NA NA NA\n\n# print cumprod (NA after sixth element)\nprint(cumprod(my_x))\n\nR&gt;  [1]   1   2   6  24 120  NA  NA  NA  NA  NA  NA  NA\n\n\n\n\n\n\n\n\nCuidado\n\n\n\nToda vez que utilizar as funções cumsum() e cumprod() , certifique-se de que não existe algum valor NA no vetor de entrada. Lembre-se de que todo NA é contagiante e o cálculo recursivo irá resultar em um vetor repleto de dados faltantes.\n\n\n\n\n9.6.2 Encontrando e Substituindo Valores NA\nPara encontrar os valores NA em um vetor, basta utilizar a função is.na() : \n\n# set vector with NA\nmy_x &lt;- c(1:2, NA, 4:10)\n\n# find location of NA\nidx_na &lt;- is.na(my_x)\nprint(idx_na)\n\nR&gt;  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\nR&gt; [10] FALSE\n\n\nPara substituí-los, use indexação com a saída de is.na() :\n\n# set vector\nmy_x &lt;- c(1, NA, 3:4, NA)\n\n# replace NA for 2\nmy_x[is.na(my_x)] &lt;- 2\n\n# print result\nprint(my_x)\n\nR&gt; [1] 1 2 3 4 2\n\n\nOutra maneira de limpar o objeto é utilizar a função na.omit() , que retorna o mesmo objeto mas sem os valores NA. Note, porém, que o tamanho do vetor irá mudar e o objeto será da classe omit, o que indica que o vetor resultante não inclui os NA e apresenta, também, a posição dos elementos NA encontrados. \n\n# set vector\nmy_char &lt;- c(letters[1:3], NA, letters[5:8])\n\n# print it\nprint(my_char)\n\nR&gt; [1] \"a\" \"b\" \"c\" NA  \"e\" \"f\" \"g\" \"h\"\n\n# use na.omit to remove NA\nmy_char &lt;- na.omit(my_char)\n\n# print result\nprint(my_char)\n\nR&gt; [1] \"a\" \"b\" \"c\" \"e\" \"f\" \"g\" \"h\"\nR&gt; attr(,\"na.action\")\nR&gt; [1] 4\nR&gt; attr(,\"class\")\nR&gt; [1] \"omit\"\n\n\nApesar de o tipo de objeto ter sido trocado, devido ao uso de na.omit() , as propriedades básicas do vetor inicial se mantêm. Por exemplo: o uso de nchar() no objeto resultante é possível.\n\n# trying nchar on a na.omit object\nprint(nchar(my_char))\n\nR&gt; [1] 1 1 1 1 1 1 1\n\n\nPara outros objetos, porém, recomenda-se cautela quando no uso da função na.omit() .\n\n\n9.6.3 Outras Funções Úteis\ncomplete.cases - Retorna um vetor lógico que indica se as linhas do objeto possuem apenas valores não omissos. Essa função é usada exclusivamente para dataframes e matrizes.\n\n# create matrix\nmy_mat &lt;- matrix(1:15, nrow = 5)\n\n# set an NA value\nmy_mat[2,2] &lt;- NA\n\n# print index with rows without NA\nprint(complete.cases(my_mat))\n\nR&gt; [1]  TRUE FALSE  TRUE  TRUE  TRUE"
  },
  {
    "objectID": "09-objetos-basicos.html#exerc-classes-basicas",
    "href": "09-objetos-basicos.html#exerc-classes-basicas",
    "title": "9  As Classes Básicas de Objetos",
    "section": "9.7 Exercícios",
    "text": "9.7 Exercícios\n\n\n\n\nR Core Team. 2023. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/.\n\n\nSpinu, Vitalie, Garrett Grolemund, and Hadley Wickham. 2023. Lubridate: Make Dealing with Dates a Little Easier. https://lubridate.tidyverse.org.\n\n\nWickham, Hadley. 2023a. Forcats: Tools for Working with Categorical Variables (Factors). https://forcats.tidyverse.org/.\n\n\n———. 2023b. Stringr: Simple, Consistent Wrappers for Common String Operations. https://stringr.tidyverse.org.\n\n\n———. 2023c. Tidyverse: Easily Install and Load the Tidyverse. https://tidyverse.tidyverse.org."
  },
  {
    "objectID": "10-intro-programacao.html",
    "href": "10-intro-programacao.html",
    "title": "10  Introdução a Programação com o R",
    "section": "",
    "text": "TODO: write more"
  },
  {
    "objectID": "99-references.html",
    "href": "99-references.html",
    "title": "Referências Bibliográficas",
    "section": "",
    "text": "Allaire, JJ. 2023. Quarto: R Interface to Quarto Markdown Publishing\nSystem. https://github.com/quarto-dev/quarto-r.\n\n\nAllaire, JJ, Yihui Xie, Christophe Dervieux, Jonathan McPherson, Javier\nLuraschi, Kevin Ushey, Aron Atkins, et al. 2023. Rmarkdown: Dynamic\nDocuments for r. https://github.com/rstudio/rmarkdown.\n\n\nDragulescu, Adrian, and Cole Arendt. 2020. Xlsx: Read, Write, Format\nExcel 2007 and Excel 97/2000/XP/2003 Files. https://github.com/colearendt/xlsx.\n\n\nGarmonsway, Duncan. 2023. Tidyxl: Read Untidy Excel Files. https://github.com/nacnudus/tidyxl.\n\n\nHester, Jim, and Jennifer Bryan. 2022. Glue: Interpreted String\nLiterals. https://github.com/tidyverse/glue.\n\n\nHester, Jim, Hadley Wickham, and Gábor Csárdi. 2023. Fs:\nCross-Platform File System Operations Based on Libuv. https://fs.r-lib.org.\n\n\nIannone, Richard, Joe Cheng, Barret Schloerke, Ellis Hughes, Alexandra\nLauer, and JooYoung Seo. 2023. Gt: Easily Create Presentation-Ready\nDisplay Tables. https://gt.rstudio.com.\n\n\nKlik, Mark. 2022. Fst: Lightning Fast Serialization of Data\nFrames. http://www.fstpackage.org.\n\n\nMirai Solutions GmbH. 2023. XLConnect: Excel Connector for r.\nhttps://mirai-solutions.ch\nhttps://github.com/miraisolutions/xlconnect.\n\n\nMüller, Kirill, and Hadley Wickham. 2023. Tibble: Simple Data\nFrames. https://tibble.tidyverse.org/.\n\n\nOoms, Jeroen. 2023. Writexl: Export Data Frames to Excel Xlsx\nFormat. https://docs.ropensci.org/writexl/.\n\n\nPerlin, Marcelo. 2022. GetBCBData: Imports Datasets from BCB\n(Central Bank of Brazil) Using Its Official API. https://github.com/msperlin/GetBCBData/.\n\n\n———. 2023a. GetTDData: Get Data for Brazilian Bonds (Tesouro\nDireto). https://github.com/msperlin/GetTDData/.\n\n\n———. 2023b. yfR: Downloads and Organizes Financial Data from Yahoo\nFinance. https://github.com/ropensci/yfR.\n\n\nPerlin, Marcelo S. 2023. GetQuandlData: Fast and Cached Import of\nData from Quandl Using the Json API. https://github.com/msperlin/GetQuandlData/.\n\n\nPerlin, Marcelo, and Guilherme Kirch. 2022. GetFREData: Reading FRE\nCorporate Data of Public Traded Companies from B3. https://github.com/msperlin/GetFREData/.\n\n\n———. 2023. GetDFPData2: Reading Annual and Quarterly Financial\nReports from B3. https://github.com/msperlin/GetDFPData2/.\n\n\nR Core Team. 2023a. Foreign: Read Data Stored by Minitab, s, SAS,\nSPSS, Stata, Systat, Weka, dBase, ... https://svn.r-project.org/R-packages/trunk/foreign/.\n\n\n———. 2023c. R: A Language and Environment for Statistical\nComputing. Vienna, Austria: R Foundation for Statistical Computing.\nhttps://www.R-project.org/.\n\n\n———. 2023b. R: A Language and Environment for Statistical\nComputing. Vienna, Austria: R Foundation for Statistical Computing.\nhttps://www.R-project.org/.\n\n\nSpinu, Vitalie, Garrett Grolemund, and Hadley Wickham. 2023.\nLubridate: Make Dealing with Dates a Little Easier. https://lubridate.tidyverse.org.\n\n\nTeetor, Paul. 2011. R Cookbook: Proven Recipes for Data Analysis,\nStatistics, and Graphics. \" O’Reilly Media, Inc.\".\n\n\nUshey, Kevin, JJ Allaire, and Yuan Tang. 2023. Reticulate: Interface\nto Python. https://rstudio.github.io/reticulate/.\n\n\nUshey, Kevin, and Hadley Wickham. 2023. Renv: Project\nEnvironments. https://rstudio.github.io/renv/.\n\n\nWickham, Hadley. 2019. Advanced r. CRC press.\n\n\n———. 2023a. Forcats: Tools for Working with Categorical Variables\n(Factors). https://forcats.tidyverse.org/.\n\n\n———. 2023b. Stringr: Simple, Consistent Wrappers for Common String\nOperations. https://stringr.tidyverse.org.\n\n\n———. 2023c. Tidyverse: Easily Install and Load the Tidyverse.\nhttps://tidyverse.tidyverse.org.\n\n\nWickham, Hadley, and Jennifer Bryan. 2023. Readxl: Read Excel\nFiles. https://readxl.tidyverse.org.\n\n\nWickham, Hadley, Winston Chang, Lionel Henry, Thomas Lin Pedersen,\nKohske Takahashi, Claus Wilke, Kara Woo, Hiroaki Yutani, and Dewey\nDunnington. 2023. Ggplot2: Create Elegant Data Visualisations Using\nthe Grammar of Graphics. https://ggplot2.tidyverse.org.\n\n\nWickham, Hadley, Romain François, Lionel Henry, Kirill Müller, and Davis\nVaughan. 2023. Dplyr: A Grammar of Data Manipulation. https://dplyr.tidyverse.org.\n\n\nWickham, Hadley, and Lionel Henry. 2023. Purrr: Functional\nProgramming Tools. https://purrr.tidyverse.org/.\n\n\nWickham, Hadley, Jim Hester, and Jennifer Bryan. 2023. Readr: Read\nRectangular Text Data. https://readr.tidyverse.org.\n\n\nWickham, Hadley, Davis Vaughan, and Maximilian Girlich. 2023. Tidyr:\nTidy Messy Data. https://tidyr.tidyverse.org.\n\n\nXie, Yihui. 2023. Knitr: A General-Purpose Package for Dynamic\nReport Generation in r. https://yihui.org/knitr/.\n\n\nZeileis, Achim, Bettina Gruen, Friedrich Leisch, and Nikolaus Umlauf.\n2022. Exams: Automatic Generation of Exams in r. https://www.R-exams.org/."
  }
]