---
title: "How to calculate betas (systematic risk) for a large number of stocks"
subtitle: "A comparison between using a loop, function by and the package dplyr"
author: "Marcelo S. Perlin"
date: 2017-01-15
tags: [R, stock market, beta, linear regression]
categories: [R, stock market, beta, linear regression]
---



<p>One of the first examples about using linear regression models in finance is the calculation of betas, the so called market model. Coefficient beta is a measure of systematic risk and it is calculated by estimating a linear model where the dependent variable is the return vector of a stock and the explanatory variable is the return vector of a diversified local market index, such as SP500 (US), FTSE (UK), Ibovespa (Brazil), or any other.</p>
<p>From the academic side, the calculation of beta is part of a famous asset pricing model, CAPM - Capital Asset Pricing Model, that relates expected return and systematic risk. One can reach the market model equation by assuming several conditions such as Normal distributed returns, rational investors and frictionless market. Summing up, the CAPM model predicts that betas have a linear relationship to expected returns, that is, stocks with higher betas should present, collectively, higher average of historical returns.</p>
<p>In the quantitative side, we can formulate the market model as:</p>
<p><span class="math inline">\(R_t = \alpha + \beta R_{M,t} + \epsilon _t\)</span></p>
<p>where <span class="math inline">\(R_{t}\)</span> is the return of the stock at time <span class="math inline">\(t\)</span>, <span class="math inline">\(R_{M,t}\)</span> is the return of the market index, <span class="math inline">\(\alpha\)</span> is the constant (also called Jensen’s alphas) and, finally, <span class="math inline">\(\beta\)</span> is the measure of systematic risk for the stock. The values of <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are found by minimizing the sum of squared errors of the model. So, if you have a vector of prices for a stock and another vector of prices for the local market index, you can easily find the stock’s beta by calculating the daily returns and estimating the market model by OLS.</p>
<p>The problem here is that, usually, you don’t want the beta of a single stock. You want to calculate the systematic risk for a large number of stocks. This is where students usually have problems, as they only learned in class how to estimate one model. In order to do the same procedure for more than one stock, some programming is needed. This is where R really shines in comparison to simpler programs such as Excel.</p>
<p>In this post I will download some data from the US market, make some adjustments to the resulting dataframe and discuss three ways to calculate the betas of several stocks. These are:</p>
<ol style="list-style-type: decimal">
<li>Using a <code>loop</code></li>
<li>Using function <code>by</code></li>
<li>Using package <code>dplyr</code></li>
</ol>
<p>But first, lets load the data.</p>
<div id="loading-the-data-and-preparing-it" class="section level1">
<h1>Loading the data and preparing it</h1>
<p>I’m a bit biased, but I really like using package <code>BatchGetSymbols</code> to download financial data from yahoo finance. In this example we will download data for 10 stocks selected randomly from the SP500 index. I will also add the ticker <code>^GSPC</code>, which belongs to the SP500 index. We will need it to calculate the betas. In order for the code to be reproducible, I will set <code>random.seed(100)</code>. This means that anyone that runs the code available here will get the exact same results.</p>
<pre class="r"><code>library(BatchGetSymbols)</code></pre>
<pre><code>## Loading required package: rvest</code></pre>
<pre><code>## Loading required package: xml2</code></pre>
<pre><code>## Loading required package: dplyr</code></pre>
<pre><code>## 
## Attaching package: &#39;dplyr&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:stats&#39;:
## 
##     filter, lag</code></pre>
<pre><code>## The following objects are masked from &#39;package:base&#39;:
## 
##     intersect, setdiff, setequal, union</code></pre>
<pre><code>## </code></pre>
<pre class="r"><code>set.seed(100)

ticker.MktIdx &lt;- &#39;^GSPC&#39;
first.date &lt;- as.Date(&#39;2015-01-01&#39;)
last.date &lt;- as.Date(&#39;2019-01-01&#39;)

n.chosen.stocks &lt;- 10 # can&#39;t be higher than 505

# get random stocks
my.tickers &lt;- c(sample(GetSP500Stocks()$Tickers,n.chosen.stocks),
                ticker.MktIdx)

l.out &lt;- BatchGetSymbols(tickers = my.tickers, 
                             first.date = first.date,
                             last.date = last.date)</code></pre>
<pre><code>## 
## Running BatchGetSymbols for:</code></pre>
<pre><code>## 
##    tickers =FTV, ZBH, OXY, C, XLNX, VZ, BEN, WY, ROL, VTR, ^GSPC
##    Downloading data for benchmark ticker
## ^GSPC | yahoo (1|1) | Found cache file
## FTV | yahoo (1|11) | Found cache file - Got 62% of valid prices | OUT: not enough data (thresh.bad.data = 75%)
## ZBH | yahoo (2|11) | Found cache file - Got 100% of valid prices | Youre doing good!
## OXY | yahoo (3|11) | Found cache file - Got 100% of valid prices | Good stuff!
## C | yahoo (4|11) | Found cache file - Got 100% of valid prices | Looking good!
## XLNX | yahoo (5|11) | Found cache file - Got 100% of valid prices | Youre doing good!
## VZ | yahoo (6|11) | Found cache file - Got 100% of valid prices | Feels good!
## BEN | yahoo (7|11) | Found cache file - Got 100% of valid prices | Well done!
## WY | yahoo (8|11) | Found cache file - Got 100% of valid prices | Well done!
## ROL | yahoo (9|11) | Found cache file - Got 100% of valid prices | Looking good!
## VTR | yahoo (10|11) | Found cache file - Got 100% of valid prices | Nice!
## ^GSPC | yahoo (11|11) | Found cache file - Got 100% of valid prices | Got it!</code></pre>
<pre class="r"><code>df.stocks &lt;- l.out$df.tickers</code></pre>
<p>Now, lets check if everything went well with the import process.</p>
<pre class="r"><code>print(l.out$df.control)</code></pre>
<pre><code>## # A tibble: 11 x 6
##    ticker src   download.status total.obs perc.benchmark.dates threshold.decisi…
##    &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;               &lt;int&gt;                &lt;dbl&gt; &lt;chr&gt;            
##  1 FTV    yahoo OK                    628                0.624 OUT              
##  2 ZBH    yahoo OK                   1006                1     KEEP             
##  3 OXY    yahoo OK                   1006                1     KEEP             
##  4 C      yahoo OK                   1006                1     KEEP             
##  5 XLNX   yahoo OK                   1006                1     KEEP             
##  6 VZ     yahoo OK                   1006                1     KEEP             
##  7 BEN    yahoo OK                   1006                1     KEEP             
##  8 WY     yahoo OK                   1006                1     KEEP             
##  9 ROL    yahoo OK                   1006                1     KEEP             
## 10 VTR    yahoo OK                   1006                1     KEEP             
## 11 ^GSPC  yahoo OK                   1006                1     KEEP</code></pre>
<p>It seems that everything is Ok. All stocks have column <code>perc.benchmark.dates</code> equal to one (100%), meaning that they have the exact same dates as the benchmark ticker.</p>
<p>Now, lets plot the time series of prices and look for any problem:</p>
<pre class="r"><code>library(ggplot2)

p &lt;- ggplot(df.stocks, aes(x=ref.date, y=price.adjusted)) + 
  geom_line() + facet_wrap(~ticker, scales = &#39;free&#39;)

print(p)</code></pre>
<p><img src="/blog/post/2017-01-15-CalculatingBetas_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>Again, we see that all prices seems to be Ok. This is one of the advantages of working with adjusted (and not closing) prices from yahoo finance. Artificial effects in the dataset such as ex-dividend prices, splits and inplits are already taken into account and the result is a smooth series without any breaks.</p>
<p>The final step in preparing the data is to add a column with the returns of the market index. This is not strictly necessary but I really like to keep things organized in a tabular way. Since we will match each vector of returns of the stocks to a vector of returns of the market index, it makes sense to <em>synchronize</em> the rows in the data.frame. First, we isolate the data for the market index in object <code>df.MktIdx</code> and use function <code>match</code> to make an index that matches the dates between the assets and the market index. We later use this index to build a new column in <code>df.stocks</code>. See the next code:</p>
<pre class="r"><code>df.MktIdx &lt;- df.stocks[df.stocks$ticker==ticker.MktIdx, ]

idx &lt;- match(df.stocks$ref.date, df.MktIdx$ref.date)

df.stocks$ret.MktIdx &lt;- df.MktIdx$ret.adjusted.prices[idx]</code></pre>
<p>Now that we have the data in the correct format and structure, let’s start to calculate some betas. Here is where the different approaches will differ in syntax. Let’s start with the first case, using loops.</p>
</div>
<div id="estimating-betas" class="section level1">
<h1>Estimating betas</h1>
<div id="using-loops" class="section level2">
<h2>Using loops</h2>
<p>Loops are great and (almost) everyone loves then. While they can be a bit more verbose than fancy on-liners, the structure of a loop is very flexible and this can help solve complex problems. Let use it in our problem.</p>
<p>The first step in using loops is the understand the vector that will be used as iterator in the loop. In our problem we are processing each stock, so the number of iterations in the loop is simply the number of stocks in the sample. We can find the unique stocks with the command <code>unique</code>.</p>
<pre class="r"><code># Check unique tickers
unique.tickers &lt;- unique(df.stocks$ticker)

# create a empty vector to store betas
beta.vec &lt;- c()

for (i.ticker in unique.tickers){
  
  # message to prompt
  cat(&#39;\nRunning ols for&#39;,i.ticker)
  
  # filter the data.frame for stock i.ticker
  df.temp &lt;- df.stocks[df.stocks$ticker==i.ticker, ]
  
  # calculate beta with lm
  my.ols &lt;- lm(data = df.temp, formula = ret.adjusted.prices ~ ret.MktIdx)
  
  # save beta
  my.beta &lt;- coef(my.ols)[2]
  
  # store beta em beta.vec
  beta.vec &lt;- c(beta.vec, my.beta)
}</code></pre>
<pre><code>## 
## Running ols for ZBH
## Running ols for OXY
## Running ols for C
## Running ols for XLNX
## Running ols for VZ
## Running ols for BEN
## Running ols for WY
## Running ols for ROL
## Running ols for VTR
## Running ols for ^GSPC</code></pre>
<pre class="r"><code># print result
print(data.frame(unique.tickers,beta.vec))</code></pre>
<pre><code>##    unique.tickers  beta.vec
## 1             ZBH 0.9130036
## 2             OXY 1.0046153
## 3               C 1.3468402
## 4            XLNX 1.2272195
## 5              VZ 0.5864176
## 6             BEN 1.2555433
## 7              WY 0.9400250
## 8             ROL 0.8057286
## 9             VTR 0.4923402
## 10          ^GSPC 1.0000000</code></pre>
<p>As you can see, the result is a lengthy code, but it works quite well. The final result is a dataframe with the tickers and their betas. Notice that, as expected, the betas are all positive and <code>^GSPC</code> has a beta equal to 1.</p>
</div>
<div id="using-function-by" class="section level2">
<h2>Using function <code>by</code></h2>
<p>Another way of solving the problem is to calculate the betas using one of the functions from the <code>apply</code> family. In this case, we will use function <code>by</code>. Be aware that you can also solve the problem using <code>tapply</code> and <code>lapply</code>. The code, however, will increase in complexity.</p>
<p>The function <code>by</code> works similarly to <code>tapply</code>. The difference is that it is oriented to dataframes. That is, given a grouping variable, the original dataframe is broken into smaller dataframes and each piece is passed to a function. This helps a lot our problem since we need to work with two columns, the vector of returns of the asset and the vector of returns of the market index.</p>
<p>Given the functional form of <code>by</code>, will need to encapsulate a procedure that takes a dataframe as input and returns a coefficient beta, calculated from columns <code>ret</code> and <code>ret.MktIdx</code>. The next code does that.</p>
<pre class="r"><code>get.beta &lt;- function(df.temp){
  
  # estimate model
  my.ols &lt;- lm(data=df.temp, formula = ret.adjusted.prices ~ ret.MktIdx)
  
  # isolate beta
  my.beta &lt;- coef(my.ols)[2]
  
  # return beta
  return(my.beta)
}</code></pre>
<p>The previous function accepts a single dataframe called <code>df.temp</code>, uses it to calculate a linear model with function <code>lm</code> and then returns the resulting beta, which is the second coefficient in <code>coef(my.ols)</code>. Now, lets use it with function <code>by</code>.</p>
<pre class="r"><code># get betas with by
my.l &lt;- by(data = df.stocks, 
           INDICES = df.stocks$ticker, 
           FUN = get.beta)

# my.l is an objetct of class by. To get only its elements, we can unclass it
betas &lt;- unclass(my.l)

# print result
print(data.frame(betas))</code></pre>
<pre><code>##           betas
## ^GSPC 1.0000000
## BEN   1.2555433
## C     1.3468402
## OXY   1.0046153
## ROL   0.8057286
## VTR   0.4923402
## VZ    0.5864176
## WY    0.9400250
## XLNX  1.2272195
## ZBH   0.9130036</code></pre>
<p>Again, it worked well. Needless to say that the results are identical to the previous case.</p>
</div>
<div id="using-dplyr" class="section level2">
<h2>Using <code>dplyr</code></h2>
<p>Now, let’s solve our problem using package <code>dplyr</code>. If you are not familiar with the <em>tidyverse</em> and the work of Hadley Wickham, you will be a happier person after reading the rest of this post, trust me.</p>
<p>Package <code>dplyr</code> is one of my favorites and most used packages. It allows for the representation of data processing procedures in a simpler and more intuitive way. It really helps to tackle computational problems if you can fit it within a flexible structure. This is what, in my opinion, <code>dplyr</code> does best. It combines clever functions with dataframes in the long (tidy) format.</p>
<p>Have a look in the next set of code.</p>
<pre class="r"><code>library(dplyr)

beta.tab &lt;- df.stocks %&gt;% 
  group_by(ticker) %&gt;% # group by column ticker
  do(ols.model = lm(data = ., formula = ret.adjusted.prices ~ret.MktIdx)) %&gt;%   # estimate model
  mutate(beta = coef(ols.model)[2]) # get coefficients

print(beta.tab)</code></pre>
<pre><code>## Source: local data frame [10 x 3]
## Groups: &lt;by row&gt;
## 
## # A tibble: 10 x 3
##    ticker ols.model  beta
##    &lt;chr&gt;  &lt;list&gt;    &lt;dbl&gt;
##  1 ^GSPC  &lt;lm&gt;      1    
##  2 BEN    &lt;lm&gt;      1.26 
##  3 C      &lt;lm&gt;      1.35 
##  4 OXY    &lt;lm&gt;      1.00 
##  5 ROL    &lt;lm&gt;      0.806
##  6 VTR    &lt;lm&gt;      0.492
##  7 VZ     &lt;lm&gt;      0.586
##  8 WY     &lt;lm&gt;      0.940
##  9 XLNX   &lt;lm&gt;      1.23 
## 10 ZBH    &lt;lm&gt;      0.913</code></pre>
<p>After loading <code>dplyr</code>, we use the pipeline operator %&gt;% to streamline all calculations. This means that we don’t need to keep a copy of intermediate calculations. Also, It looks pretty, don’t you agree?</p>
<p>The line <code>beta.tab &lt;- df.stocks %&gt;%</code> passes the dataframe <code>df.stocks</code> for the next line, <code>group_by(ticker) %&gt;%</code>, which will group the dataframe according the the values of column <code>ticker</code> and pass the result for the next step. The line <code>do(ols.model = lm(data = ., formula = ret ~ret.MktIdx))</code> estimates the model by passing a temporary dataframe and saves it in a column called <code>ols.model</code>. Notice that the model is a <code>S3</code> object and not a single value. The dataframe alternative <code>tibble</code> is flexible with its content. The final line, <code>mutate(beta = coef(ols.model)[2])</code> retrieves the beta from each element of the column <code>ols.model</code>.</p>
<p>What I really like about <code>dplyr</code> is that it makes it easy to extend the original code. As an example, if I wanted to use a second grouping variable, I can just add it in the second line as <code>group_by(ticker, newgroupingvariable)</code>. This becomes handy if you need, lets say, to estimated the model in different time periods.</p>
<p>As an example, let’s assume that I want to split the sample for each stock in half and see if the betas change significantly from time period to the other. This robustness check is a very common procedure in scientific research. First, let’s build a new column in <code>df.stocks</code> that sets the time periods as <code>Sample 1</code> and <code>Sample 2</code>. We can use <code>tapply</code> for that;</p>
<pre class="r"><code>set.sample &lt;- function(ref.dates){
  my.n &lt;- length(ref.dates) # get number of dates
  my.n.half &lt;- floor(my.n/2) # get aproximate half of observations
  
  # create grouping variable
  samples.vec &lt;- c(rep(&#39;Sample 1&#39;, my.n.half ), rep(&#39;Sample 2&#39;, my.n-my.n.half))
  
  # return
  return(samples.vec)
}

# build group
my.l &lt;- tapply(X = df.stocks$ref.date, 
               INDEX = df.stocks$ticker,
               FUN = set.sample )

# unsort it
my.l &lt;- my.l[my.tickers]

# save it in dataframe
df.stocks$my.sample &lt;- unlist(my.l)</code></pre>
<p>We proceed by calling the same functions as before, but using an additional grouping variable.</p>
<pre class="r"><code>beta.tab &lt;- df.stocks %&gt;% 
  group_by(ticker,my.sample) %&gt;% # group by column ticker
  do(ols.model = lm(data = ., formula = ret.adjusted.prices ~ret.MktIdx)) %&gt;%   # estimate model
  mutate(beta = coef(ols.model)[2]) # get coefficients

print(beta.tab)</code></pre>
<pre><code>## Source: local data frame [20 x 4]
## Groups: &lt;by row&gt;
## 
## # A tibble: 20 x 4
##    ticker my.sample ols.model  beta
##    &lt;chr&gt;  &lt;chr&gt;     &lt;list&gt;    &lt;dbl&gt;
##  1 ^GSPC  Sample 1  &lt;lm&gt;      1.00 
##  2 ^GSPC  Sample 2  &lt;lm&gt;      1.   
##  3 BEN    Sample 1  &lt;lm&gt;      1.40 
##  4 BEN    Sample 2  &lt;lm&gt;      1.08 
##  5 C      Sample 1  &lt;lm&gt;      1.54 
##  6 C      Sample 2  &lt;lm&gt;      1.11 
##  7 OXY    Sample 1  &lt;lm&gt;      1.10 
##  8 OXY    Sample 2  &lt;lm&gt;      0.882
##  9 ROL    Sample 1  &lt;lm&gt;      0.781
## 10 ROL    Sample 2  &lt;lm&gt;      0.836
## 11 VTR    Sample 1  &lt;lm&gt;      0.653
## 12 VTR    Sample 2  &lt;lm&gt;      0.295
## 13 VZ     Sample 1  &lt;lm&gt;      0.669
## 14 VZ     Sample 2  &lt;lm&gt;      0.485
## 15 WY     Sample 1  &lt;lm&gt;      1.08 
## 16 WY     Sample 2  &lt;lm&gt;      0.772
## 17 XLNX   Sample 1  &lt;lm&gt;      1.07 
## 18 XLNX   Sample 2  &lt;lm&gt;      1.42 
## 19 ZBH    Sample 1  &lt;lm&gt;      0.888
## 20 ZBH    Sample 2  &lt;lm&gt;      0.944</code></pre>
<p>As we can see, the output now shows the beta for all combinations between <code>ticker</code> and <code>my.sample</code>. It seems that the betas tend to be higher for <em>Sample 2</em>, meaning that the overall systematic risk in the market has increased over time, at least for the majority of the ten chosen stocks. Given the small sample of stocks, It might be interesting to test for this property in a larger dataset.</p>
<p>Back to the model, if you want more information about it, you can just write new lines in the last call to %&gt;%. Let’s say, for example, that you want to get the value of alpha and the corresponding t-statistic of both coefficients. We can use the following code for that:</p>
<pre class="r"><code>library(dplyr)

beta.tab &lt;- df.stocks %&gt;% 
  group_by(ticker) %&gt;% # group by column ticker
  do(ols.model = lm(data = ., formula = ret.adjusted.prices ~ret.MktIdx)) %&gt;%   # estimate model
  mutate(beta = coef(ols.model)[2],
         beta.tstat = summary(ols.model)[[4]][2,3],
         alpha = coef(ols.model)[1],
         alpha.tstat = summary(ols.model)[[4]][1,3]) # get coefficients</code></pre>
<pre><code>## Warning in summary.lm(ols.model): essentially perfect fit: summary may be
## unreliable

## Warning in summary.lm(ols.model): essentially perfect fit: summary may be
## unreliable</code></pre>
<pre class="r"><code>print(beta.tab)</code></pre>
<pre><code>## Source: local data frame [10 x 6]
## Groups: &lt;by row&gt;
## 
## # A tibble: 10 x 6
##    ticker ols.model  beta beta.tstat     alpha alpha.tstat
##    &lt;chr&gt;  &lt;list&gt;    &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
##  1 ^GSPC  &lt;lm&gt;      1        3.49e17  0              0    
##  2 BEN    &lt;lm&gt;      1.26     2.99e 1 -0.000708      -1.96 
##  3 C      &lt;lm&gt;      1.35     3.46e 1 -0.000184      -0.548
##  4 OXY    &lt;lm&gt;      1.00     2.19e 1 -0.000217      -0.551
##  5 ROL    &lt;lm&gt;      0.806    2.11e 1  0.000879       2.67 
##  6 VTR    &lt;lm&gt;      0.492    8.94e 0 -0.000144      -0.304
##  7 VZ     &lt;lm&gt;      0.586    1.65e 1  0.000287       0.935
##  8 WY     &lt;lm&gt;      0.940    2.24e 1 -0.000463      -1.28 
##  9 XLNX   &lt;lm&gt;      1.23     2.46e 1  0.000623       1.45 
## 10 ZBH    &lt;lm&gt;      0.913    2.17e 1 -0.000164      -0.451</code></pre>
<p>In the previous code, I added line <code>beta.tstat = summary(ols.model)[[4]][2,3]</code> that returns the t-statistic of the beta coefficient. The location of this parameter is found by investigating the elements of an object of type <code>lm</code>. After calling <code>summary</code>, the t-statistic is available in the fourth element of the <code>lm</code> object, which is a matrix with several information from the estimation. The t-statistic for the alpha parameter is found in a similar way.</p>
<p>As you can see, the syntax of <code>dplyr</code> make it easy to extend the model and quickly try new things. It is possible to do the same using other R functions and a loop, but using <code>dplyr</code> is really handy.</p>
</div>
</div>
<div id="conclusions" class="section level1">
<h1>Conclusions</h1>
<p>As you can probably suspect from the text, I’m a big fan of <code>dplyr</code> and I’m always teaching its use to my students. While loops are ok and I personally use then a lot in more complex problems, the functions in <code>dplyr</code> allow for an intuitive syntax in data processing, making it easy to understand and extend code.</p>
<p>Do notice that the code in this example is self contained and reproducible. If you want to try it for more stocks, just change input <code>n.chosen.stocks</code> to a higher value.</p>
</div>
