[{"path":"index.html","id":"bem-vindo","chapter":"Bem vindo!","heading":"Bem vindo!","text":"\n Seja bem vindo ao site livro Análise de Dados Financeiros e Econômicos com o R, terceira edição. Aqui encontrarás o conteúdo integral livro para os primeiros sete capítulos. obra completa está disponível como um ebook, impresso capa normal ou impresso capa dura. Se gostaste livro e estás utilizando-o para o seu trabalho, considere comprar obra em um dos seus formatos. papel de autor, aprecio o gesto e irei considerá-los como um fator motivante para futuras edições.\nEsta versão online livro também está disponível para download como pdf e ebook1, com os sete primeiros capítulos na forma integral.","code":""},{"path":"index.html","id":"licença-de-uso","chapter":"Bem vindo!","heading":"Licença de uso","text":"Este trabalho é licenciado pela Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. O código contigo neste site, e livro como um todo, é disponibilizado pela licença MIT, portanto, sinta-se livre para utilizá-lo seu trabalho, desde de que origem código seja citada. Uma sugestão de citação é disponibilizada abaixo:Perlin, M. S. Análise de Dados Financeiros com o R. Terceira Edição, Porto Alegre: Marcelo S. Perlin (publicação independente), 2021.","code":""},{"path":"index.html","id":"sobre-o-autor","chapter":"Bem vindo!","heading":"Sobre o Autor","text":"Sou professor e pesquisador programa de pós-graduação em Administração da Universidade Federal Rio Grande Sul (UFRGS). Também sou autor e mantenedor de diversos pacotes R disponíveis CRAN e Github, muitos desses contemplados livro. Maiores detalhes sobre meu trabalho acadêmico estão disponíveis meu site pessoal","code":""},{"path":"index.html","id":"livros-do-autor","chapter":"Bem vindo!","heading":"Livros do Autor","text":"Poupando e Investindo em Renda Fixa: Este livro apresenta uma forma de investir com foco longo prazo, resiliência e na qualidade de vida investidor. Contrário crença popular, investir para o longo prazo é fácil e pode ser feito por qualquer pessoa com vontade de aprender. O grande diferencial da obra é o uso frequente de dados financeiros reais para entender melhor como o mercado de renda fixa funciona, os efeitos dos tributos e custos operacionais, e quais são melhores opções para o investidor pessoa física. Cada capítulo livro apresenta e analisa os principais produtos disponíveis na renda fixa: produtos bancários (CDBs, LCA, entre outros), Tesouro Direto (Prefixado, IPCA+, SELIC), fundos de renda fixa e debêntures.Poupando e Investindo em Renda Fixa: Este livro apresenta uma forma de investir com foco longo prazo, resiliência e na qualidade de vida investidor. Contrário crença popular, investir para o longo prazo é fácil e pode ser feito por qualquer pessoa com vontade de aprender. O grande diferencial da obra é o uso frequente de dados financeiros reais para entender melhor como o mercado de renda fixa funciona, os efeitos dos tributos e custos operacionais, e quais são melhores opções para o investidor pessoa física. Cada capítulo livro apresenta e analisa os principais produtos disponíveis na renda fixa: produtos bancários (CDBs, LCA, entre outros), Tesouro Direto (Prefixado, IPCA+, SELIC), fundos de renda fixa e debêntures.Analyzing Financial Economic Data R: Versão internacional livro “Análise de Dados Financeiros com o R”. Versão web disponível aqui.Analyzing Financial Economic Data R: Versão internacional livro “Análise de Dados Financeiros com o R”. Versão web disponível aqui.","code":""},{"path":"sobre-nova-edição.html","id":"sobre-nova-edição","chapter":"Sobre Nova Edição","heading":"Sobre Nova Edição","text":"Desde última edição livro em 2018, muita coisa mudou. O ecossistema R e RStudio tem evoluído de forma constante. Em um esforço de atualização, tenho enorme prazer em publicar terceira edição de “Análise de Dados Financeiros e Econômicos com o R”. É gratificante perceber que, como um bom vinho, o conteúdo livro só melhora com o tempo.O diferencial da terceira edição é o foco leitor. principais mudanças são:Todo o conteúdo livro agora é disponibilizado via pacote adfeR, facilitando muito reprodução de todos os exemplos de código.Todo o conteúdo livro agora é disponibilizado via pacote adfeR, facilitando muito reprodução de todos os exemplos de código.Uso de caixas de textos customizadas para indicar pontos importantes e precauções que os leitores devem ter em cada seção livro.Uso de caixas de textos customizadas para indicar pontos importantes e precauções que os leitores devem ter em cada seção livro.Mais de 100 exercícios de final de capítulo foram criados e agora possuem gabarito em texto e código, disponível na versão web livro2. Todos os exercícios estão disponíveis formato exams (Zeileis et al. 2022) e podem ser compilados para um pdf ou então exportados para plataformas de e-learning, tal como o Moodle ou Blackboard (veja seção Conteúdo para Instrutores Prefácio).Mais de 100 exercícios de final de capítulo foram criados e agora possuem gabarito em texto e código, disponível na versão web livro2. Todos os exercícios estão disponíveis formato exams (Zeileis et al. 2022) e podem ser compilados para um pdf ou então exportados para plataformas de e-learning, tal como o Moodle ou Blackboard (veja seção Conteúdo para Instrutores Prefácio).Quatro novos pacotes especializados na obtenção de dados financeiros e econômicos estão inclusos na nova edição. São estes: GetDFPData2, GetFREData, GetQuandlData e GetBCBData. Todos são pacotes estáveis, desenvolvidos por mim e serão mantidos ao longo tempo. Assim, não corremos mais o risco de quebra de código devido desatualização de um pacote por um autor.Quatro novos pacotes especializados na obtenção de dados financeiros e econômicos estão inclusos na nova edição. São estes: GetDFPData2, GetFREData, GetQuandlData e GetBCBData. Todos são pacotes estáveis, desenvolvidos por mim e serão mantidos ao longo tempo. Assim, não corremos mais o risco de quebra de código devido desatualização de um pacote por um autor.Um novo capítulo sobre Otimização de Código em R, discutindo melhorias na estrutura de código e também minimização tempo de execução via estratégias de cacheamento local e processamento paralelo.Um novo capítulo sobre Otimização de Código em R, discutindo melhorias na estrutura de código e também minimização tempo de execução via estratégias de cacheamento local e processamento paralelo.Uso de template customizado para o ebook e html via CSS (Cascading Style Sheets). Agora, o livro possui, sem dúvida, uma cara própria e consistente entre os diferentes formatos.Uso de template customizado para o ebook e html via CSS (Cascading Style Sheets). Agora, o livro possui, sem dúvida, uma cara própria e consistente entre os diferentes formatos.Este livro é um projeto vitalício que pretendo atualizar frequentemente. Vejo neste trabalho uma maneira de contribuir para formação profissional de uma nova geração de pesquisadores e analistas de mercado. Espero que goste da obra e use-para tornar o R um aliado seu ciclo de trabalho.","code":""},{"path":"prefácio.html","id":"prefácio","chapter":"Prefácio","heading":"Prefácio","text":"Dado que se interessou por este livro, prevejo que você é um aluno de pós-graduação dando os primeiros passos em pesquisa com dados, ou é um profissional experiente procurando conhecer novas ferramentas para utilizar em seu trabalho. Em ambos os casos, este livro é para você. finalidade e objeto deste trabalho é introduzir o leitor ao uso R como ferramenta de computação e análise de dados, com uma ênfase especial para pesquisa empírica tópico de Finanças e Economia. Ao final deste livro você irá aprender como utilizar o R para importar e manipular dados e, por fim, reportar tabelas e figuras de uma pesquisa em um relatório técnico.Este livro é o resultado meu trabalho como docente na Escola de Administração da Universidade Federal Rio Grande Sul. programa de pós-graduação em Administração, eu leciono uma disciplina introdutória ao uso R para resolver problemas de pesquisa na área de Finanças e Economia. Observando os alunos em sala de aula, percebo diariamente o impacto positivo que esse tipo de orientação tem em suas futuras carreiras profissionais, seja como pesquisadores acadêmicos, seja como analistas de dados em organizações públicas e privadas. Este livro é um projeto pessoal para disseminar conhecimento sobre ferramenta para um público maior e mais diversificado.Outra motivação que tive para escrever o livro foi minha experiência na utilização de códigos disponibilizados por outros pesquisadores em pesquisas específicas. Na maioria das vezes, esses códigos são desorganizados, pouco claros e, possivelmente, funcionam apenas computador pesquisador que os escreveu! Surpreendentemente, devido desorganização, o trabalho de desvendar o código de outros professores tende levar mais tempo que desenvolver eu mesmo o procedimento, por mais complexo que ele fosse. Esses casos, aliás, ferem ciência, pois um dos princípios básicos da pesquisa é replicabilidade - isto é, uma rotina de pesquisa mal escrita irá reduzir possibilidade de outras pessoas utilizarem.Assim como se espera que um artigo científico esteja bem escrito, também se deve esperar que o código por trás da respectiva pesquisa seja de qualidade. Porém, esse não é o caso na grande maioria das vezes. Com este livro, irei atacar esse problema, formalizando uma estrutura de código voltada à reprodutibilidade científica, focando em organização e usabilidade. Nesse sentido, espero que futuras gerações de pesquisadores estejam mais bem preparadas para compartilhar o seu trabalho.Antes de prosseguir, um aviso. Não iremos trabalhar usos avançados R. O conteúdo será limitado exemplos simples e práticos de utilização software para construção de pesquisa baseada em dados financeiros e econômicos. De fato, um dos desafios na escrita deste livro foi definir o limite entre o material introdutório e o avançado. Procurei, sempre que possível, dosar gradualmente o nível de complexidade. Para leitores interessados em conhecer funções avançadas programa e o seu funcionamento interno, sugiro leitura manual oficial R (Teetor 2011) e de Wickham (2019).Com este livro irás aprender os seguinte tópicos:Usar o R e RStudio\nO capítulo 01 apresenta, discute e justifica o uso R como uma plataforma de programação desenhada para resolver problemas relacionados dados. capítulo 02 exploraremos os comandos básicos R e os recursos RStudio, incluindo criação de objetos, execução de scripts, interação com o disco rígido computador, e muito mais.\nImportação de dados financeiros e econômicos\nNos capítulos 04 e 05 vamos aprender importar dados de arquivos locais, tal como uma planilha Excel, ou então da internet. Aprenderemos tirar proveito da modularidade R e, quando necessário, instalar pacotes que permitam o download de dados diversos tal como preços de ações, índices econômicos, curva de juros, dados financeiros de empresas e muito mais.\nLimpar, estruturar e analisar dados\nNos capítulos 06 e 07 iremos estudar o ecossistema de objetos R. Aprenderemos manipular objetos tal como vetores numéricos, datas e tabelas inteiras. Nos capítulo 08 e 09 vamos estudar o uso de ferramentas de programação para resolver problemas com dados incluindo limpeza, reestruturação e também análise.\nVisualização de dados\ncapítulo 10 aprenderemos usar o pacote ggplot2 para criar visualizações conjunto de dados, incluindo os casos mais comuns em finanças e economia, séries temporais e gráficos estatísticos.\nAnalisar dados com econometria\ncapítulo 11 aprenderemos usar os modelos econométricos mais populares em finanças e economia, incluindo o modelo linear, GLM, Arima e outros. Isto inclui simulação, teste de hipóteses e estimação de modelos para diversas séries de dados reais.\nReporte de resultados\ncapítulo 12 veremos como reportar os resultados de sua pesquisa para um documento externo com exportação fácil e reproduzível de tabelas e figuras. O conteúdo também inclui uma seção sobre inovadora tecnologia RMarkdown, qual permite que código e texto sejam compilados conjuntamente.\nMelhorando o seu código\núltimo capítulo livro vamos discutir melhores práticas de programação, incluindo análise perfil de execução código R, destacando pontos de gargalo e melhoria tempo de execução com estratégias de cacheamento local, uso de código C++ e processamento paralelo.\n","code":""},{"path":"prefácio.html","id":"material-suplementar","chapter":"Prefácio","heading":"Material Suplementar","text":"Todo o material usado livro, incluindo exemplos de código separados por capítulos, está publicamente disponível na Internet e distribuído com um pacote R denominado adfeR. Este inclui arquivos de dados, código em si, e várias funções que irão facilitar execução dos exemplos livro. Se você planeja, como sugerido, escrever código enquanto lê o livro, este pacote ajudará muito em sua jornada.Para instalar este pacote seu computador, basta executar algumas linhas de comando R. Veja o código destacado seguir e copie e cole o mesmo prompt RStudio (canto inferior esquerdo da tela, com um sinal “>”) e pressione Enter para cada comando. Esteja ciente de que você precisará R e RStudio instalados em seu computador (consulte seção 1.4).O que este código fará é instalar o pacote devtools, uma dependência necessária para instalar código Github – um repositório de pacotes onde o livro está hospedado. Depois disso, uma chamada para install_github('msperlin/adfeR') irá instalar o pacote em seu computador.Depois da instalação, todos os arquivos livro estarão disponíveis localmente, salvos em uma pasta seu computador. Iremos usar todos estes arquivos futuramente. Opcionalmente, caso quiser olhar os arquivos, podes copiar todo conteúdo para outra pasta com o código seguir:Veja que o tilda (~) é um atalho para o diretório “Documentos” Windows (ou “home” Linux/Mac). Assim, o código anterior descompactará o arquivo livro na pasta “Documentos/adfeR-files”. O pacote também inclui várias outras funções que serão usadas ao longo livro. Se você preferir maneira antiga e consagrada de baixar o arquivo e descompactar manualmente, podes encontrar uma cópia site livro3.","code":"\n# install devtools dependency\ninstall.packages('devtools')\n\n# install book package\ndevtools::install_github('msperlin/adfeR')\nadfeR::copy_book_files(path_to_copy = '~')"},{"path":"prefácio.html","id":"conteúdo-para-instrutores","chapter":"Prefácio","heading":"Conteúdo para Instrutores","text":"Se você um instrutor de R, aqui encontrarás muito material para usar em suas aulas:Exercícios estáticos na internet\nCada capítulo deste livro inclui exercícios que seus alunos podem praticar. Todas soluções estão disponíveis na versão online livro, disponível em https://www.msperlin.com/adfeR/.\nExercícios exportáveis para pdf ou plataformas de e-learning\nTodos exercícios livro estão formato exams (Zeileis et al. 2022) e são exportáveis para arquivos em pdf ou então para plataformas de e-learning tal como o Moodle ou Blackboard. Veja este post blog4 para maiores detalhes.\nAcesso ao livro na internet\nNa versão web livro, o conteúdo integral está liberado até o capítulo 7, o qual é mais que suficiente para um curso introdutório sobre plataforma.\nEspero que goste deste livro. O conteúdo tem sido compilado por um longo período de tempo, base de muito suor e, literalmente, litros de café por parte autor.Boa leitura!Marcelo S. Perlin","code":""},{"path":"introducao.html","id":"introducao","chapter":"Capítulo 1 Introdução","heading":"Capítulo 1 Introdução","text":"Na era digital, informação é abundante e de fácil acesso. Nota-se, em todas áreas de conhecimento, um crescimento substancial registro digital dos mais diversos eventos. cada segundo, volumosos bancos de dados de diferentes empresas e organizações são alimentados com novas informações. Essa tendência impõe uma alteração significativa na forma como organizações utilizam análise de dados na tomada de decisões. Sem dúvida, o período atual é bastante prolífico para profissionais com conhecimento e experiência na utilização das ferramentas corretas para análise computacional de dados.Em particular, área de Economia e Finanças oferece grande variedade de informações disponíveis ao público. Instituições de pesquisa como IBGE, IPEA, Bancos Centrais, bolsas de valores e tantas outras, disponibilizam seus dados publicamente, seja por obrigatoriedade legal, seja para o próprio fomento da atividade de pesquisa. Hoje em dia, computadores domésticos já possuem capacidade de processar quantidades volumosas de dados em pouco tempo. Essa evolução aparato computacional ocorreu mais rapidamente que o acréscimo de complexidade das metodologias utilizadas, resultando em uma diminuição significativa tempo necessário para execução de uma pesquisa. Ou seja, o volume de dados não é mais uma barreira de entrada para analistas.Os métodos de processamento também avançaram em termos de complexidade. passado, uma simples planilha eletrônica poderia dar conta trabalho de análise. Hoje em dia, é esperado que um analista de dados ou aluno de pós-graduação saiba programar e analisar dados via código, facilitando e acelerando obtenção de resultados, permitindo colaboração via reproducibilidade de resultados.É nesse ambiente que se destaca o papel R, uma linguagem de programação voltada para resolução de problemas computacionais envolvendo análise, processamento, visualização e modelagem de dados. Nas próximas seções, explicarei o que é o R e quais são suas vantagens frente outras alternativas.","code":""},{"path":"introducao.html","id":"o-que-é-o-r","chapter":"Capítulo 1 Introdução","heading":"1.1 O que é o R","text":"O R é uma linguagem de programação voltada para resolução de problemas estatísticos e para visualização gráfica de dados. O código base R foi inspirado na linguagem S, inicialmente criada laboratório da Bell/&T por John Chambers e seus colegas. Esse código foi reaproveitado por dois acadêmicos, Ross Ihaka e Robert Gentleman, resultando na plataforma de programação que temos hoje. Para os curiosos, o nome R foi escolhido devido ao compartilhamento da primeira letra nome de seus criadores.Hoje, R é sinônimo de programação voltada à análise de dados, com uma larga base de usuários e funções bem estabelecidas. É muito provável que pesquisadores de áreas diversas, desde Economia até Biologia, ou mesmo Música, encontrem R uma quantidade significativa de códigos que facilitem suas análises. campo empresarial, grandes empresas como Google e Microsoft já o adotaram como linguagem interna para análise de dados. O R é atualmente mantido pelo R Foundation e o R Consortium, um esforço coletivo para financiar projetos de extensão da linguagem.E o mais importante: o R é totalmente livre e disponível em vários sistemas operacionais. Seja você um usuário Windows, Linux/Unix ou MacOS, existe uma instalação R para sua plataforma, e os seus códigos devem rodar entre uma e outra com mínimas alterações.","code":""},{"path":"introducao.html","id":"por-que-escolher-o-r","chapter":"Capítulo 1 Introdução","heading":"1.2 Por que Escolher o R","text":"O processo de aprendizado de uma nova linguagem de programação exige muito tempo e esforço. Portanto, é importante entender razões por trás dessa escolha. Possivelmente você esteja se perguntando por que deve optar pelo R e investir tempo em sua aprendizagem, ao invés de escolher uma outra linguagem.Em primeiro lugar, o R é uma plataforma madura, estável, continuamente suportada e intensamente utilizada na indústria. Ao escolher o R, você terá bagagem computacional necessária não somente para uma carreira acadêmica em pesquisa científica, mas também para o trabalho em organizações privadas. Nesse sentido, com escolha de outra linguagem de programação menos popular ou proprietária/comercial, é provável que tal linguagem não seja utilizada em um ambiente empresarial e isso pode limitar suas oportunidades profissionais futuras. Uma bagagem de conhecimento em R certamente aumenta sua atratividade como um profissional em Finanças e Economia.Aprender linguagem R é fácil. experiência que tenho ensinando o R em sala de aula permite afirmar que os alunos, mesmo aqueles sem experiência em programação, apresentam facilidade em aprender linguagem e em utilizá-la para criar seus próprios códigos de pesquisa. linguagem é intuitiva e certas normas e funções podem ser estendidas para diferentes casos. Após entender como o programa funciona, fica fácil descobrir novas funcionalidades partindo de uma lógica anterior. Essa notação compartilhada entre procedimentos facilita o aprendizado.interface R e RStudio torna o uso da ferramenta bastante produtivo. interface gráfica disponibilizada pelo RStudio facilita o uso software, assim como produtividade usuário. Utilizando o ambiente de trabalho R e RStudio, têm-se disposição diversas ferramentas que facilitam e estendem o uso da plataforma.Os pacotes R permitem mais diversas funcionalidades. Logo veremos que o R permite o uso de código de outros usuários, os quais podem ser localmente instalados através de um simples comando. Esses estendem linguagem básica R e possibilitam mais diversas funcionalidades. Podes, por exemplo, utilizar o R para mandar emails estruturados, escrever e publicar um livro, criar provas objetivas com conteúdo dinâmico, contar piadas e poemas (é sério!), acessar e coletar dados da internet, entre diversas outras funcionalidades.O R tem compatibilidade com diferentes linguagens e sistemas operacionais. Se, por algum motivo, o usuário precisar utilizar código de outra linguagem de programação tal como C++, Python, Julia, é fácil integrar mesma dentro de um programa R. Diversos pacotes estão disponíveis para facilitar esse processo. Portanto, o usuário nunca fica restrito uma única linguagem e tem flexibilidade para escolher suas ferramentas de trabalho.O R é totalmente gratuito! O programa e todos os seus pacotes são completamente livres, não tendo custo algum de licença e distribuição. Portanto, você pode utilizá-lo e modificá-lo livremente seu trabalho ou computador pessoal. Essa é uma razão muito forte para adoção da linguagem em um ambiente empresarial, onde obtenção de licenças individuais e coletivas de outros softwares comerciais pode incidir um alto custo financeiro.","code":""},{"path":"introducao.html","id":"usos-do-r","chapter":"Capítulo 1 Introdução","heading":"1.3 Usos do R","text":"O R é uma linguagem de programação completa e qualquer problema computacional pode ser resolvido com base nela. Dada adoção R por diferentes áreas de conhecimento, lista de possibilidades é extensa. Para o caso de Finanças e Economia, destaco abaixo possíveis utilizações programa:Substituir e melhorar tarefas intensivas e repetitivas dentro de ambientes corporativos, geralmente realizadas em planilhas eletrônicas;Substituir e melhorar tarefas intensivas e repetitivas dentro de ambientes corporativos, geralmente realizadas em planilhas eletrônicas;Desenvolvimento de rotinas para administrar portfolios de investimentos e executar ordens financeiras;Desenvolvimento de rotinas para administrar portfolios de investimentos e executar ordens financeiras;Criação de ferramentas para controle, avaliação e divulgação de índices econômicos sobre um país ou região;Criação de ferramentas para controle, avaliação e divulgação de índices econômicos sobre um país ou região;Execução de diversas possibilidades de pesquisa científica através da estimação de modelos econométricos e testes de hipóteses;Execução de diversas possibilidades de pesquisa científica através da estimação de modelos econométricos e testes de hipóteses;Criação e manutenção de websites dinâmicos ou estáticos através pacotes shiny, blogdown ou distill;Criação e manutenção de websites dinâmicos ou estáticos através pacotes shiny, blogdown ou distill;Organização de um processo automatizado de criação e divulgação de relatórios técnicos com o pacote knitr e tecnologia RMarkdown.Organização de um processo automatizado de criação e divulgação de relatórios técnicos com o pacote knitr e tecnologia RMarkdown.Além dos usos destacados anteriormente, o acesso público pacotes desenvolvidos por usuários expande ainda mais essas funcionalidades. O site da CRAN (Comprehensive R Archive Network)5 oferece um Task Views software para o tópico de Finanças6 e Econometria7. Nos links é possível encontrar os principais pacotes disponíveis para cada tema. Isso inclui importação de dados financeiros da internet, estimação de um modelo econométrico específico, cálculos de diferentes estimativas de risco, entre várias outras possibilidades. leitura dessa página e o conhecimento desses pacotes são essenciais para aqueles que pretendem trabalhar com Finanças e Economia. Vale destacar, porém, que essa lista é moderada e apresenta apenas os principais itens. lista completa de pacotes é muito maior que o apresentado Task Views. ","code":""},{"path":"introducao.html","id":"instalacao","chapter":"Capítulo 1 Introdução","heading":"1.4 Como Instalar o R","text":"O R é instalado seu sistema operacional como qualquer outro programa. maneira mais direta e funcional de instalá-lo é ir ao website R em https://www.r-project.org/ e clicar link CRAN painel Download, conforme mostrado na figura seguir.\nFigura 1.1: Página inicial para o download R\npróxima tela apresenta escolha espelho para baixar os arquivos de instalação. O repositório CRAN é espelhado em diversas partes mundo, permitindo acesso rápido para os usuários. Para grande maioria dos leitores deste livro, essa localidade deve ser o Brasil. Portanto, você pode escolher um dos links da instituição mais próxima, tal como o da UFPR (Universidade Federal Paraná). Em caso de dúvida, escolha o repositório RStudio 0-Cloud (veja Figura \\(\\ref{fig:website-cran-2}\\)), o qual automaticamente direciona para o local mais próximo.\nFigura 1.2: Tela com escolha espelho para o download\nO próximo passo é selecionar o sistema operacional computador. Devido à maior popularidade da plataforma Windows, partir de agora daremos enfoque à instalação R nesse sistema. instruções de instalação nos demais sistemas operacionais podem ser facilmente encontradas na internet. Destaca-se que, independente da plataforma, o modo de uso R é o mesmo. Existem, porém, algumas exceções, principalmente quando o R interage com o sistema de arquivos. Essas exceções serão destacadas decorrer livro. Assim, mesmo que você esteja utilizando Linux ou MacOS, poderá tirar proveito material aqui apresentado.\nFigura 1.3: Tela com escolha sistema operacional\nApós clicar link Download R Windows, próxima tela irá mostrar seguintes opções de download: base, contrib, old.contrib e RTools. Dentre opções de download, primeira (base) deve ser selecionada. O link acessa instalação básica R para Windows. O link contrib e old.contrib acessa os pacotes/módulos disponíveis para o R. Não precisas acessar estes últimos links, existe uma maneira muito mais fácil de instalar pacotes, como veremos em seguida.O último link, RTools, serve para instalar dependências necessárias caso usuário desenvolver e distribuir os seus próprios pacotes de R. Este não é uma instalação necessária para usuários iniciantes. Porém, saiba que alguns pacotes externos ao CRAN podem exigir instalação RTools para compilação de código. Minha sugestão é que já instale este software e assim evite qualquer problema futuro.\nFigura 1.4: Tela com opções de instalação\nApós clicar link base, próxima tela mostrará o link para o download arquivo de instalação R Windows.\nFigura 1.5: Tela para o download R\nApós baixar o arquivo, abra-o e siga os passos da tela de instalação R. Escolha língua inglesa em todas etapas processo. O uso da língua inglessa não é acidental. Este é melhor forma, mesmo para iniciantes, de se aprender usar o R. É possível instalar uma versão em português porém isso limita o potencial da ferramenta. Caso não fluente em inglês, não se preocupe, o vocabulário necessário é básico. Neste momento, nenhuma outra configuração especial é necessária. Sugiro manter todas escolhas padrão selecionadas e simplesmente ir aceitando telas de diálogo. Após instalação R, partimos para instalação RStudio.\ncada quatro meses uma nova versão R é lançada, corrigindo\nbugs e implementando novas soluções. Temos dois tipos\nprincipais de versões, major e minor. Por exemplo,\nhoje, 05/02/2021, última versão R é 4.0.3. O primeiro dígito (“4”)\nindica versão major e todos os demais são tipo\nminor. Geralmente, mudanças minor são bem\nespecíficas e, possivelmente, terão pouco impacto seu trabalho.\n\nPorém, ao contrário de mudanças minor, mudanças tipo\nmajor refletem totalmente ecossistema de pacotes R. Toda\nvez que instalar uma nova versão major R, terás que\nreinstalar todos os pacotes utilizados. O problema é que não é incomum\nproblemas de incompatibilidade de pacotes com nova versão.\n\nMinha dica é: toda vez que uma nova versão major R sair,\nespere alguns meses antes de instalar na sua máquina. Assim, o autores\ndos pacotes terão mais tempo para atualizar os seus códigos, minimizando\npossibilidade de problemas de compatibilidade.\n","code":""},{"path":"introducao.html","id":"instalando-o-rstudio","chapter":"Capítulo 1 Introdução","heading":"1.5 Instalando o RStudio","text":"instalação R inclui sua própria interface gráfica, um programa que facilita edição e execução de nossos scripts. Essa, porém, possui várias limitações. O RStudio é um software que torna o uso e o visual R muito mais prático e eficiente. Uma forma de entender essa relação é com uma analogia com carros. Enquanto o R é o motor da linguagem de programação, o RStudio é carroceria e o painel de instrumentos, os quais melhoram significativamente experiência de uso. Além de apresentar um visual mais atrativo, o RStudio também é acrescido de várias funcionalidades que facilitam vida usuário, possibilitando construção de projetos e pacotes próprio R, criação de documentos dinâmicos (Sweave/knitr) e interface com edição de textos em LaTeX, entre várias outras. Assim como o R, o RStudio também é gratuito e pode ser utilizado ambiente empresarial.instalação RStudio é mais simples que R. Os arquivos estão disponíveis endereço disponibilizado site livro. Após acessar página, clique em Download RStudio e depois em Download Rstudio Desktop. Logo após, basta selecionar o arquivo relativo ao sistema operacional em que você irá trabalhar. Provavelmente, essa opção será Windows Vista/7/8/10. Note que, assim como o R, o RStudio também está disponível para diferentes plataformas.Destaco que o uso RStudio não é essencial para desenvolver programas R. Outros softwares de interface estão disponíveis e podem ser utilizados. Porém, dada minha experiência atual, o RStudio é o programa de interface que oferece maior variedade de funcionalidades para essa linguagem, além de ser amplamente utilizado, o que justifica sua escolha.","code":""},{"path":"introducao.html","id":"recursos-na-internet","chapter":"Capítulo 1 Introdução","heading":"1.6 Recursos na Internet","text":"comunidade R é viva e envolvente. Na internet é possível encontrar uma diversidade de material sobre o uso R. Diversos usuários, assim como o próprio autor livro, publicam material sobre o uso R em seus blogs. Isso inclui anúncios de pacotes, publicações sobre análise de dados na vida real, curiosidades, novidades e tutoriais. R-Bloggers é um site internacional que agrega esses blogs em um único local, tornando mais fácil para qualquer um acessar e participar. O conteúdo R-Bloggers, porém, é todo em inglês.Recentemente, uma lista de blogs locais sobre o R está compilada e organizada por Marcos Vital em https://marcosvital.github.io/blogs-de-R--Brasil/. Eu recomendo inscrição feed R-Bloggers, além dos blogs nacionais. Não só você será informado sobre o que está acontecendo universo R, mas também aprenderá muito lendo artigos e os códigos de outros usuários.Aprender e usar R pode ser uma experiência social. Várias conferências e grupos de usuários estão disponíveis em muitos países, incluindo o Brasil. O grupo R Brasil - Programadores Facebook é bastante ativo, com um grande número de participantes. Recomendo fortemente inscrição neste grupo e o acompanhamento das discussões relacionadas ao uso R. Diversas conferências locais sobre o R são divulgadas nesse grupo.","code":""},{"path":"introducao.html","id":"organização-e-material-do-livro","chapter":"Capítulo 1 Introdução","heading":"1.7 Organização e Material do Livro","text":"Este livro tem uma abordagem prática uso R e será acompanhado por uma série de códigos que irão exemplificar e mostrar para o leitor funcionalidades programa. Para tirar o máximo de proveito material, sugiro que você primeiro busque entender o código mostrado e, somente então, tente utilizá-lo em seu próprio computador. O índice remissivo disponibilizado final livro serve como uma mapa de uso das funções. Toda vez que uma função é chamada livro, um registro número da página é criado índice remissivo. Esse indica, também, o pacote que função pertence. Podes utilizar este mapa para localizar o uso de qualquer função ou pacote decorrer livro.Sugiro também o uso da versão web livro8, qual permite que os código de exemplo sejam copiados direto para sua sessão R. Assim, perderás menos tempo digitando código, sobrando tempo para o estudo.Aprender programar em uma nova linguagem é como aprender uma língua estrangeira: o uso dia--dia é de extrema importância para criar fluência. Sempre que possível, teste o código seu computador e brinque com o mesmo, modificando os exemplos dados e verificando o efeito das modificações nas saídas programa. Procure sempre entender como rotina estudada pode ajudar na solução de um problema seu. Cada capítulo apresenta seu final uma lista de exercícios, incluindo questões tipo desafio. Podes testar suas habilidades de programação resolvendo atividades propostas. Vale relembrar que todo o código deste livro está disponibilizado na internet. Não precisas, portanto, escrever o código diretamente livro. Podes copiar e colar código fonte disponibilizado site.decorrer da obra, toda demonstração de código terá duas partes: o código em si e sua saída R. Essa saída nada mais é que o resultado dos comandos na tela programa. Todas entradas e saídas de código serão sinalizadas texto com um formato especial. Veja o exemplo seguir:caso anterior, os textos L <- list(var1 = 'abc', var2 = 1:5) e print(L) são os códigos de entrada. saída programa é apresentação na tela dos elementos de x, com o símbolo antecessor R>. Por enquanto não se preocupe em entender e reproduzir o código utilizado acima. Iremos tratar disso próximo capítulo.Note que faço uso da língua inglesa código, tanto para nomeação de objetos quanto para os comentários. Isso não é acidental. O uso da língua inglesa facilita o desenvolvimento de código ao evitar caracteres latinos, além de ser uma das línguas mais utilizadas mundo. Portanto, é importante já ir se acostumando com esse formato. O vocabulário necessário, porém, é limitado. De forma alguma precisarás ter fluência em inglês para entender o código.O código também pode ser espacialmente organizado usando novas linhas. Esse é um procedimento comum em torno de argumentos de funções. O próximo pedaço de código é equivalente ao anterior, e executará exatamente da mesma maneira. Observe como usei uma nova linha para alinhar verticalmente os argumentos da função list. Você verá em breve que, ao longo livro, esse tipo de alinhamento vertical é constantemente usado em códigos longos. Afinal, o código tem que necessariamente caber na página livro.O código também segue uma estrutura bem definida. Uma das decisões ser feita na escrita de códigos de computação é forma de nomear os objetos e como lidar com estrutura texto código em geral. É recomendável seguir um padrão limpo de código, de forma que o mesmo seja fácil de ser mantido ao longo tempo e de ser entendido por outros usuários. Para este livro, foi utilizado uma mistura de escolhas pessoais autor com o estilo de código sugerido pelo Google. O usuário, porém, é livre para escolher estrutura que achar mais eficiente. Voltaremos discutir estrutura de código capítulo 13.","code":"\n# create a list\nL <- list(var1 = 'abc', var2 = 1:5)\n\n# print to prompt\nprint(L)R> $var1\nR> [1] \"abc\"\nR> \nR> $var2\nR> [1] 1 2 3 4 5\n# create a list\nL <- list(var1 = 'abc',\n          var2 = 1:5)\n\n# print to prompt\nprint(L)R> $var1\nR> [1] \"abc\"\nR> \nR> $var2\nR> [1] 1 2 3 4 5"},{"path":"introducao.html","id":"exercícios","chapter":"Capítulo 1 Introdução","heading":"1.8 Exercícios","text":"","code":""},{"path":"introducao.html","id":"q.1","chapter":"Capítulo 1 Introdução","heading":"Q.1","text":"linguagem R foi desenvolvida com base em qual outra linguagem de programação?\n\nSolução\n\n","code":""},{"path":"introducao.html","id":"q.2","chapter":"Capítulo 1 Introdução","heading":"Q.2","text":"Qual o nome dos dois autores R?\n\nSolução\n\n","code":""},{"path":"introducao.html","id":"q.3","chapter":"Capítulo 1 Introdução","heading":"Q.3","text":"Qual o principal diferencial R em relação outras linguagens de programação, tal como Python, C++, javascript e demais?\n\nSolução\n\n","code":""},{"path":"introducao.html","id":"q.4","chapter":"Capítulo 1 Introdução","heading":"Q.4","text":"Qual razão para o nome da linguagem de programação ser R?\n\nSolução\n\n","code":""},{"path":"introducao.html","id":"q.5","chapter":"Capítulo 1 Introdução","heading":"Q.5","text":"Sobre o R, considere seguintes alternativas:- O R foi desenvolvido em 2018 e é um projeto inovador e instável;II - O RStudio é uma linguagem de programação alternativa ao R;III - O R não tem compatibilidade com diferentes linguagens de programação;Quais alternativas estão corretas?\n\nSolução\n\n","code":""},{"path":"introducao.html","id":"q.6","chapter":"Capítulo 1 Introdução","heading":"Q.6","text":"Assim que tiver R e RStudio instalado, dirija-se ao site de pacotes CRAN9 e procure por tecnologias que usas seu trabalho. Por exemplo, se usas Planilhas Google (Sheets)10 ostensivamente seu trabalho, logo descobrirá que existe um pacote CRAN que interage com planilhas na nuvem.\n\nSolução\n\nmeu trabalho uso muito os dados Tesouro Direto para criar e manter material da aula de finanças na graduação. Pois bem, CRAN é possível encontrar o pacote GetTDData, o qual importa e organiza os dados Tesouro Direto. Sou viesado para falar, afinal eu desenvolvi o pacote, mas ele facilitou bastante atualização e exportação desses dados cada semestre. Basta rodar um código e todos minhas tabelas e figuras são atualizadas!","code":""},{"path":"introducao.html","id":"q.7","chapter":"Capítulo 1 Introdução","heading":"Q.7","text":"site de instalação R Windows é possível instalar também o aplicativo Rtools. Para que ele serve?\n\nSolução\n\nO Rtools é uma extensão R particular ao Windows. Este serve para compilar pacotes partir código fonte e é um requisito para quem desenvolve pacotes. Para o usuário comum, porém, também recomenda-se instalação Rtools pois alguns pacotes requerem tal compilação.Para usuários Linux/Unix ou MacOS, o Rtools não é necessário pois, geralmente, os compiladores já estão disponíveis pelo próprio sistema operacional.","code":""},{"path":"introducao.html","id":"q.8","chapter":"Capítulo 1 Introdução","heading":"Q.8","text":"Use o Google para pesquisar por grupos de R em sua região. Verifique se os encontros são frequentes e, caso não tiver um impedimento maior, vá para um desses encontros e faça novos amigos.\n\nSolução\n\nNão é incomum que programadores tenham certa tendência introversão. Certamente este foi meu caso início de carreira. Mas, saiba que timidez é um estado não-permanente, um mecanismo de defesa criado pela sua própria cabeça! Da mesma forma que melhorará em algum esporte quanto mais vezes o praticar, menos tímido será quanto mais vezes buscar se expressar.triste (ou não) realidade para os tímidos é que comunicação é parte fundamental jogo profissional e é uma forma de manter uma rede de relacionamento. Quanto mais pessoas conhecerem o seu trabalho e sua personalidade, melhor. Talvez uma pessoa que conheceste em um desses grupos pode lhe indicar para vaga ou projeto futuro. Assim, resumindo, o que você realmente tem perder indo um desses encontros?","code":""},{"path":"introducao.html","id":"q.9","chapter":"Capítulo 1 Introdução","heading":"Q.9","text":"Dirija-se ao site RBloggers11 e procure por um tópico seu interesse, tal como futebol (soccer) ou investimentos (investments). Leia pelo menos três artigos encontrados.\n\nSolução\n\nParticularmente, sou apaixonado pelo esporte de tênis. site RBloggers encontrei os seguintes artigos misturando R e tennis:Using R study evolution TennisVisualizing Tennis Grand Slam Winners PerformancesTennis Grand Slam Tournaments Champions Basic Analysis","code":""},{"path":"introducao.html","id":"q.10","chapter":"Capítulo 1 Introdução","heading":"Q.10","text":"Caso trabalhe em uma instituição com infrainstrutura de dados, converse com o encarregado e busque entender quais são tecnologias empregadas. Verifique se, através R, é possível ter acesso todas tabelas dos bancos de dados. Por enquanto não existe necessidade de escrever código, ainda. Apenas verifique se esta possibilidade existe.\n\nSolução\n\nNa universidade temos acesso diferentes repositórios pagos para dados financeiros. Infelizmente, nenhum deles oferece algum tipo de API para comunicação com o R. De fato, este foi um dos motivadores para escrita dos pacotes de obtenção de dados financeiros de forma gratuita.","code":""},{"path":"operacoes-basicas.html","id":"operacoes-basicas","chapter":"Capítulo 2 Operações Básicas no R","heading":"Capítulo 2 Operações Básicas no R","text":"Antes de começar desenvolver o seu código, é necessário entender forma de trabalhar com o R e o RStudio. Isso inclui os componentes da linguagem, os diferentes tipos de objetos e operações que podem ser realizadas com base nos comandos existentes.Neste capítulo iremos percorrer os passos iniciais sobre o ponto de vista de alguém que nunca trabalhou com o R e, possivelmente, nunca teve contato com outra linguagem de programação. Aqueles já familiarizados com o programa irão encontrar pouca informação nova e, portanto, sugiro leitura da próxima seção. É recomendado, porém, que mínimo esse usuário verifique os temas tratados para confirmar ou não o seu conhecimento sobre funcionalidades programa. Muitas das sugestões apresentadas aqui tem potencial de aumentar significativamente sua produtividade RStudio.","code":""},{"path":"operacoes-basicas.html","id":"como-o-r-funciona","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.1 Como o R Funciona?","text":"maior dificuldade que um usuário iniciante possui ao começar desenvolver rotinas com o R é forma de trabalho. nossa interação com computadores foi simplificada ao longo dos anos e atualmente estamos confortáveis com o formato de interação tipo aponte e clique. Isto é, caso se queira efetuar alguma operação computador, basta apontar o mouse para o local específico na tela e clicar um botão que realize tal operação. Uma série de passos nesse sentido permite execução de tarefas complexas computador. Mas não se engane, essa forma de interação formato aponte e clique é apenas uma camada por cima que realmente acontece computador. Por trás de todo clique existe um comando sendo executado, seja na abertura de um arquivo pdf, direcionamento browser para uma página na internet ou qualquer outra operação cotidiana de trabalho.Enquanto esse formato de interação visual e motora tem seus benefícios ao facilitar e popularizar o uso de computadores, é pouco flexível e eficaz quando se trabalha com procedimentos computacionais. Ao conhecer os possíveis comandos disponíveis ao usuário, é possível criar um arquivo contendo alguns comandos em sequência e, futuramente, simplesmente pedir que o computador execute esse arquivo com os nossos procedimentos. Uma rotina de computador é nada mais que um texto que instrui, de forma clara e sequencial, o que o computador deve fazer. Investe-se certo tempo para criação programa, porém, futuro, esse irá executar sempre da mesma maneira o procedimento gravado. médio e longo prazo, existe um ganho significativo de tempo entre o uso de uma rotina computador e uma interface tipo aponte e clique.Além disso, o risco de erro humano na execução procedimento é quase nulo, pois os comandos e sua sequência estão registrados arquivo texto e irão ser executados sempre da mesma maneira. Da mesma forma, esse aglomerado de comandos pode ser compartilhado com outras pessoas, quais podem replicar os resultados em seus computadores. Essa é uma das grandes razões que justificam popularização de programação na realização de pesquisa em dados. Todos os procedimentos executados podem ser replicados pelo uso de um script.uso R, o ideal é mesclar o uso mouse com utilização de comandos. O R e o RStudio possuem algumas funcionalidades através mouse, porém sua capacidade é otimizada quando os utilizamos via inserção de comandos específicos. Quando um grupo de comandos é realizado de uma maneira inteligente, temos um script R que deve preferencialmente produzir algo importante para nós final de sua execução. Em Finanças e Economia, isso pode ser o valor atualizado de um portfólio de investimento, o cálculo de um índice de atividade econômica, performance histórica de uma estratégia de investimento, o resultado de uma pesquisa acadêmica, entre diversas outras possibilidades.O R também possibilita exportação de arquivos, tal como figuras serem inseridas em um relatório técnico ou informações em um arquivo texto. De fato, o próprio relatório técnico pode ser dinamicamente criado dentro R através da tecnologia RMarkdown. Por exemplo, este livro que estás lendo foi escrito utilizando o pacote bookdown (Xie 2022), o qual é baseado em RMarkdown. O conteúdo livro é compilado com execução dos códigos e suas saídas são registradas em texto. Todas figuras e os dados livro podem ser atualizados com execução de um simples comando.O produto final de trabalhar com R e RStudio será um script que produz elementos para um relatório de dados. Um bom exemplo de um código simples e polido pode ser encontrado neste link12. Abra-o e você verá o conteúdo de um arquivo com extensão .R que fará o download dos preços das ações de duas empresas e criará um gráfico e uma tabela. Ao terminar de ler o livro, você irá entender o que está acontecendo código e como ele realiza o trabalho. Melhor ainda, você poderá melhorá-lo com novas funcionalidades e novas saídas. Caso esteja curioso em ver o script rodar, faça o seguinte: 1) instale R e RStudio computador, 2) copie o conteúdo de texto link para um novo script (“File” -> “New File” -> “R Script”), 3) salve-o com um nome qualquer e, finalizando, 4) pressione control + shift + enter para executar o script inteiro.","code":""},{"path":"operacoes-basicas.html","id":"objetos-e-funções","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.2 Objetos e Funções","text":"R, tudo é um objeto, e cada tipo de objeto tem suas propriedades. Por exemplo, o valor de um índice de inflação ao longo tempo – em vários meses e anos – pode ser representado como um objeto tipo vetor numérico. datas em si, formato YYYY-MM-DD (ano-mês-dia), podem ser representadas como texto (character) ou própria classe Date. Por fim, podemos representar conjuntamente os dados de inflação e datas armazenando-os em um objeto único tipo dataframe, o qual nada mais é que uma tabela com linhas e colunas. Todos esses objetos fazem parte ecossistema R e é através da manipulação destes que tiramos o máximo proveito software.Enquanto representamos informações mundo real como diferentes classes R, um tipo especial de objeto é função, qual representa um procedimento preestabelecido que está disponível para o usuário. O R possui uma grande quantidade de funções, quais possibilitam que o usuário realize uma vasta gama de procedimentos. Por exemplo, os comandos básicos R, não incluindo demais pacotes, somam um total de 1258 funções. Com base neles e outros iremos importar dados, calcular médias, testar hipóteses, limpar dados, e muito mais.Cada função possui um próprio nome. Por exemplo, função sort() é um procedimento que ordena valores valores utilizados como input. Caso quiséssemos ordnear os valores 2, 1, 3, 0, basta inserir prompt o seguinte comando e apertar enter:O comando c(2, 1, 3, 0) combina os valores em um vetor (maiores detalhes sobre comando c serão dados em seção futura). Observe que função sort é utilizada com parênteses de início e fim. Esses parênteses servem para destacar entradas (inputs), isto é, informações enviadas para função produzir alguma coisa. Observe que cada entrada (ou opção) da função é separada por uma vírgula, tal como em MinhaFuncao(entrada01, entrada02, entrada03, ...). caso código anterior, note que usamos opção decreasing = TRUE. Essa é uma instrução específica para função sort ordenar de forma decrescente os elementos vetor de entrada. Veja diferença:O uso de funções está coração R e iremos dedicar grande parte livro elas. Por enquanto, essa breve introdução já serve o seu propósito. O principal é entender que uma função usa suas entradas para produzir algo de volta. Nos próximos capítulos iremos utilizar funções já existentes para mais diferentes finalidades: baixar dados da internet, ler arquivos, realizar testes estatísticos e muito mais. capítulo 8 iremos tratar deste assunto com maior profundidade, incluindo forma de escrevermos nossas próprias funções.","code":"\nsort(c(2, 1, 3, 0), decreasing = TRUE)R> [1] 3 2 1 0\nsort(c(2, 1, 3, 0), decreasing = FALSE)R> [1] 0 1 2 3"},{"path":"operacoes-basicas.html","id":"o-formato-brasileiro","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.3 O Formato Brasileiro","text":"Antes de começar explicar o uso R e RStudio, é importante ressaltar algumas regras de formatação de números e códigos para o caso brasileiro.Decimal: O decimal R é definido pelo ponto (.), tal como em 2.5 e não vírgula, como em 2,5. Esse é o padrão internacional, e diferença para notação brasileira gera muita confusão. Alguns softwares, por exemplo o Microsoft Excel, fazem essa conversão automaticamente momento da importação dos dados. Porém isso não ocorre na maioria dos casos. Como regra geral, utilize vírgulas apenas para separar os termos de entradas em uma função (veja exemplo de seção anterior com função sort). Em nenhuma situação deve-se utilizar vírgula como separador de casas decimais. Mesmo quando estiver exportando dados, sempre dê prioridade para o formato internacional, pois esse será compatível com grande maioria dos dados e facilitará o uso software.Caracteres latinos: Devido ao seu padrão internacional, o R apresenta problemas para entender caracteres latinos, tal como cedilha e acentos. Caso possa evitar, não utilize esses tipos de caracteres código para nomeação de variáveis ou arquivos. Nos objetos de classe texto (character), é possível utilizá-los desde que codificação objeto esteja correta (UTF-8 ou Latin1). Assim, recomenda-se que o código R seja escrito na língua inglesa. Isso automaticamente elimina o uso de caracteres latinos e facilita usabilidade código por outras pessoas que não entendam língua portuguesa. Destaca-se que essa foi escolha utilizada para o livro. Os nomes dos objetos nos exemplos estão em inglês, assim como também todos os comentários código. Formato das datas: Datas R são formatadas de acordo com norma ISO 8601, seguindo o padrão YYYY-MM-DD, onde YYYY é o ano em quatro números, MM é o mês e DD é o dia. Por exemplo, uma data em ISO 8601 é 2022-11-23. Brasil, datas são formatadas como DD/MM/YYYY. Reforçando regra, sempre dê preferência ao padrão internacional. Vale salientar que conversão entre um formato e outro é bastante fácil e será apresentada em capítulo futuro.momento de instalação R, diversas informações sobre o formato local seu computador são importadas seu sistema operacional. Para saber qual o formato que o R está configurado localmente, digite o seguinte comando prompt (canto esquerdo inferior RStudio) e aperte enter:saída de Sys.localeconv() mostra como o R interpreta pontos decimais e o separador de milhares, entre outras coisas. Como você pode ver resultado anterior, este livro foi compilado usando notação brasileira de moeda (BRL/R$), mas usa formatação internacional – o ponto (.) – para decimais.\nMuito cuidado ao modificar o formato que o R interpreta os diferentes\nsímbolos e notações. Como regra de bolso, caso precisar usar algum\nformato específico, faça-o isoladamente dentro contexto código.\nEvite mudanças permanentes pois nunca se sabe onde tais formatos estão\nsendo usados. Evite, assim, surpresas desagradáveis futuro.\n","code":"\n# get local format\nSys.localeconv()R>     decimal_point     thousands_sep          grouping \nR>               \".\"                \"\"                \"\" \nR>   int_curr_symbol   currency_symbol mon_decimal_point \nR>            \"BRL \"              \"R$\"               \",\" \nR> mon_thousands_sep      mon_grouping     positive_sign \nR>               \".\"        \"\\003\\003\"                \"\" \nR>     negative_sign   int_frac_digits       frac_digits \nR>               \"-\"               \"2\"               \"2\" \nR>     p_cs_precedes    p_sep_by_space     n_cs_precedes \nR>               \"1\"               \"1\"               \"1\" \nR>    n_sep_by_space       p_sign_posn       n_sign_posn \nR>               \"1\"               \"1\"               \"1\""},{"path":"operacoes-basicas.html","id":"tipos-de-arquivos","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.4 Tipos de Arquivos","text":"Assim como outros programas, o R possui um ecossistema de arquivos e cada extensão tem uma finalidade diferente. seguir apresenta-se uma descrição de diversas extensões de arquivos. Os itens da lista estão ordenados por ordem de importância e uso. Note que omitimos arquivos de figuras tal como .png, .jpg, .gif entre outros, pois estes não são exclusivos R.Arquivos com extensão .R: Representam arquivos tipo texto contendo diversas instruções para o R. Esses são os arquivos que conterão o código da pesquisa e onde passaremos maior parte tempo. Também pode ser chamado de um script ou rotina de pesquisa. Como sugestão, pode-se dividir toda uma pesquisa em etapas e, para cada, nomear script correspondente. Exemplos: 01-Get-Data.R, 02-Clean-data.R, 03_Estimate_Models.R.Arquivos com extensão .RData e .rds: armazenam dados nativos R. Esses arquivos servem para salvar objetos R em um arquivo disco rígido computador para, em sessão futura, serem novamente carregados. Por exemplo, podes guardar o resultado de uma pesquisa em uma tabela, qual é salva em um arquivo com extensão .RData ou .rds. Exemplos: Raw-Data.RData, Table-Results.rds.Arquivos com extensão .Rmd, .md e .Rnw: São arquivos relacionados tecnologia Rmarkdown. O uso desses arquivos permite criação de documentos onde texto e código são integrados.Arquivos com extensão .Rproj: Contém informações para edição de projetos RStudio. O sistema de projetos RStudio permite configuração customizada projeto e também facilita utilização de ferramentas de controle de código, tal como controle de versões. O seu uso, porém, não é essencial. Para aqueles com interesse em conhecer esta funcionalidade, sugiro leitura manual RStudio13. Uma maneira simples de entender os tipos de projetos disponíveis é, RStudio, clicar em “File”, “New project”, “New Folder” e assim deve aparecer uma tela com todos os tipos possíveis de projetos RStudio. Exemplo: -Dissertation-Project.Rproj.","code":""},{"path":"operacoes-basicas.html","id":"explicando-a-tela-do-rstudio","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.5 Explicando a Tela do RStudio","text":"Após instalar os dois programas, R e RStudio, Procure o ícone RStudio na área de trabalho ou via menu Iniciar. Note que instalação R inclui um programa de interface e isso muitas vezes gera confusão. Verifique que estás utilizado o software correto. janela resultante deve ser igual figura 2.1, apresentada seguir.\nFigura 2.1: tela RStudio\nObserve que o RStudio automaticamente detectou instalação R e inicializou sua tela lado esquerdo. Caso não visualizar uma tela parecida ou chegar em uma mensagem de erro indicando que o R não foi encontrado, repita os passos de instalação capítulo anterior (seção 1.4).Como um primeiro exercício, clique em File, New File e R Script. Após, um editor de texto deve aparecer lado esquerdo da tela RStudio. É nesse editor que iremos inserir os nossos comandos, os quais são executados de cima para baixo, na mesma direção em que normalmente o lemos. Note que essa direção de execução introduz uma dinâmica de recursividade: cada comando depende comando executado nas linhas anteriores. Após realizar os passos definidos anteriormente, tela resultante deve ser semelhante à apresentada na figura 2.2.\nFigura 2.2: Explicando tela RStudio\n\nUma sugestão importante aqui é modificar o esquema de cores \nRStudio para uma configuração de tela escura. Não é\nsomente uma questão estética mas sim de prevenção e melhoria de sua\nsaúde física. Possivelmente irás passar demasiado tempo na frente \ncomputador. Assim, vale pena modificar cores da interface para\naliviar seus olhos constante brilho da tela. Dessa forma, conseguirás\ntrabalhar por mais tempo, sem forçar sua visão. Podes configurar o\nesquema de cores RStudio indo na opção Tools, Global\nOptions e então em Appearance. Um esquema de cores escuras\nque pessoalmente gosto e sugiro é o Ambience.\nApós os passos anteriores, tela RStudio deve estar semelhante Figura 2.2, com os seguintes itens/painéis:Editor de scripts (Script editor): localizado lado esquerdo e acima da tela. Esse painel é utilizado para escrever código e é onde passaremos maior parte tempo.Console R (R prompt): localizado lado esquerdo e abaixo editor de scripts. Apresenta o prompt R, o qual também pode ser utilizado para executar comandos. principal função prompt é testar código e apresentar os resultados dos comandos inseridos editor de scripts.Área de trabalho (Environment): localizado lado direito e superior da tela. Mostra todos os objetos, incluindo variáveis e funções atualmente disponíveis para o usuário. Observe também presença painel History, o qual mostra o histórico dos comandos já executados.Pacotes (Panel Packages): mostra os pacotes instalados e carregados pelo R. Um pacote é nada mais que um módulo R, cada qual com sua finalidade específica. Observe presença de quatro abas: Files, para carregar e visualizar arquivos sistema; Plots, para visualizar figuras; Help, para acessar o sistema de ajuda R e Viewer, para mostrar resultados dinâmicos e interativos, tal como uma página da internet.Como um exercício introdutório, vamos inicializar duas variáveis. Dentro console R (lado esquerdo inferior), digite os seguintes comandos e aperte enter ao final de cada linha. O símbolo <- é nada mais que junção de < com -. O símbolo ' representa uma aspa simples e sua localização teclado Brasileiro é botão abaixo escape (esc), lado esquerdo superior teclado.Após execução, dois objetos devem aparecer painel Environment, um chamado x com o valor 1, e outro chamado y com o conjunto de caracteres 'text'. O histórico de comandos na aba History também foi atualizado com os comandos utilizados anteriormente.Agora, vamos mostrar na tela os valores de x. Para isso, digite o seguinte comando prompt e aperte enter novamente:função print é uma das principais funções para mostrarmos valores prompt R. O texto apresentado como [1] indica o índice primeiro número da linha. Para verificar isso, digite o seguinte comando, o qual irá mostrar vários números na tela: Nesse caso, utilizamos o símbolo : em 50:100 para criar uma sequência iniciando em 50 e terminando em 100. Observe que temos valores encapsulados por colchetes ([]) lado esquerda da tela. Esses representam os índices primeiro elemento apresentado na linha. Por exemplo, o décimo quinto elemento vetor criado é o valor 64.","code":"\n# set x and y\nx <- 1\ny <- 'my text'\n# print x\nprint(x)R> [1] 1\n# print vector from 50 to 100\nprint(50:100)R>  [1]  50  51  52  53  54  55  56  57  58  59  60  61  62  63\nR> [15]  64  65  66  67  68  69  70  71  72  73  74  75  76  77\nR> [29]  78  79  80  81  82  83  84  85  86  87  88  89  90  91\nR> [43]  92  93  94  95  96  97  98  99 100"},{"path":"operacoes-basicas.html","id":"pacotes-do-r","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.6 Pacotes do R","text":"Um dos grandes benefícios uso R é o seu acervo de pacotes. Esses representam um conjunto de procedimentos agrupados em uma coleção de funções e voltados para resolução de um problema qualquer. O R tem em sua essência uma filosofia de colaboração. Usuários disponibilizam os seus códigos para outras pessoas utilizarem. E, mais importante, todos os pacotes são gratuitos, assim como o R. Por exemplo, considere um caso em que está interessado em baixar dados da internet sobre o desemprego histórico Brasil. Para isso, basta procurar e instalar o pacote específico que realiza esse procedimento.Esses pacotes podem ser instalados de diferentes fontes, com principais sendo CRAN (Comprehensive R Archive Network) e Github. cada dia aumenta quantidade e diversidade de pacotes existentes para o R. O próprio autor deste livro possui diversos pacotes disponíveis CRAN, cada um para resolver algum problema diferente. Na grande maioria, são pacotes para importar e organizar dados financeiros.O CRAN é o repositório oficial R e é livre. Qualquer pessoa pode enviar um pacote e todo código enviado está disponível na internet. Existe, porém, um processo de avaliação que o código passa e certas normas rígidas devem ser respeitadas sobre o formato código, o manual usuário e forma de atualização pacote. Para quem tiver interesse, um tutorial claro e fácil de seguir é apresentado site http://r-pkgs..co.nz/intro.html. regras completas estão disponíveis site CRAN - https://cran.r-project.org/web/packages/policies.html. adequação código essas normas é responsabilidade desenvolvedor e gera um trabalho significativo, principalmente na primeira submissão.lista completa de pacotes disponíveis CRAN, juntamente com uma breve descrição, pode ser acessada link packages site R - https://cran.r-project.org/. Uma maneira prática de verificar existência de um pacote para um procedimento específico é carregar página anterior e procurar seu navegador de internet palavra-chave que define o seu procedimento. Caso existir o pacote com palavra-chave, procura acusará o encontro termo na descrição pacote.Outra fonte importante para o encontro de pacotes é o Task Views, em que são destacados os principais pacotes de acordo com área e o tipo de uso. Veja tela Task Views na Figura \\(\\ref{fig:TaskViews}\\).\nFigura 2.3: Tela Task Views\nAo contrário CRAN, o Github não possui restrição quanto ao código enviado e, devido isso, tende ser escolhido como ambiente de compartilhamento de código. responsabilidade de uso, porém, é próprio usuário. Na prática, é muito comum os desenvolvedores manterem uma versão em desenvolvimento Github e outra oficial CRAN. Quando versão em desenvolvimento atinge um estágio de maturidade, mesma é enviada ao CRAN.O mais interessante uso de pacotes é que estes podem ser acessados e instalados diretamente R via internet. Para saber qual é quantidade atual de pacotes CRAN, digite e execute os seguintes comandos prompt:Atualmente, 2022-11-23 10:51:29, existem 18877 pacotes disponíveis nos servidores CRAN.Também se pode verificar quantidade de pacotes localmente instalados com o comando installed.packages():Nesse caso, o computador em que o livro foi escrito possui 531 pacotes R instalados. Note que, apesar autor ser um experiente programador R, apenas uma pequena fração pacotes disponíveis CRAN está sendo usada! diversidade dos pacotes é gigantesca.","code":"\n# find current available packages\ndf_cran_pkgs <- available.packages()\n\n# get size of matrix\nn_cran_pkgs <- nrow(df_cran_pkgs)\n\n# print it\nprint(n_cran_pkgs)R> [1] 18877\n# get number of local (installed) packages\nn_local_pkgs <- nrow(installed.packages())\n\n# print it\nprint(n_local_pkgs)R> [1] 531"},{"path":"operacoes-basicas.html","id":"instalando-pacotes-do-cran","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.6.1 Instalando Pacotes do CRAN","text":"Para instalar um pacote, basta utilizar o comando install.packages. Como exemplo, vamos instalar um pacote que será utilizado nos capítulos futuros, o readr: Copie e cole este comando prompt e pronto! O R irá baixar os arquivos necessários e instalar o pacote readr e suas dependências. Após isto, funções relativas ao pacote estarão prontas para serem usadas após o carregamento módulo (detalhes seguir). Observe que definimos o nome pacote na instalação como se fosse texto, com o uso das aspas (\"). Caso o pacote instalado seja dependente de outros pacotes, o R automaticamente instala todos módulos faltantes. Assim, todos os requerimentos para o uso respectivo pacote já serão satisfeitos e tudo funcionará perfeitamente. É possível, porém, que um pacote tenha uma dependência externa. Como um exemplo, o pacote RndTexExams depende da existência de uma instalação LaTex. Geralmente essa é anunciada na sua descrição e um erro é sinalizado na execução programa quando o LaTex não é encontrado. Fique atento, portanto, esses casos.Aproveitando o tópico, sugiro que o leitor já instale todos os pacotes tidyverse com o seguinte código:O tidyverse é um conjunto de pacotes voltados data science e com uma sintaxe própria e consistente, voltada praticabilidade. Verás que, em uma instalação nova R, o tidyverse depende de uma grande quantidade de pacotes.","code":"\n# install pkg readr\ninstall.packages('readr')\n# install pkgs from tidyverse\ninstall.packages('tidyverse')"},{"path":"operacoes-basicas.html","id":"instalando-pacotes-do-github","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.6.2 Instalando Pacotes do Github","text":"Para instalar um pacote diretamente Github, é necessário instalar antes o pacote devtools, disponível CRAN: Após isto, utilize função devtools::install_github para instalar um pacote diretamente Github. Note que o símbolo :: indica que função install_github pertence ao pacote devtools. Com esta particular sintaxe, não precisamos carregar todo o pacote para utilizar apenas uma função.exemplo seguir instalamos versão em desenvolvimento pacote ggplot2, cuja versão oficial também está disponível CRAN: Observe que o nome usuário repositório também é incluído. caso anterior, o nome hadley pertence ao desenvolvedor ggplot2, Hadley Wickham. decorrer livro notará que esse nome aparecerá diversas vezes, dado que Hadley é um prolífico e competente desenvolvedor de diversos pacotes R e tidyverse.\nUm aviso aqui é importante. Os pacotes github não são\nmoderados. Qualquer pessoa pode enviar código para lá e o conteúdo não é\nchecado de forma independente. Nunca instale pacotes github\nsem conhecer os autores. Apesar de improvável – nunca aconteceu comigo\npor exemplo – é possível que esses possuam algum código malicioso.\n","code":"\n# install devtools\ninstall.packages('devtools')\n# install ggplot2 from github\ndevtools::install_github(\"hadley/ggplot2\")"},{"path":"operacoes-basicas.html","id":"carregando-pacotes","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.6.3 Carregando Pacotes","text":"Dentro de uma rotina de pesquisa, utilizamos função library para carregar um pacote na nossa sessão R. Ao fecharmos o RStudio ou então iniciar uma nova sessão R, os pacotes são descarregados. Vale salientar que alguns pacotes, tal como o base e o stats, são inicializados automaticamente cada nova sessão. grande maioria, porém, deve ser carregada início dos scripts. Veja o exemplo seguir:partir disso, todas funções pacote estarão disponíveis para o usuário. Note que não é necessário utilizar aspas (\") ao carregar o pacote. Caso utilize uma função específica pacote e não deseje carregar todo ele, pode fazê-lo através uso símbolo especial ::, conforme o exemplo seguir.Nesse caso, utilizamos função fortune próprio pacote fortunes, o qual mostra na tela uma frase possivelmente engraçada escolhida mailing list R. Nesse caso, selecionamos mensagem número 10. Se não tiver disponível o pacote, o R mostrará seguinte mensagem de erro:Para resolver, utilize o comando install.packages(\"fortunes\") para instalar o pacote seu computador. Execute o código fortunes::fortune(10) prompt para confirmar instalação. Toda vez que se deparar com essa mensagem de erro, deves instalar o pacote que está faltando.Outra maneira de carregar um pacote é através da função require. Essa tem um comportamento diferente da função library e deve ser utilizada dentro da definição de funções ou teste carregamento pacote. Caso o usuário crie uma função customizada que necessite de procedimentos de um pacote em particular, o mesmo deve carregar o pacote escopo da função. Por exemplo, veja o código seguir, em que criamos uma função dependente pacote quantmod:Nesse caso, função getSymbols faz parte pacote quantmod. Não se preocupe agora com estrutura utilizada para criar uma função R. Essa será explicada em capítulo futuro.\nUma precaucão que deve sempre ser tomada quando se carrega um pacote\né um possível conflito de funções. Por exemplo, existe\numa função chamada filter pacote dplyr e\ntambém pacote stats. Caso carregarmos ambos pacotes e\nchamarmos função filter escopo código, qual delas o\nR irá usar? Pois bem, preferência é sempre para o último\npacote carregado. Esse é um tipo de problema que pode gerar\nmuita confusão. Felizmente, note que o próprio R acusa um conflito de\nnome de funções carregamento pacote. Para testar, inicie uma nova\nsessão R e carregue o pacote dplyr. Verás que uma\nmensagem indica haver dois conflitos com o pacote stats e\nquatro com pacote o base.\n","code":"\n# load dplyr\nlibrary(dplyr)\n# call fct fortune() from pkg fortune\nfortunes::fortune(10)R> \nR> Overall, SAS is about 11 years behind R and S-Plus in\nR> statistical capabilities (last year it was about 10 years\nR> behind) in my estimation.\nR>    -- Frank Harrell (SAS User, 1969-1991)\nR>       R-help (September 2003)R> Error in library(\"fortune\") : there is no package called \"fortune\"\nmy_fct <- function(x){\n  require(quantmod)\n\n  df <- getSymbols(x, auto.assign = F)\n  return(df)\n}"},{"path":"operacoes-basicas.html","id":"atualizando-pacotes","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.6.4 Atualizando Pacotes","text":"Ao longo tempo, é natural que os pacotes disponibilizados CRAN sejam atualizados para acomodar novas funcionalidades ou se adaptar mudanças em suas dependências. Assim, é recomendável que os usuários atualizem os seus pacotes instalados para uma nova versão através da internet. Esse procedimento é bastante fácil. Uma maneira direta de atualizar pacotes é clicar botão update painel de pacotes canto direito inferior RStudio, conforme mostrado na figura 2.4.\nFigura 2.4: Atualizando pacotes R\natualização de pacotes através prompt também é possível. Para isso, basta utilizar o comando update.packages, conforme mostrado seguir. O comando update.packages() compara versão dos pacotes instalados em relação versão disponível CRAN. Caso tiver alguma diferença, nova versão é instalada. Após execução comando, todos os pacotes estarão atualizados com versão disponível nos servidores CRAN.\nVersionamento de pacotes é extremamente importante para manter \nreproducibilidade código. Apesar de ser raro de acontecer, é possível\nque atualização de um pacote R modifique, para os mesmos dados,\nresultados já obtidos anteriormente. Tenho uma experiência\nparticularmente memorável quando um artigo científico retornou da\nrevisão e, devido atualização de um dos pacotes, não consegui\nreproduzir os resultados apresentados artigo. final deu tudo\ncerto, mas o trauma fica.\n\nUma solução para este problema é congelar versões dos pacotes para\ncada projeto usando ferramenta packrat RStudio. Em\nresumo, o packrat faz cópias locais dos pacotes utilizados\nprojeto, os quais têm preferência aos pacotes sistema. Assim, se\num pacote atualizado sistema, mas não projeto, o código R vai\ncontinuar usando versão mais antiga e seu código sempre rodará nas\nmesmas condições.\n","code":"\nupdate.packages()"},{"path":"operacoes-basicas.html","id":"executando-códigos-em-um-script","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.7 Executando Códigos em um Script","text":"Agora, vamos juntar todos os códigos digitados anteriormente e colar na tela editor (lado esquerdo superior), assim como mostrado seguir:Após colar todos os comandos editor, salve o arquivo .R em alguma pasta pessoal. Esse arquivo, o qual momento não faz nada de especial, registrou os passos de um algoritmo simples que cria dois objetos e mostra os seus valores. Futuramente esse irá ter mais forma, com importação de dados, manipulação e modelagem dos mesmos e saída de tabelas e figuras.RStudio existem alguns atalhos predefinidos para executar códigos que economizam bastante tempo. Para executar um script inteiro, basta apertar control + shift + s. Esse é o comando source. Com o RStudio aberto, sugiro testar essa combinação de teclas e verificar como o código digitado anteriormente é executado, mostrando os valores prompt R. Visualmente, o resultado deve ser próximo ao apresentado na figura 2.5.\nFigura 2.5: Exemplo de Rotina R\nOutro comando muito útil é execução por linha. Nesse caso não é executado todo o arquivo, mas somente linha em que o cursor mouse se encontra. Para isto, basta apertar control+enter. Esse atalho é bastante útil desenvolvimento de rotinas pois permite que cada linha seja testada antes de executar o programa inteiro. Como um exemplo de uso, aponte o cursor para linha print(x) e pressione control + enter. Verás que o valor de x é mostrado na tela prompt. seguir destaco esses e outros atalhos RStudio, os quais também são muito úteis.control+shift+s executa o arquivo atual RStudio, sem mostrar comandos prompt (sem eco – somente saída);control+shift+enter: executa o arquivo atual, mostrando comandos na tela (com eco – código e saída);control+enter: executa linha selecionada, mostrando comandos na tela;control+shift+b: executa os códigos início arquivo até linha atual onde o cursor se encontra;control+shift+e: executa os códigos da linha onde o cursor se encontra até o final arquivo.Sugere-se que esses atalhos sejam memorizados e utilizados. Isso facilita bastante o uso programa. Para aqueles que gostam de utilizar o mouse, uma maneira alternativa para rodar o código script é apertar o botão source, localizado canto direito superior editor de rotinas. Isto é equivalente ao atalho control+shift+s.Porém, mundo real de programação, poucos são os casos em que uma análise de dados é realizada por um script apenas. Como uma forma de organizar o código, pode-se dividir o trabalho em N scripts diferentes, onde um deles é o “mestre”, responsável por rodar os demais.Neste caso, para executar os scripts em sequência, basta chamá-los script mestre com o comando source, como código seguir: Nesse caso, o código anterior é equivalente abrirmos e executarmos (control + shift + s) cada um dos scripts sequencialmente.Como podemos ver, existem diversas maneiras de executar uma rotina de pesquisa. Na prática, porém, iras centralizar o uso em dois comandos apenas: control+shift+s para rodar o script inteiro e control+enter para rodar por linha.","code":"\n# set objects\nx <- 1\ny <- 'my text'\n\n# print it\nprint(x)\nprint(1:50)\n# Import all data\nsource('01-import-data.R')\n\n# Clean up\nsource('02-clean-data.R')\n\n# Build tables\nsource('03-build-table.R')"},{"path":"operacoes-basicas.html","id":"testando-código","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.8 Testando Código","text":"O desenvolvimento de códigos em R segue um conjunto de etapas. Primeiro você escreverá uma nova linha de comando em uma rotina. Essa linha será testada com o atalho control + enter, verificando-se ocorrência de erros e saídas na tela. Caso não houver erro e o resultado igual ao esperado, parte-se para próxima linha de código.Um ciclo de trabalho fica claro, escrita código da linha atual é seguida pela execução, seguido da verificação de resultados, modificação caso necessário e assim por diante. Esse é um processo normal e esperado. Dado que uma rotina é lida e executada de cima para baixo, você precisa ter certeza de que cada linha de código está corretamente especificada antes de passar para próxima.Quando você está tentando encontrar um erro em um script preexistente, o R oferece algumas ferramentas para controlar e avaliar sua execução. Isso é especialmente útil quando você possui um código longo e complicado. ferramenta de teste mais simples e fácil de utilizar que o RStudio oferece é o ponto de interrupção código. RStudio, você pode clicar lado esquerdo editor e aparecerá um círculo vermelho, como na Figura 2.6.\nFigura 2.6: Exemplo de debug\nO círculo vermelho indica um ponto de interrupção código que forçará o R pausar execução nessa linha. Quando execução atinge o ponto de interrupção, o prompt mudará para browser[1]> e você poderá verificar o conteúdo dos objetos. console, você tem opção de continuar execução para o próximo ponto de interrupção ou interrompê-la. O mesmo resultado pode ser alcançado usando função browser. Dê uma olhada:O resultado prático código anterior é o mesmo que utilizar o círculo vermelho RStudio, figura 2.6. Porém, o uso browser permite mais controle sobre onde execução deve ser pausada. Como um teste, copie e cole o código anterior RStudio, salve em um novo script e execute com Control + Shift + S. Para sair ambiente de depuramento (debug), aperte enter prompt RStudio. ","code":"\n# set x\nx <- 1\n\n# set y\nbrowser()\ny <- 'My humble text'\n\n# print contents of x\nprint(x)"},{"path":"operacoes-basicas.html","id":"criando-objetos-simples","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.9 Criando Objetos Simples","text":"Um dos comandos mais básicos R é definição de objetos. Como foi mostrado nas seções anteriores, pode-se definir um objeto com o uso comando <-, o qual, para o português, é traduzido para o verbo defina (assign em inglês). Considere o seguinte código:Lê-se esse código como x é definido como 123. direção da seta define onde o valor será armazenado. Por exemplo, utilizar 123 -> my_x também funcionaria, apesar de ser uma sintaxe pouco utilizada ou recomendada. Note que também é possível escrever diversos comandos na mesma linha com o uso da semi-vírgula (;).\nO uso símbolo <- para definição de objetos é\nespecífico R. Na época da concepção da linguagem S, de onde\no R foi baseado, existiam teclados com uma tecla específica que definia\ndiretamente o símbolo de seta. Teclados contemporâneos, porém, não\npossuem mais esta configuração. Uma alternativa é utilizar o atalho para\no símbolo, o qual, Windows, é definido por alt + -.\nÉ possível também usar o símbolo = para definir objetos assim como o <-. Saliento que esta é prática comum em outras linguagens de programação. Porém, ecosistema R, utilização = com esse fim específico não é recomendada. O símbolo de igualdade tem o seu uso especial e resguardado na definição de argumentos de uma função tal como sort(x = 1:10, decreasing = TRUE).O nome dos objetos é importante R. Tirando alguns casos específicos, o usuário pode nomear os objetos como quiser. Essa liberdade, porém, pode ser um problema. É desejável sempre dar nomes curtos que façam sentido ao conteúdo objeto e que sejam simples de entender. Isso facilita o entendimento código por outros usuários e faz parte das normas sugeridas para estruturação código. Observe que todos os objetos criados nesse livro possuem nomenclatura em inglês e formatação específica, onde espaços entre substantivos e verbos são substituídos por traço baixo, tal como em my_x e my_csv_file. Aqui, o mais importante é consistência formato. Sempre mantenha o mesmo padrão em todo o código. capítulo 13 vamos ir mais fundo nesta questão de estrutura de código.O R executa o código procurando objetos e funções disponíveis seu ambiente de trabalho (enviromnent). Se tentarmos acessar um objeto que não existe, o R irá retornar uma mensagem de erro:Isso ocorre pois o objeto z não existe na sessão atual R. Se criarmos uma variável z como z <- 123 e repetirmos o comando print(z), não teremos mesma mensagem de erro.Um ponto importante aqui é definição de objetos de classes diferentes com o uso de símbolos específicos. O uso de aspas duplas (\" \") ou simples (' ') define objetos da classe texto enquanto números são definidos pelo próprio valor. Conforme será mostrado, cada objeto R tem uma classe e cada classe tem um comportamento diferente. Portanto, objetos criados com o uso de aspas pertencem à classe character. Podemos confirmar isso via código:saídas anteriores mostram que variável x é tipo numérico, enquanto variável y é tipo texto (character). Ambas fazem parte das classes básicas de objetos R. Por enquanto, este é o mínimo que deves saber para avançar nos próximos capítulos. Iremos estudar este assunto mais profundamente capítulo 7. ","code":"\n# set x\nmy_x <- 123\n\n# set x, y and z in one line\nmy_x <- 1 ; my_y <- 2; my_z <- 3\nprint(z)R> Error in print(z): object 'z' not found\n# set vars\nx <- 1\ny <- '1'\n\n# display classes\nclass(x)R> [1] \"numeric\"\nclass(y)R> [1] \"character\""},{"path":"operacoes-basicas.html","id":"criando-vetores","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.10 Criando Vetores","text":"Nos exemplos anteriores criamos objetos simples tal como x <- 1 e x <- 'abc'. Enquanto isso é suficiente para demonstrar os comandos básicos R, na prática tais comandos são bastante limitados, uma vez que um problema real de análise de dados certamente irá ter um maior volume de informações mundo real.Um dos procedimentos mais utilizados R é criação de vetores atômicos. Esses são objetos que guardam uma série de elementos. Todos os elementos de um vetor atômico devem possuir mesma classe, o que justifica sua propriedade atômica. Um exemplo seria representar R uma série de preços diários de uma ação. Tal série possui vários valores numéricos que formam um vetor da classe numérica.Vetores atômicos são criados R através uso comando c, o qual é oriundo verbo em inglês combine. Por exemplo, caso eu quisesse combinar os valores 1, 2 e 3 em um objeto/vetor, eu poderia fazê-lo através seguinte comando: Esse comando funciona da mesma maneira para qualquer número de elementos. Caso necessário, poderíamos criar um vetor com mais elementos simplesmente adicionando valores após o 3, tal como em x <- c(1, 2, 3, 4, 5).O uso comando c não é exclusivo para vetores numéricos. Por exemplo, poderíamos criar um vetor de outra classe de dados, tal como character:única restrição uso comando c é que todos os itens vetor tenham mesma classe. Se inserirmos dados de classes diferentes, o R irá tentar transformar os itens para mesma classe seguindo uma lógica própria, onde classe mais complexa sempre tem preferência. Caso ele não consiga transformar todos os elementos para uma classe só, uma mensagem de erro será retornada. Observe próximo exemplo como os valores numéricos primeiro e segundo elemento de x são transformados para classe de caracteres.Outra utilização comando c é combinação de vetores. De fato, isto é exatamente o que fizemos ao executar o código c(1, 2, 3). Neste caso, cada vetor possuía um elemento. Podemos realizar o mesmo com vetores maiores. Veja seguir:Portanto, o comando c possui duas funções principais: criar e combinar vetores.","code":"\n# set vector\nx <- c(1, 2, 3)\n\n# print it\nprint(x)R> [1] 1 2 3\ny <- c('text 1', 'text 2', 'text 3', 'text 4')\nprint(y)R> [1] \"text 1\" \"text 2\" \"text 3\" \"text 4\"\n# numeric class\nx <- c(1, 2)\nclass(x)R> [1] \"numeric\"\n# character class\nx <- c(1, 2, '3')\nclass(x)R> [1] \"character\"\n# set x and y\nx <- c(1, 2, 3)\ny <- c(4, 5)\n\n# print concatenation between x and y\nprint(c(x, y))R> [1] 1 2 3 4 5"},{"path":"operacoes-basicas.html","id":"conhecendo-os-objetos-criados","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.11 Conhecendo os Objetos Criados","text":"Após execução de diversos comandos editor ou prompt, é desejável saber quais são os objetos criados pelo código. É possível descobrir essa informação simplesmente olhando para o lado direito superior RStudio, na aba da área de trabalho. Porém, existe um comando que sinaliza mesma informação prompt. Com o fim de saber quais são variáveis atualmente disponíveis na memória R, pode-se utilizar o comando ls. Observe o exemplo seguir: Os objetos x, y e z foram criados e estavam disponíveis ambiente de trabalho atual, juntamente com outros objetos. Para descobrir os valores dos mesmos, basta digitar os nomes dos objetos e apertar enter prompt:Destaca-se que digitar o nome objeto na tela tem o mesmo resultado que utilizar função print. De fato, ao executar o nome de uma variável, internamente o R passa esse objeto para função print.R, conforme já mostrado, todos os objetos pertencem alguma classe. Para descobrir classe de um objeto, basta utilizar função class. Observe exemplo seguir que x é um objeto da classe numérica e y é um objeto da classe de texto (character). Outra maneira de conhecer melhor um objeto é verificar sua representação em texto. Todo objeto R possui uma representação textual e verificação desta é realizada através da função str: Essa função é particularmente útil quando se está tentando entender os detalhes de um objeto mais complexo, tal como uma tabela. utilidade da representação textual é que nela aparece o tamanho objeto e suas classes internas. Nesse caso, o objeto x é da classe integer e possui dez elementos.","code":"\n# set vars\nx <- 1\ny <- 2\nz <- 3\n\n# show current objects\nls()R> [1] \"x\" \"y\" \"z\"\nxR> [1] 1\nyR> [1] 2\nzR> [1] 3\n# set vars\nx <- 1\ny <- 'a'\n\n# check classes\nclass(x)R> [1] \"numeric\"\nclass(y)R> [1] \"character\"\n# print textual representation of a vector\nx <- 1:10\nprint(str(x))R>  int [1:10] 1 2 3 4 5 6 7 8 9 10\nR> NULL"},{"path":"operacoes-basicas.html","id":"mostrando-e-formatando-informações-na-tela","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.12 Mostrando e Formatando Informações na Tela","text":"Como já vimos, é possível mostrar o valor de uma variável na tela de duas formas, digitando o nome dela prompt ou então utilizando função print. Explicando melhor, função print é voltada para apresentação de objetos e pode ser customizada para qualquer tipo. Por exemplo, caso tivéssemos um objeto de classe chamada MyTable que representasse um objeto tabular, poderíamos criar uma função chamada print.MyTable que irá mostrar uma tabela na tela com um formato especial tal como número de linhas, nomes das colunas, etc. função print, portanto, pode ser customizada para cada classe de objeto.Porém, existem outras funções específicas para apresentar texto (e não objetos) prompt. principal delas é message. Essa toma como input um texto, processa-o para símbolos específicos e o apresenta na tela. Essa função é muito mais poderosa e personalizável que print. Por exemplo, caso quiséssemos mostrar na tela o texto 'O valor de x é igual 2', poderíamos fazê-lo da seguinte forma:Função message também funciona para vetores:customização da saída da tela é possível através de comandos específicos. Por exemplo, se quiséssemos quebrar linha da tela, poderíamos fazê-lo através uso caractere reservado \\n:Observe que o uso print não resultaria mesmo efeito, uma vez que esse comando apresenta o texto como ele é, sem processar para efeitos específicos:Outro exemplo uso de comandos específicos para texto é adicionar um espaçamento tab texto apresentado com o símbolo \\t. Veja seguir:Vale destacar que, na grande maioria dos casos de pesquisa, será necessário apenas o uso de \\n para formatar textos de saída. Outras maneiras de manipular saída de texto prompt com base em símbolos específicos são encontradas manual oficial R.Parte processo de apresentação de texto na tela é customização mesmo. Para isto, existem duas funções muito úteis: paste e format. função paste cola uma série de caracteres juntos. É uma função muito útil, qual será utilizada intensamente para o resto dos exemplos deste livro. Observe o código seguir:O resultado anterior não está muito longe que fizemos exemplo com função print. Note, porém, que função paste adiciona um espaço entre cada texto. Caso não quiséssemos esse espaço, poderíamos usar função paste0: \nUma alternativa função message é cat\n(concatenate print). Não é incomum encontrarmos códigos\nonde mensagens para o usuário são transmitidas via cat e\nnão message. Como regra, dê preferência \nmessage pois esta é mais fácil de controlar. Por exemplo,\ncaso o usuário quiser silenciar uma função, omitindo todas saídas da\ntela, bastaria usar o comando suppressMessages.\nOutra possibilidade muito útil uso paste é modificar o texto entre junção dos itens serem colados. Por exemplo, caso quiséssemos adicionar uma vírgula e espaço (,) entre cada item, poderíamos fazer isso através uso argumento sep, como seguir:Caso tivéssemos um vetor atômico com os elementos da frase em um objeto apenas, poderíamos atingir o mesmo resultado utilizando paste o argumento collapse:Prosseguindo, o comando format é utilizado para formatar números e datas. É especialmente útil quando formos montar tabelas e buscarmos apresentar os números de uma maneira visualmente atraente. Por definição, o R apresenta uma série de dígitos após vírgula:Caso quiséssemos apenas dois dígitos aparecendo na tela, utilizaríamos o seguinte código:Tal como, também é possível mudar o símbolo de decimal:Tal flexibilidade é muito útil quando devemos reportar resultados respeitando algum formato local tal como o Brasileiro.Uma alternativa recente e muito interessante para o comando base::paste é stringr::str_c e stringr::str_glue. Enquanto primeira é quase idêntica paste0, segunda tem uma maneira pecular de juntar objetos. Veja um exemplo seguir:Como vemos, temos três alternativas para o mesmo resultado final. Note que str_glue usa de chaves para definir variáveis dentro próprio texto. Esse é um formato muito interessante e prático.","code":"\n# set var\nx <- 2\n\n# print with message()\nmessage('The value of x is', x)R> The value of x is2\n# set vec\nx <- 2:5\n\n# print with message()\nmessage('The values in x are: ', x)R> The values in x are: 2345\n# set char\nmy_text <- 'First line,\\nSecond Line,\\nThird Line'\n\n# print with new lines\nmessage(my_text)R> First line,\nR> Second Line,\nR> Third Line\nprint(my_text)R> [1] \"First line,\\nSecond Line,\\nThird Line\"\n# set char with \\t\nmy_text_1 <- 'A and B'\nmy_text_2 <- '\\tA and B'\nmy_text_3 <- '\\t\\tA and B'\n\n# print with message()\nmessage(my_text_1)R> A and B\nmessage(my_text_2)R>  A and B\nmessage(my_text_3)R>      A and B\n# set chars\nmy_text_1 <- 'I am a text'\nmy_text_2 <- 'very beautiful'\nmy_text_3 <- 'and informative.'\n\n# using paste and message\nmessage(paste(my_text_1, my_text_2, my_text_3))R> I am a text very beautiful and informative.\n# using paste0\nmessage(paste0(my_text_1, my_text_2, my_text_3))R> I am a textvery beautifuland informative.\n# using custom separator\nmessage(paste(my_text_1, my_text_2, my_text_3, sep = ', '))R> I am a text, very beautiful, and informative.\n# using paste with collapse argument\nmy_text <-c('Eu sou um texto', 'muito bonito', 'e charmoso.')\nmessage(paste(my_text, collapse = ', '))R> Eu sou um texto, muito bonito, e charmoso.\n# message without formatting\nmessage(1/3)R> 0.333333333333333\n# message with format and two digits\nmessage(format(1/3, digits=2))R> 0.33\n# message with format and two digits\nmessage(format(1/3, decimal.mark = ','))R> 0,3333333\nlibrary(stringr)\n\n# define some vars\nmy_name <- 'Pedro'\nmy_age <- 23\n\n# using base::paste0\nmy_str_1 <- paste0('My name is ', my_name, ' and my age is ', my_age)\n\n# using stringr::str_c\nmy_str_2 <- str_c('My name is ', my_name, ' and my age is ', my_age)\n\n# using stringr::str_glue\nmy_str_3 <- str_glue('My name is {my_name} and my age is {my_age}')\n\nidentical(my_str_1, my_str_2)R> [1] TRUE\nidentical(my_str_1, my_str_3)R> [1] FALSE\nidentical(my_str_2, my_str_3)R> [1] FALSE"},{"path":"operacoes-basicas.html","id":"conhecendo-o-tamanho-dos-objetos","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.13 Conhecendo o Tamanho dos Objetos","text":"Na prática de programação com o R, é muito importante saber o tamanho das variáveis que estão sendo utilizadas. Isso serve não somente para auxiliar o usuário na verificação de possíveis erros código, mas também para saber o tamanho necessário em certos procedimentos de iteração tal como loops, os quais serão tratados em capítulo futuro.R, o tamanho objeto pode ser verificado com o uso de quatro principais funções: length, nrow, ncol e dim. função length é destinada objetos com uma única dimensão, tal como vetores atômicos:Para objetos com mais de uma dimensão, por exemplo matrizes e dataframes, utilizam-se funções nrow, ncol e dim para descobrir o número de linhas (primeira dimensão) e o número de colunas (segunda dimensão). Veja diferença seguir.Já função dim mostra dimensão objeto, resultando em um vetor numérico como saída. Essa deve ser utilizada quando o objeto tiver mais de duas dimensões. Na prática, esses casos são raros. Um exemplo para variável x é dado seguir:Para o caso de objetos com mais de duas dimensões, podemos utilizar função array para criá-los e dim para descobrir o seu tamanho:Uma observação importante aqui é que funções length, nrow, ncol e dim não servem para descobrir o número de letras em um texto. Esse é um erro bastante comum. Por exemplo, caso tivéssemos um objeto tipo texto e usássemos função length, o resultado seria o seguinte:Isso ocorre pois função length retorna o número de elementos. Nesse caso, my_char possui apenas um elemento. Para descobrir o número de caracteres objeto, utilizamos função nchar, conforme seguir:Reforçando, cada objeto R tem suas propriedades e funções específicas para manipulação.","code":"\n# set x\nx <- c(2,3,3,4,2,1)\n\n# get length x\nn <- length(x)\n\n# display message\nmessage(paste('The length of x is', n))R> The length of x is 6\n# set matrix and print it\nx <- matrix(1:20, nrow = 4, ncol = 5)\nprint(x)R>      [,1] [,2] [,3] [,4] [,5]\nR> [1,]    1    5    9   13   17\nR> [2,]    2    6   10   14   18\nR> [3,]    3    7   11   15   19\nR> [4,]    4    8   12   16   20\n# find number of rows, columns and elements\nmy_nrow <- nrow(x)\nmy_ncol <- ncol(x)\nmy_length <- length(x)\n\n# print message\nmessage(paste('\\nThe number of lines in x is ', my_nrow))R> \nR> The number of lines in x is  4\nmessage(paste('\\nThe number of columns in x is ', my_ncol))R> \nR> The number of columns in x is  5\nmessage(paste('\\nThe number of elements in x is ', my_length))R> \nR> The number of elements in x is  20\nprint(dim(x))R> [1] 4 5\n# set array with dimension\nmy_array <- array(1:9, dim = c(3,3,3))\n\n# print it\nprint(my_array)R> , , 1\nR> \nR>      [,1] [,2] [,3]\nR> [1,]    1    4    7\nR> [2,]    2    5    8\nR> [3,]    3    6    9\nR> \nR> , , 2\nR> \nR>      [,1] [,2] [,3]\nR> [1,]    1    4    7\nR> [2,]    2    5    8\nR> [3,]    3    6    9\nR> \nR> , , 3\nR> \nR>      [,1] [,2] [,3]\nR> [1,]    1    4    7\nR> [2,]    2    5    8\nR> [3,]    3    6    9\n# print its dimension\nprint(dim(my_array))R> [1] 3 3 3\n# set char object\nmy_char <- 'abcde'\n\n# find its length (and NOT number of characters)\nprint(length(my_char))R> [1] 1\n# using nchar for number of characters\nprint(nchar(my_char))R> [1] 5"},{"path":"operacoes-basicas.html","id":"selecionando-elementos-de-um-vetor-atômico","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.14 Selecionando Elementos de um Vetor Atômico","text":"Após criação de um vetor atômico de qualquer classe, é possível que se esteja interessado em apenas um ou alguns elementos desse mesmo vetor. Por exemplo, caso estivéssemos buscando atualizar o valor de um portfólio de investimento, o nosso interesse dentro de um vetor contendo preços de uma ação é somente para o preço mais recente. Todos os demais preços não seriam relevantes para nossa análise e, portanto, poderiam ser ignorados.Esse processo de seleção de pedaços de um vetor atômico é chamado de indexação e é executado através uso de colchetes []. Observe o exemplo de código seguir:Se quiséssemos apenas o terceiro elemento de my_x, utilizaríamos o operador de colchete da seguinte forma:Também podemos utilizar o comando length, apresentado anteriormente, para acessar o último elemento vetor:caso de estarmos interessado apenas último e penúltimo valor de my_x utilizaríamos o operador de sequência (:):Uma propriedade única da linguagem R é que, caso acessado uma posição que não existe vetor, o programa retorna o valor NA (available). Veja seguir, onde tenta-se obter o quarto valor de um vetor com apenas três elementos.É importante conhecer esse comportamento R, pois o não tratamento desses erros pode gerar problemas difíceis de identificar em um código mais complexo. Em outras linguagens de programação, tentativa de acesso elementos não existentes geralmente retorna um erro e cancela execução resto código. caso R, dado que o acesso elementos inexistentes não gera erro, é possível que isso gere um problema em outras partes script.\nGeralmente, ocorrência de NAs (Available)\nsugere existência de problema código. Saiba que NA\nindicam falta de dados e são contagiosos: tudo que interagir com\nobjeto tipo NA, seja uma soma ou multiplicação, irá\ntambém virar NA. O usuário deve prestar atenção\ntoda vez que surgirem valores NA de forma inesperada nos\nobjetos criados. Uma inspeção nos índices dos vetores pode ser\nnecessária.\nO uso de indexadores é muito útil quando se está procurando por itens de um vetor que satisfaçam alguma condição. Por exemplo, caso quiséssemos todos os valores de my_x que são maiores que 3, utilizaríamos o seguinte comando:É possível também indexar por mais de uma condição através dos operadores de lógica & (e) e | (ou). Por exemplo, caso quiséssemos os valores de my_x maiores que 2 e menores que 4, usaríamos o seguinte comando:Da mesma forma, havendo interesse nos itens que são menores que 3 ou maiores que 6, teríamos:indexação lógica também funciona com interação de diferentes variáveis, isto é, podemos utilizar uma condição lógica em uma variável para selecionar itens em outra:Olhando mais de perto o processo de indexação, vale salientar que, quando utilizamos uma condição de indexação dos dados, esta-se criando uma variável tipo lógica. Essa toma apenas dois valores: TRUE (verdadeiro) ou FALSE (falso). É fácil perceber isso quando criamos o teste lógico em um objeto e o mostramos na tela:demais propriedades e operações com vetores lógicos serão explicadas em capítulo futuro.","code":"\n# set my_x\nmy_x <- c(1, 5, 4, 3, 2, 7, 3.5, 4.3)\n# get third element of my_x\nelem_x <- my_x[3]\nprint(elem_x)R> [1] 4\n# get last element of my_x\nlast_elem <- my_x[length(my_x)]\n\n# print it\nprint(last_elem)R> [1] 4.3\n# get last and second last elements\npiece_x_1 <- my_x[ (length(my_x)-1):length(my_x) ]\n\n# print it\nprint(piece_x_1)R> [1] 3.5 4.3\n# set vec\nmy_vec <- c(1,2,3)\n\n# find fourth element (NA returned!)\nprint(my_vec[4])R> [1] NA\n# get all values higher than 3\npiece_x_2 <- my_x[my_x>3]\n\n# print it\nprint(piece_x_2)R> [1] 5.0 4.0 7.0 3.5 4.3\n# get all values higher than 2 AND lower than 4\npiece_x_3 <- my_x[ (my_x>2) & (my_x<4) ]\n\n# print it\nprint(piece_x_3)R> [1] 3.0 3.5\n# get all values lower than 3 OR higher than 6\npiece_x_4 <- my_x[ (my_x<3)|(my_x>6) ]\n\n# print it\nprint(piece_x_4)R> [1] 1 2 7\n# set my_x and my_y\nmy_x <- c(1, 4, 6, 8, 12)\nmy_y <- c(-2, -3, 4, 10, 14)\n\n# find elements in my_x where my_y are positive\nmy_piece_x <- my_x[ my_y > 0 ]\n\n# print it\nprint(my_piece_x)R> [1]  6  8 12\n# set logical object\nmy_logical <- my_y > 0\n\n# print it\nprint(my_logical)R> [1] FALSE FALSE  TRUE  TRUE  TRUE\n# show its class\nclass(my_logical)R> [1] \"logical\""},{"path":"operacoes-basicas.html","id":"limpando-a-memória","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.15 Limpando a Memória","text":"Após criação de diversas variáveis, o ambiente de trabalho R pode ficar cheio de conteúdo já utilizado e dispensável. Nesse caso, é desejável limpar memória programa. Geralmente isso é realizado começo de um script, de forma que toda vez que o script executado, memória estará totalmente limpa antes de qualquer cálculo. Além de desocupar memória computador, isso ajuda evitar possíveis erros código. Na grande maioria dos casos, porém, limpeza ambiente de trabalho deve ser realizada apenas uma vez.Por exemplo, dada uma variável x, podemos excluí-la da memória com o comando rm, conforme mostrado seguir: Observe que o objeto x não estará mais mais disponível após o uso comando rm('x').Entretanto, em situações práticas é desejável limpar toda memória utilizada por todos os objetos disponíveis R. Pode-se atingir esse objetivo com o seguinte código:O termo list é um argumento da função rm, o qual define quais objetos serão eliminados. Já o comando ls() mostra todas os objetos disponíveis atualmente. Portanto, ao encadear ambos os comandos, limpamos da memória todos os objetos disponíveis para o R. Como comentado, uma boa política de programação é sempre iniciar o script limpando memória R. .\nlimpeza da memória em scripts é uma estratégia\ncontroversa. Alguns autores argumentam que é melhor não limpar memória\npois isso pode apagar resultados importantes. Na minha opinião, acho\nfundamental limpar memória, desde que todos resultados sejam\nreproduzíveis. Ao iniciar um código sempre mesmo estado, isto é,\nnenhuma variável criada, fica mais fácil de entender e capturar\npossíveis bugs.\n","code":"\n# set x and y\nx <- 1\ny <- 2\n\n# print all existing objects\nls()\n\n# remove x from memory\nrm('x')\n\n# print objects again\nls()\n# clean up workspace (all existing objects)\nrm(list = ls())"},{"path":"operacoes-basicas.html","id":"mostrando-e-mudando-o-diretório-de-trabalho","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.16 Mostrando e Mudando o Diretório de Trabalho","text":"Assim como outros softwares, o R sempre trabalha em algum diretório. É com base nesse diretório que o R procura arquivos para importar dados. É nesse mesmo diretório que o R salva arquivos, caso não definirmos um endereço computador explicitamente. Essa saída pode ser um arquivo de uma figura, um arquivo de texto ou uma planilha eletrônica. Como boa prática de criação e organização de scripts, deve-se sempre mudar o diretório de trabalho para onde o arquivo script está localizado.Em sua inicialização, o R possui como diretório default pasta de documentos usuário cujo atalho é o tilda ('~').Para mostrar o diretório atual de trabalho, basta utilizar função getwd: O resultado código anterior mostra pasta onde este livro foi escrito. Esse é o diretório onde os arquivos livro foram compilados dentro ambiente Linux.mudança de diretório de trabalho é realizada através comando setwd. Por exemplo, caso quiséssemos mudar o nosso diretório de trabalho para C:/Minha pesquisa/, basta digitar prompt:Enquanto para casos simples, como o anterior, lembrar o nome diretório é fácil, em casos práticos o diretório de trabalho pode ser em um lugar mais profundo da raiz de diretórios sistema de arquivos. Nessa situação, uma estratégia eficiente para descobrir pasta de trabalho é utilizar um explorador de arquivos, tal como o Explorer Windows. Abra esse aplicativo e vá até o local onde quer trabalhar com o seu script. Após isso, coloque o cursor na barra de endereço e selecione todo o endereço. Aperte control+c para copiar o endereço para área de transferência. Volte para o seu código e cole o mesmo código. Atenção nesta etapa, o Windows utiliza barra invertida para definir endereços computador, enquanto o R utiliza barra normal. Caso tente utilizar barra invertida, um erro será mostrado na tela. Veja o exemplo seguir.O erro terá seguinte mensagem:justificativa para o erro é que barra invertida \\ é um caractere reservado R e não pode ser utilizado isoladamente. Caso precises, podes definí-lo objeto de texto com dupla barra, tal como em \\\\. Veja exemplo seguir, onde dupla barra é substituída por uma barra única:solução problema é simples. Após copiar o endereço, modifique todas barras para barra normal, assim como código seguir:É possível também utilizar barras invertidas duplas \\\\ na definição de diretórios, porém não se recomenda essa formatação, pois não é compatível com outros sistemas operacionais.Outro ponto importante aqui é o uso de endereços relativos. Por exemplo, caso esteja trabalhando em um diretório que contém um subdiretório chamado Data, podes entrar nele com o seguinte código:Outra possibilidade pouco conhecida uso de setwd é que é possível entrar em níveis inferiores sistema de diretórios com .., tal como em:Portanto, caso estejas trabalhando diretório C:/Research/ e executar o comando setwd('..'), o diretório atual de trabalho viraria C:/, um nível inferior C:/Research/.Uma maneira mais moderna e pouco conhecida de definir o diretório de trabalho é usar funções internas RStudio. Este é um conjunto de funções que só funcionam dentro RStudio e fornecem diversas informações sobre o arquivo sendo editado. Para descobrir o caminho arquivo atual que está sendo editado RStudio e configurar o diretório de trabalho para lá, você pode escrever:Dessa forma, o script mudará o diretório para sua própria localização. Apesar de não ser um código exatamente elegante, ele é bastante funcional. Caso copie o arquivo para outro diretório, o valor de my_path muda para o novo diretório. Esteja ciente, entanto, de que esse truque só funciona editor de rotinas RStudio e dentro de um arquivo salvo. O código não funcionará partir prompt. \nOutro truque bastante útil para definir diretórios de trabalho R é\nusar o símbolo ~. Esse define pasta\n‘Documentos’ Windows, qual é única para cada\nusuário. Portanto, ao executar setwd(‘~’), irás direcionar\no R uma pasta de fácil acesso e livre modificação pelo usuário atual\ncomputador.\n","code":"\n# get current directory\nmy_dir <- getwd()\n\n# print it\nprint(my_dir)R> [1] home/msperlin/adfeR/01-Book Content\n# set dir\nmy_d <- 'C:/Minha Pesquisa/'\nsetwd(my_d)my_d <- 'C:\\Minha pesquisa\\'\nsetwd(my_d)Error: '\\M' is an unrecognized escape in character string...\"\n# set char with \\\nmy_char <- 'using \\\\'\n\n# print it\nmessage(my_char)R> using \\\nmy_d <- 'C:/Minha pesquisa/'\nsetwd(my_d)\n# change to subfolder\nsetwd('Data')\n# change to previous level\nsetwd('..')\nmy_path <- dirname(rstudioapi::getActiveDocumentContext()$path)\nsetwd(my_path)"},{"path":"operacoes-basicas.html","id":"comentários-no-código","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.17 Comentários no Código","text":"Comentários são definidos usando o símbolo #. Qualquer texto direita desse símbolo não será processado pelo R. Note que até cor código direita hashtag muda RStudio. Isso dá liberdade para escrever o que necessário dentro script. Um exemplo:Os comentários são uma eficiente maneira de comunicar qualquer informação importante que não pode ser inferida diretamente código. O uso correto de comentários é tão importante quanto o código em si. Quando bem feitos, aumentam reproducibilidade, organização e entendimento código. Em geral, você deve evitar o uso de comentários que são muito óbvios ou muito genéricos. Por exemplo:Como você pode ver, é bastante óbvio que linha df <- read.csv('MyDataFile.csv') está lendo um arquivo .csv. O nome da função, read.csv já afirma isso. Então, o comentário não foi bom pois não adicionou novas informações ao usuário. Uma melhor abordagem seria definir o autor, descrição da funcionalidade script e explicar melhor origem e última atualização arquivo de dados. Vamos dar uma olhada:Com esses comentários, o usuário saberá o propósito script, quem o escreveu e data da última edição. origem arquivo e data de atualização mais recente também estão disponíveis. Se o usuário quiser atualizar os dados, tudo o que ele tem fazer é ir ao mencionado site e baixar o novo arquivo. Isso facilitará o uso futuro e o compartilhamento script.Outro uso de comentários é definir seções código, como em:O uso de uma longa linha de traços (-) é intencional. Isto faz com que o RStudio identifique seções código e apresente espaço abaixo editor de rotinas um atalho para acessar correspondentes linhas de cada seção. Teste você mesmo, copie e cole o código acima em um novo script RStudio, salve o mesmo, e verás que seções aparecem em um botão entre o editor e o prompt. Desta forma, uma vez que você precisa mudar uma parte específica código, você pode se dirigir rapidamente seção desejada.\nQuando começar compartilhar código com outras pessoas, logo\nperceberás que os comentários são essenciais e esperados. Eles ajudam \ntransmitir informações que não estão disponíveis código. Uma nota\naqui, ao longo livro você verá que os comentários código são, na\nmaior parte tempo, bastante óbvios. Isso foi intencional, pois\nmensagens claras e diretas são importantes para novos usuários, os quais\nfazem parte da audiência.\n","code":"\n# This is a comment\n# This is another comment\nx <- 'abc' # this is another comment, but mixed with code\n\nmy_l <- list(var1 = 1:10,   # set var 1\n             var2 = 2:5)    # another var\n# read a csv file\ndf <- read.csv ('MyDataFile.csv')\n# Script for reproducing results of JOHN (2018)\n# Author: Mr Researcher (dontspamme@emailprovider.com)\n# Last script update: 2018-01-10\n#\n# File downloaded from www.sitewithdatafiles.com/data-files/\n# The description of the data goes here\n#\n# Last file update: 2017-12-05\ndf <- read.csv('MyDataFile.csv')\n# Script for reproducing results of JOHN (2018)\n# Author: Mr Researcher (dontspamme@emailprovider.com)\n# Last script update: 2018-01-10\n#\n# File downloaded from www.sitewithdatafiles.com/data-files/\n# The description of the data goes here\n#\n# Last file update: 2017-12-05\n\n# Clean data -------------------------\n# - remove outliers\n# - remove unnecessary columns\n\n# Create descriptive tables ----------\n\n\n# Estimate models --------------------\n\n\n# Report results ---------------------"},{"path":"operacoes-basicas.html","id":"cancelando-a-execução-de-um-código","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.18 Cancelando a Execução de um Código","text":"Toda vez que o R estiver executando algum código, uma sinalização visual formato de um pequeno círculo vermelho canto direito prompt irá aparecer. Caso conseguir ler (o símbolo é pequeno em monitores modernos), o texto indica o termo stop. Esse símbolo não somente indica que o programa ainda está rodando mas também pode ser utilizado para cancelar execução de um código. Para isso, basta clicar referido botão. Outra maneira de cancelar uma execução é apontar o mouse prompt e pressionar tecla Esc teclado.Para testar o cancelamento de código, copie e cole o código seguir em um script RStudio. Após salvar, rode o mesmo com control+shift+s.O código anterior usa um comando especial tipo para mostrar mensagem cada segundo. Neste caso, o código demorará 100 segundos para rodar. Caso não desejes esperar, aperte esc para cancelar execução. Por enquanto, não se preocupe com funções utilizadas exemplo. Iremos discutir o uso comando capítulo 8.","code":"\nfor (i in 1:100) {\n  message('\\nRunning code (please make it stop by hitting esc!)')\n  Sys.sleep(1)\n}"},{"path":"operacoes-basicas.html","id":"procurando-ajuda","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.19 Procurando Ajuda","text":"Uma tarefa muito comum uso R é procurar ajuda. quantidade de funções disponíveis para o R é gigantesca e memorizar todas peculariedades é quase impossível. Assim, até mesmo usuários avançados comumente procuram ajuda sobre tarefas específicas programa, seja para entender detalhes sobre algumas funções ou estudar um novo procedimento. Portanto, saibas que o uso sistema de ajuda R faz parte cotidiano.É possível buscar ajuda utilizando tanto o painel de help RStudio como diretamente prompt. Para isso, basta digitar o ponto de interrogação junto ao objeto sobre o qual se deseja ajuda, tal como em ?mean. Nesse caso, o objeto mean é uma função e o uso comando irá abrir o painel de ajuda sobre ela. R, toda tela de ajuda de uma função é igual, conforme se vê na Figura 2.7 apresentada seguir. Esta mostra uma descrição da função mean, seus argumentos de entrada explicados e também o seu objeto de saída. tela de ajuda segue com referências e sugestões para outras funções relacionadas. Mais importante, os exemplos de uso da função aparecem por último e podem ser copiados e colados para acelerar o aprendizado uso da função.\nFigura 2.7: Tela de ajuda da função mean\nCaso quiséssemos procurar um termo nos arquivos de ajuda, bastaria utilizar o comando ??\"standard deviation\". Essa operação irá procurar ocorrência termo em todos os pacotes R e é muito útil para aprender como realizar alguma operação, nesse caso o cálculo de desvio padrão.Como sugestão, o ponto inicial e mais direto para aprender uma nova função é observando o seu exemplo de uso, localizada final da página de ajuda. Com isto, podes verificar quais tipos de objetos de entrada mesma aceita e qual o formato e o tipo de objeto na sua saída. Após isso, leia atentamente tela de ajuda para entender se mesma faz exatamente o que esperas e quais são suas opções de uso nas respectivas entradas. Caso função realizar o procedimento desejado, podes copiar e colar o exemplo de uso para o teu próprio script, ajustando onde necessário.Outra fonte muito importante de ajuda é própria internet. Sites como stackoverflow.com e mailing lists específicos R, cujo conteúdo também está na internet, são fontes preciosas de informação. Havendo alguma dúvida que não foi possível solucionar via leitura dos arquivos de ajuda R, vale o esforço de procurar uma solução via mecanismo de busca na internet. Em muitas situações, o seu problema, por mais específico que seja, já ocorreu e já foi solucionado por outros usuários.Caso estiver recebendo uma mensagem de erro enigmática, outra dica é copiar e colar mesma para uma pesquisa Google. Aqui apresenta-se outro benefício uso da língua inglesa. É mais provável que encontres solução se o erro escrito em inglês, dado o maior número de usuários na comunidade global. Caso não encontrar uma solução desta forma, podes inserir uma pergunta stackoverflow ou grupo Brasileiro R Facebook.\nToda vez que pedir ajuda na internet, procure sempre 1) descrever\nclaramente o seu problema e 2) adicionar um código reproduzível seu\nproblema. Assim, o leitor pode facilmente verificar o que está\nacontecendo ao rodar o exemplo seu computador. Não tenho dúvida que,\nse respeitar ambas regras, logo uma pessoa caridosa lhe ajudará com o\nseu problema.\n","code":""},{"path":"operacoes-basicas.html","id":"utilizando-code-completion-com-a-tecla-tab","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.20 Utilizando Code Completion com a Tecla tab","text":"Um dos recursos mais úteis RStudio é o preenchimento automático de código (code completion). Essa é uma ferramenta de edição que facilita o encontro de nomes de objetos, nome de pacotes, nome de arquivos e nomes de entradas em funções. O seu uso é muito simples. Após digitar um texto qualquer, basta apertar tecla tab e uma série de opções aparecerá. Veja Figura 2.8 apresentada seguir, em que, após digitar letra f e apertar tab, aparece uma janela com uma lista de objetos que iniciam com respectiva letra.\nFigura 2.8: Uso autocomplete para objetos\nEssa ferramenta também funciona para pacotes. Para verificar, digite library(r) prompt ou editor, coloque o cursor entre os parênteses e aperte tab. O resultado deve ser algo parecido com figura 2.9.\nFigura 2.9: Uso autocomplete para pacotes\nObserve que uma descrição pacote ou objeto também é oferecida. Isso facilita bastante o dia dia, pois memorização das funcionalidades e dos nomes dos pacotes e os objetos R não é uma tarefa fácil. O uso tab diminui o tempo de investigação dos nomes e evita possíveis erros de digitação na definição destes.O uso dessa ferramenta torna-se ainda mais benéfico quando os objetos são nomeados com algum tipo de padrão. restante livro observarás que os objetos tendem ser nomeados com o prefixo , como em my_x, my_num. O uso desse padrão facilita o encontro futuro nome dos objetos, pois basta digitar , apertar tab e uma lista de todos os objetos criados pelo usuário aparecerá.Outro uso tab é encontro de arquivos e pastas computador. Basta criar uma variável como my_file <- \" \", apontar o cursor para o meio das aspas e apertar tecla tab. Uma tela com os arquivos e pastas diretório atual de trabalho aparecerá, conforme mostrado na figura 2.10. Nesse caso específico, o R estava direcionado para minha pasta de códigos, em que é possível enxergar diversos trabalhos realizados passado.\nFigura 2.10: Uso autocomplete para arquivos\nUma dica aqui é utilizar o tab com raiz computador. Assumindo que o disco seu computador está alocado para C:/, digite my_file <- \"C:/\" e pressione tab após o símbolo /. Uma tela com os arquivos da raiz computador aparecerá RStudio. Podes facilmente navegar o sistema de arquivos utilizando setas e enter.O autocomplete também funciona para encontrar e definir entradas de uma função. Por se tratar de um tópico mais avançado, deixamos o seu uso e demonstração para o capítulo 8.\nO autocomplete é uma das ferramentas mais importantes \nRStudio, funcionando para encontro de objetos, locais disco rígido,\npacotes e funções. Acostume-se utilizar tecla tab o quanto\nantes e logo verá como fica mais fácil escrever código rapidamente, e\nsem erros de digitação.\n","code":""},{"path":"operacoes-basicas.html","id":"interagindo-com-arquivos-e-o-sistema-operacional","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.21 Interagindo com Arquivos e o Sistema Operacional","text":"Em muitas situações de uso R será necessário interagir com os arquivos computador, seja criando novas pastas, descompactando e compactando arquivos, listando e removendo arquivos disco rígido computador ou qualquer outro tipo de operação. Na grande maioria dos casos, o interesse é na manipulação de arquivos contendo dados.","code":""},{"path":"operacoes-basicas.html","id":"listando-arquivos-e-pastas","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.21.1 Listando Arquivos e Pastas","text":"Para listar arquivos computador, basta utilizar o função list.files. O argumento path define o diretório para listar os arquivos. Na construção deste livro foi criado um diretório chamado 00-text-resources/data, onde alguns dados são salvos. Pode-se verificar os arquivos nessa pasta com o seguinte código:Observe que nesse diretório encontram-se vários arquivos .csv, .rds e .xlsx. Esses contêm dados que serão utilizados em capítulos futuros. Recomenda-se utilizar o argumento full.names como TRUE, o qual faz com que o retorno da função list.files contenha o caminho completo arquivo. Isso facilita, por exemplo, uma possível importação de dados em que é necessário indicar não somente o nome arquivo, mas sua localização completa computador. Destaca-se que também é possível listar os arquivos de forma recursiva, isto é, listar os arquivos de subpastas endereço original. Para verificar, tente utilizar o seguinte código seu computador:O comando anterior irá listar todos os arquivos existentes na pasta atual e subpastas de trabalho. Dependendo de onde o comando foi executado, pode levar um certo tempo para o término processo. Caso precisar cancelar execução, aperte esc teclado.Para listar pastas (diretórios) computador, basta utilizar o comando list.dirs. Veja seguir.caso anterior, o comando lista todos os diretórios trabalho atual sem recursividade. saída comando mostra os diretórios que utilizei para escrever este livro. Isso inclui o diretório de saída livro (./_book), entre diversos outros. Nesse mesmo diretório, encontram-se os capítulos livro, organizados por arquivos e baseados na linguagem RMarkdown (.Rmd). Para listar somente os arquivos com extensão .Rmd, utiliza-se o argumento pattern da função list.files, como seguir:O texto *.Rmd$ orienta o R procurar todos arquivos que terminam o seu nome com o texto .Rmd. Os símbolos '*'' e '$' são operadores específicos para o encontro de padrões em texto em uma linguagem chamada regex (regular expressions) e, nesse caso, indicam que o usuário quer encontrar todos arquivos com extensão .Rmd. O símbolo ’*’ diz para ignorar qualquer texto anterior ‘.Rmd’ e ‘$’ indica o fim nome arquivo. Os arquivos apresentados anteriormente contêm todo o conteúdo deste livro, incluindo este próprio parágrafo, localizado arquivo 02-OperacoesBasicas.Rmd!","code":"\nmy_f <- list.files(path = \"00-text-resources/data\", full.names = TRUE)\nprint(my_f[1:5])R> [1] \"00-text-resources/data/AdjustedPrices-InternacionalIndices.RDATA\"\nR> [2] \"00-text-resources/data/BovStocks_2011-12-01_2016-11-29.csv\"      \nR> [3] \"00-text-resources/data/BovStocks_2011-12-01_2016-11-29.RData\"    \nR> [4] \"00-text-resources/data/example_gethfdata.RDATA\"                  \nR> [5] \"00-text-resources/data/FileWithLatinChar_ISO-8859-9.txt\"\n# list all files recursively\nlist.files(path = getwd(), recursive = T, full.names = TRUE)\n# list directories\nmy_dirs <- list.dirs(recursive = F)\nprint(my_dirs)R>  [1] \"./_book\"                     \nR>  [2] \"./_bookdown_files\"           \nR>  [3] \"./.Rproj.user\"               \nR>  [4] \"./00-code-resources\"         \nR>  [5] \"./00-text-resources\"         \nR>  [6] \"./adfeR_pt_ed03_cache\"       \nR>  [7] \"./adfeR_pt_ed03_files\"       \nR>  [8] \"./adfeR_pt_ed03-ONLINE_cache\"\nR>  [9] \"./adfeR_pt_ed03-ONLINE_files\"\nR> [10] \"./gdfpd2_cache\"              \nR> [11] \"./gfred_cache\"               \nR> [12] \"./many_datafiles\"            \nR> [13] \"./quandl_cache\"              \nR> [14] \"./tabs\"                      \nR> [15] \"./TD Files\"\nlist.files(path = getwd(), pattern = \"*.Rmd$\")R>  [1] \"_BemVindo.Rmd\"                             \nR>  [2] \"00a-Sobre-NovaEdicao.Rmd\"                  \nR>  [3] \"00b-Prefacio.Rmd\"                          \nR>  [4] \"01-Introducao.Rmd\"                         \nR>  [5] \"02-Operacoes-Basicas.Rmd\"                  \nR>  [6] \"03-Scripts-Pesquisa.Rmd\"                   \nR>  [7] \"04-Importacao-Exportacao-Local.Rmd\"        \nR>  [8] \"05-Importacao-Internet.Rmd\"                \nR>  [9] \"06-Objetos-Armazenamento.Rmd\"              \nR> [10] \"07-Objetos-Basicos.Rmd\"                    \nR> [11] \"08-Programacao-com-R--ONLINE.Rmd\"          \nR> [12] \"09-Limpando-Estruturando-Dados--ONLINE.Rmd\"\nR> [13] \"10-Figuras--ONLINE.Rmd\"                    \nR> [14] \"11-Modelagem--ONLINE.Rmd\"                  \nR> [15] \"12-Reportando-resultados--ONLINE.Rmd\"      \nR> [16] \"13-Otimizacao-código--ONLINE.Rmd\"          \nR> [17] \"14-Referencias.Rmd\"                        \nR> [18] \"adfeR_pt_ed03-ONLINE.Rmd\"                  \nR> [19] \"index.Rmd\""},{"path":"operacoes-basicas.html","id":"apagando-arquivos-e-diretórios","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.21.2 Apagando Arquivos e Diretórios","text":"remoção de arquivos é realizada através comando file.remove:Lembre-se que deves ter permissão seu sistema operacional para apagar um arquivo. Para o nosso caso, o retorno TRUE mostra que operação teve sucesso.Para deletar diretórios e todos os seus elementos, utilizamos unlink:função, neste caso, não retorna nada. Podes checar se o diretório existe com dir.exists:\nNão preciso nem dizer, tenha muito cuidado com\ncomandos file.remove e unlink, principalmente\nquando utilizar recursividade (recursive = TRUE). Uma\nexecução errada e partes importantes seu disco rídigo podem ser\napagadas, deixando o seu computador inoperável. Vale salientar que o R\nrealmente apaga os arquivos e não somente manda para \nlixeira. Portanto, ao apagar diretórios com unlink, não\npoderás recuperar os arquivos.\n","code":"\n# create temporary file\nmy_file <- 'MyTemp.csv'\nwrite.csv(x = data.frame(x=1:10),\n          file = my_file)\n\n# delete it\nfile.remove(my_file)R> [1] TRUE\n# create temp dir\ndir.create('temp')\n\n# fill it with file\nmy_file <- 'temp/tempfile.csv'\nwrite.csv(x = data.frame(x=1:10),\n          file = my_file)\n\nunlink(x = 'temp', recursive = TRUE)\ndir.exists('temp')R> [1] FALSE"},{"path":"operacoes-basicas.html","id":"utilizando-arquivos-e-diretórios-temporários","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.21.3 Utilizando Arquivos e Diretórios Temporários","text":"Um aspecto interessante R é que ele possui uma pasta temporária que é criado na inicialização programa. Esse diretório serve para guardar quaisquer arquivos descartáveis gerados pelo R. cada nova sessão R, um novo diretório temporário é criado. Ao inicializarmos o computador, essa pasta temporária é deletada.O endereço diretório temporário de uma sessão R é verificado com tempdir:O último texto diretório, neste caso RtmpN2n71F é aleatóriamente definido e irá trocar cada nova sessão R.mesma dinâmica é encontrada para nomes de arquivos. Caso queira, por algum motivo, utilizar um nome temporário e aleatório para algum arquivo com extensão .txt, utilize tempfile e defina entrada fileext:Note que o nome arquivo – file11cf43d05d89.txt – é totalmente aleatório e mudará cada chamada de tempfile.","code":"\nmy_tempdir <- tempdir()\nmessage(str_glue('My tempdir is {my_tempdir}'))R> My tempdir is /tmp/RtmpN2n71F\nmy_tempfile <- tempfile(fileext = '.txt')\nmessage(my_tempfile)R> /tmp/RtmpN2n71F/file11cf43d05d89.txt"},{"path":"operacoes-basicas.html","id":"baixando-arquivos-da-internet","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.21.4 Baixando Arquivos da Internet","text":"O R pode baixar arquivos da Internet diretamente código. Isso é realizado com função download.file. Veja o exemplo seguir, onde baixamos uma planilha de Excel site da Microsoft para um arquivo temporário:O uso de download.file é bastante prático quando se está trabalhando com dados da Internet que são constantemente atualizados. Basta baixar e atualizar o arquivo com dados início script. Poderíamos continuar rotina lendo o arquivo baixado e realizando nossa análise dos dados disponíveis.Um exemplo nesse caso é tabela de empresas listadas na bolsa divulgada pela CVM (comissão de valores mobiliários). tabela está disponível em um arquivo site. Podemos baixar o arquivo e, logo em seguida, ler os dados.Existem diversas informações interessantes nestes dados incluindo nome e CNPJ de empresas listadas (ou deslistadas) da bolsa de valores Brasileira. E, mais importante, o arquivo está sempre atualizado. O código anterior estará sempre buscando os dados mais recentes cada execução.","code":"\n# set link\nlink_dl <- 'go.microsoft.com/fwlink/?LinkID=521962'\nlocal_file <- tempfile(fileext = '.xlsx') # name of local file\n\ndownload.file(url = link_dl,\n              destfile = local_file)\nlibrary(readr)\nlibrary(dplyr)\n\n# set destination link and file\nmy_link <- 'http://dados.cvm.gov.br/dados/CIA_ABERTA/CAD/DADOS/cad_cia_aberta.csv'\nmy_destfile <- tempfile(fileext = '.csv')\n\n# download file\ndownload.file(my_link, \n              destfile = my_destfile, \n              mode = \"wb\")\n\n# read it\ndf_cvm <- read_csv2(my_destfile,\n                     #delim = '\\t',\n                     locale = locale(encoding = 'Latin1'),\n                     col_types = cols())R> ℹ Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n# check available columns\nprint(names(df_cvm))R>  [1] \"CNPJ_CIA\"           \"DENOM_SOCIAL\"      \nR>  [3] \"DENOM_COMERC\"       \"DT_REG\"            \nR>  [5] \"DT_CONST\"           \"DT_CANCEL\"         \nR>  [7] \"MOTIVO_CANCEL\"      \"SIT\"               \nR>  [9] \"DT_INI_SIT\"         \"CD_CVM\"            \nR> [11] \"SETOR_ATIV\"         \"TP_MERC\"           \nR> [13] \"CATEG_REG\"          \"DT_INI_CATEG\"      \nR> [15] \"SIT_EMISSOR\"        \"DT_INI_SIT_EMISSOR\"\nR> [17] \"CONTROLE_ACIONARIO\" \"TP_ENDER\"          \nR> [19] \"LOGRADOURO\"         \"COMPL\"             \nR> [21] \"BAIRRO\"             \"MUN\"               \nR> [23] \"UF\"                 \"PAIS\"              \nR> [25] \"CEP\"                \"DDD_TEL\"           \nR> [27] \"TEL\"                \"DDD_FAX\"           \nR> [29] \"FAX\"                \"EMAIL\"             \nR> [31] \"TP_RESP\"            \"RESP\"              \nR> [33] \"DT_INI_RESP\"        \"LOGRADOURO_RESP\"   \nR> [35] \"COMPL_RESP\"         \"BAIRRO_RESP\"       \nR> [37] \"MUN_RESP\"           \"UF_RESP\"           \nR> [39] \"PAIS_RESP\"          \"CEP_RESP\"          \nR> [41] \"DDD_TEL_RESP\"       \"TEL_RESP\"          \nR> [43] \"DDD_FAX_RESP\"       \"FAX_RESP\"          \nR> [45] \"EMAIL_RESP\"         \"CNPJ_AUDITOR\"      \nR> [47] \"AUDITOR\""},{"path":"operacoes-basicas.html","id":"exerc-operacoes-basicas","chapter":"Capítulo 2 Operações Básicas no R","heading":"2.22 Exercícios","text":"","code":""},{"path":"operacoes-basicas.html","id":"q.1-1","chapter":"Capítulo 2 Operações Básicas no R","heading":"Q.1","text":"Crie um novo script, salve o mesmo em uma pasta pessoal. Agora, escreva os comandos script que definam dois objetos: um contendo uma sequência entre 1 e 100 e outro com o texto seu nome (ex. 'Ricardo'). Execute o código com os atalhos teclado.\n\nSolução\n\n","code":"x <- 1:100\ny <- 'Ricardo'\n\n# press control+shift+enter to run this chunk of code in RStudio"},{"path":"operacoes-basicas.html","id":"q.2-1","chapter":"Capítulo 2 Operações Básicas no R","heading":"Q.2","text":"script criado anteriormente, use função message para mostrar seguinte frase prompt R: \"name ....\".\n\nSolução\n\n","code":"x <- 36\ny <- 'Ricardo'\n\nmessage(paste0('My name is ', y))\n\n# press control+shift+enter to run this chunk of code in RStudio"},{"path":"operacoes-basicas.html","id":"q.3-1","chapter":"Capítulo 2 Operações Básicas no R","heading":"Q.3","text":"Dentro mesmo script, mostre o diretório atual de trabalho (veja função getwd, tal como em print(getwd())). Agora, modifique o seu diretório de trabalho para o Desktop (Área de Trabalho) e mostre seguinte mensagem na tela prompt: 'desktop address ....'. Dica: use e abuse da ferramenta autocomplete RStudio para rapidamente encontrar pasta desktop.\n\nSolução\n\n","code":"current_dir <- getwd()\nprint(current_dir)\n\nnew_dir <- '~/Desktop/' # this is probably C:/Users/USERNAME/Desktop for Windows\nsetwd(new_dir)\n\ncat(paste0('My desktop address is ', getwd()))"},{"path":"operacoes-basicas.html","id":"q.4-1","chapter":"Capítulo 2 Operações Básicas no R","heading":"Q.4","text":"Utilize o R para baixar o arquivo compactado com o material livro, disponível nesse link14. Salve o mesmo como um arquivo na pasta temporária da sessão (veja função tempfile).\n\nSolução\n\n","code":"local_file <- tempfile(fileext = '.zip')\nmy_url <- 'https://www.msperlin.com/files/pafdr%20files/Code_Data_pafdR.zip'\n\ndownload.file(url = my_url, \n              destfile = local_file)\n\n# check if exists\nfile.exists(local_file)"},{"path":"operacoes-basicas.html","id":"q.5-1","chapter":"Capítulo 2 Operações Básicas no R","heading":"Q.5","text":"Utilize função unzip para descompactar o arquivo baixado na questão anterior para um diretório chamado 'adfeR-Files' dentro da pasta “Desktop”. Quantos arquivos estão disponíveis na pasta resultante? Dica: use o argumento recursive = TRUE com list.files para procurar também todos subdiretórios disponíveis.\n\nSolução\n\n","code":"my_folder <- '~/Desktop/adfeR-Files' # this is probably C:/Users/USERNAME/Desktop for Windows\nunzip(local_file, exdir = my_folder) # local_file comes from previous exercise\n\nfiles <- list.files(my_folder, \n                    full.names = TRUE, \n                    recursive = TRUE)\n\nn_files <- length(files)\n\nmessage(paste0('There are ', n_files, ' files available at folder \"', my_folder, '\".'))"},{"path":"operacoes-basicas.html","id":"q.6-1","chapter":"Capítulo 2 Operações Básicas no R","heading":"Q.6","text":"Toda vez que o usuário instala um pacote R, os arquivos particulares ao pacote são armazenados localmente em uma pasta específica computador. Utilizando comando Sys.getenv('R_LIBS_USER') e list.dirs, liste todos os diretórios desta pasta. Quantos pacotes estão disponíveis nesta pasta seu computador?\n\nSolução\n\n","code":"r_pkg_folder <- Sys.getenv ('R_LIBS_USER')\n\navailable_dirs <- list.dirs(r_pkg_folder, recursive = FALSE)\nn_dirs <- length(available_dirs)\n\ncat(paste0('There are ', n_dirs, ' folders available  at \"', r_pkg_folder, '\".'))"},{"path":"operacoes-basicas.html","id":"q.7-1","chapter":"Capítulo 2 Operações Básicas no R","heading":"Q.7","text":"mesmo assunto exercício anterior, liste todos os arquivos em todas subpastas diretório contendo os arquivos dos diferentes pacotes. Em média, quantos arquivos são necessários para cada pacote?\n\nSolução\n\n","code":"r_pkg_folder <- Sys.getenv ('R_LIBS_USER')\n\npkg_files <- list.files(r_pkg_folder, recursive = TRUE)\nmy_dirs <- list.dirs(r_pkg_folder, recursive = FALSE)\n\nn_files <- length(pkg_files)\nn_dirs <- length(my_dirs)\n\nmy_msg <- paste0('We have ', length(pkg_files), ' ',\n                 'files for ', length(my_dirs), ' packages. \\n',\n                 'On average, there are ', n_files/n_dirs, ' files per directory.')\n\nmessage(my_msg)"},{"path":"operacoes-basicas.html","id":"q.8-1","chapter":"Capítulo 2 Operações Básicas no R","heading":"Q.8","text":"Use função install.packages para instalar o pacote BatchGetSymbols seu computador. Após instalação, use função BatchGetSymbols::BatchGetSymbols para baixar dados de preços para ação da Petrobrás – PETR3 (PETR3.SA Yahoo finance) – nos últimos 15 dias. Dicas: 1) use função Sys.Date() para definir data atual e Sys.Date() - 15 para calcular data localizada 15 dias passado; 2) note que saída de BatchGetSymbols é uma lista, um tipo especial de objeto, e o que os dados de preços estão localizados segundo elemento dessa lista.\n\nSolução\n\n","code":"if (!require(BatchGetSymbols)) install.packages('BatchGetSymbols')\n\nl_out <- BatchGetSymbols(tickers = 'PETR3.SA',\n                         first.date = Sys.Date() - 15,\n                         last.date = Sys.Date())\n\ndf_prices <- l_out[[2]]\nstr(df_prices)"},{"path":"operacoes-basicas.html","id":"q.9-1","chapter":"Capítulo 2 Operações Básicas no R","heading":"Q.9","text":"O pacote cranlogs permite o acesso estatísticas de downloads de pacotes CRAN. Após instalar o cranlogs seu computador, use função cranlogs::cran_top_downloads para verificar quais são os 10 pacotes mais instalados pela comunidade global último mês. Qual o pacote em primeiro lugar? Dica: Defina entrada da função cran_top_downloads como sendo = 'last-month'. Também note que resposta aqui pode não ser mesma que obteve pois esta depende dia em que foi executado o código.\n\nSolução\n\n","code":"#if (!require(cranlogs)) install.packages('cranlogs')\n\npkgs <- cranlogs::cran_top_downloads(when = 'last-month')\n\nmy_sol <- pkgs$package[1]"},{"path":"operacoes-basicas.html","id":"q.10-1","chapter":"Capítulo 2 Operações Básicas no R","heading":"Q.10","text":"Utilizando pacote devtools, instale versão de desenvolvimento pacote ggplot2, disponível repositório de Hadley Hickman. Carregue o pacote usando library e crie uma figura simples com o código qplot(y = rnorm(10), x = 1:10).\n\nSolução\n\n","code":"if (!require(devtools)) install.packages(\"devtools\")\n\ndevtools::install_github('hadley/ggplot2')\n\nlibrary(ggplot2)\nqplot(y = rnorm (10), x = 1:10)"},{"path":"operacoes-basicas.html","id":"q.11","chapter":"Capítulo 2 Operações Básicas no R","heading":"Q.11","text":"Utilizando sua capacidade de programação, verifique seu computador qual pasta, partir diretório de “Documentos” (atalho = ~), possui o maior número de arquivos. Apresente na tela R cinco pastas com maior número de arquivos.\n\nSolução\n\n","code":"doc_folder <- '~' # 'C:/Users/USERNAME/Documents' in Windows\n                  # '/home/USERNAME/  in Linux\n\nfct_count_files <- function(dir_in) {\n  n_files <- list.files(dir_in, recursive = FALSE)\n  return(length(n_files))\n}\n\n# be aware this might take lots of time...\nall_folders <- fs::dir_ls(path = doc_folder, \n                          type = 'directory', \n                          recurse = TRUE)\n\ncounter_files <- sapply(all_folders, fct_count_files)\nsorted <- sort(counter_files, decreasing = TRUE)\n\nmessage('\\nThe five folders with highest number of files are:\\n\\n')\nmessage(paste0(names(sorted[1:5]), collapse = '\\n'))"},{"path":"scripts-pesquisa.html","id":"scripts-pesquisa","chapter":"Capítulo 3 Desenvolvendo Rotinas de Pesquisa","heading":"Capítulo 3 Desenvolvendo Rotinas de Pesquisa","text":"capítulo anterior aprendemos utilizar o R e RStudio para operações básicas tal como criação de scripts, manipulação de objetos R, mudança de diretório de trabalho, entre outras. Antes de passarmos para importação de dados, é necessário discutirmos como organizar uma rotina de pesquisa seu computador.Neste capítulo iremos tratar das etapas de pesquisa e organização de arquivos computador, incluindo dados e rotinas. O principal objetivo aqui é mostrar e justificar um formato de trabalho que facilite o desenvolvimento e compartilhamento de código. Por exemplo, ao abrir um diretório de projeto antigo, própria estrutura dos arquivos e pastas já indicará como o mesmo funciona e quais suas entradas e saídas.","code":""},{"path":"scripts-pesquisa.html","id":"etapas-de-uma-pesquisa","chapter":"Capítulo 3 Desenvolvendo Rotinas de Pesquisa","heading":"3.1 Etapas de uma Pesquisa","text":"Um script de pesquisa pode ser organizado em quatro etapas consecutivas:Importação dos dados: Dados crus (originais) mundo real são importados para sua sessão R, seja de arquivo local ou da internet. Neste momento, nenhum tipo de manipulação de dados ou reformatação manual deve acontecer. Como regra de bolso, dados crus nunca devem ser tocados. Deixe toda e qualquer manipulação para etapa seguinte.Importação dos dados: Dados crus (originais) mundo real são importados para sua sessão R, seja de arquivo local ou da internet. Neste momento, nenhum tipo de manipulação de dados ou reformatação manual deve acontecer. Como regra de bolso, dados crus nunca devem ser tocados. Deixe toda e qualquer manipulação para etapa seguinte.Limpeza e estruturação dos dados: Dados importados na fase anterior são processados em uma etapa de limpeza e estruturação. Registros anormais e erros em observações são eliminados ou tratados das tabelas originais. Novas variáveis de interesse são criadas com base nos dados importados. estrutura dos dados originais também pode ser refeita de acordo com necessidade. O resultado final dessa etapa deve ser, preferencialmente, uma tabela final com todos os dados necessários para análise problema.Limpeza e estruturação dos dados: Dados importados na fase anterior são processados em uma etapa de limpeza e estruturação. Registros anormais e erros em observações são eliminados ou tratados das tabelas originais. Novas variáveis de interesse são criadas com base nos dados importados. estrutura dos dados originais também pode ser refeita de acordo com necessidade. O resultado final dessa etapa deve ser, preferencialmente, uma tabela final com todos os dados necessários para análise problema.Visualização de dados e teste de hipóteses: Após limpar e estruturar os dados, o próximo passo é realizar análise em si, qual será visual, através da criação de diversas figuras, ou então com estimação de modelos e testes de hipótese. Essa etapa refere-se ao próprio problema da pesquisa. Na grande maioria dos casos, essa é fase que exigirá maior trabalho, visto que representa o coração da pesquisa. Essa etapa termina com criação de arquivos, tal como uma figura com extensão .png, que serão utilizados na etapa seguinte.Visualização de dados e teste de hipóteses: Após limpar e estruturar os dados, o próximo passo é realizar análise em si, qual será visual, através da criação de diversas figuras, ou então com estimação de modelos e testes de hipótese. Essa etapa refere-se ao próprio problema da pesquisa. Na grande maioria dos casos, essa é fase que exigirá maior trabalho, visto que representa o coração da pesquisa. Essa etapa termina com criação de arquivos, tal como uma figura com extensão .png, que serão utilizados na etapa seguinte.Reportando os resultados: última etapa é criação dos objetos de interesse serem reportados artigo ou relatório. Esses objetos geralmente referem-se tabelas e figuras, que podem ser exportados como arquivos externos e futuramente importados em um relatório.Reportando os resultados: última etapa é criação dos objetos de interesse serem reportados artigo ou relatório. Esses objetos geralmente referem-se tabelas e figuras, que podem ser exportados como arquivos externos e futuramente importados em um relatório.Cada uma das etapas anteriores pode ser estruturada em um único arquivo .R ou em vários arquivos separados. O uso de vários arquivos é preferível quando etapas de cada pesquisa demandarem muito tempo de processamento. Por exemplo, na importação e organização de uma base de dados de grande volume, vale pena separar os procedimentos em arquivos diferentes. Isto facilita o encontro de erros e manutenção código.Um caso prático seria análise de dados volumosos de transações financeiras mercado de capitais. importação e limpeza desses dados leva muito tempo. Uma organização inteligente da estrutura da pesquisa seria dividir etapas em diferentes scripts R e, usando arquivos locais de dados como “pontes”, lincar um script com outro. Assim, rotina de importação e limpeza de dados salva um arquivo .rds final de sua execução, o qual é importando script de teste de hipóteses. Desta forma, uma mudança na modelagem problema não exige que todo o processo de limpeza dos dados seja refeito. Essa simples organização de arquivos economiza bastante tempo. lógica é clara: isole partes da pesquisa que exigem muito tempo de execução – e pouco de desenvolvimento –, e conecte mesmas com o resto código usando arquivos externos de dados, tal como arquivos .rds e .csv.Caso você trabalhar com diversos arquivos, uma sugestão é criar uma estrutura de nomenclatura que defina etapas da pesquisa. Um exemplo seria nomear o código de importação de dados como 01-Import--clean-data.R, o código de modelagem como 02-build-report-models.R e assim sucessivamente. O efeito prático é que o uso de um contador na primeira letra nome arquivo faz com que ordem de execução programa fique clara. Indo além, você pode criar um script mestre chamado 00-run--.R que roda (comando source) todos outras rotinas. Assim, toda vez que realizar uma atualização nos dados originais, você pode simplesmente executar 00-run--.R e terá os novos resultados, sem necessitar rodar cada script individualmente.","code":""},{"path":"scripts-pesquisa.html","id":"diretorios","chapter":"Capítulo 3 Desenvolvendo Rotinas de Pesquisa","heading":"3.2 A Estrutura de Diretórios","text":"Uma estrutura de organização de diretórios também beneficia reprodutibilidade e organização da pesquisa. Para rotinas simples, com uma base de dados única e um baixo número de procedimentos, não é necessário dispender muito tempo pensando na organização dos arquivos nos diretórios. Para programas mais complexos, onde existem diversas etapas de pesquisa e diversas bases de dados, uma segmentação dos diretórios é não somente recomendada como essencial.Uma estrutura de diretórios que considero eficiente é criar um diretório único para pesquisa e, dentro dele, criar subdiretórios para cada elemento de entrada e saída. Por exemplo, você pode criar um subdiretório chamado data, onde todos os dados originais serão guardados, um diretório figs e um tables, para onde figuras e tabelas com resultados de interesse serão exportadas. Para funções utilizadas na pesquisa, você pode também criar um diretório chamado R-Fcts. Todos os scripts principais da pesquisa, e nada mais, devem ficar na raiz diretório de pesquisa. Um exemplo da estrutura de arquivos seria:O código de pesquisa também deve ser independente, com todos os arquivos disponíveis em uma subpasta diretório raiz. Se você estiver usando muitos pacotes diferentes, é aconselhável adicionar um comentário nas primeiras linhas de 0-run--.R que indica quais pacotes são necessários para executar o código. forma mais amigável de informar é adicionando uma linha comentada que instala todos os pacotes necessários, como em # install.packages ('pkg1', 'pkg2', ...). Portanto, quando alguém recebe o código pela primeira vez, tudo o que ele (ou ela) precisa fazer é retirar o símbolo de comentário e executar rotina. Dependências externas e etapas para instalação correta software também devem ser informadas.Os benefícios deste formato de diretório são os seguintes. Se você precisar compartilhar o código com outros pesquisadores, basta compactar o diretório em um único arquivo e enviá-lo ao destinatário. Após descompactar o arquivo, estrutura da pasta informa imediatamente ao usuário onde deve alterar os dados originais, ordem de execução dos scripts na pasta raiz e onde saídas são salvas. O mesmo benefício acontece quando você reutiliza seu código futuro, digamos, daqui três anos. Ao trabalhar de forma mais inteligente, você será mais produtivo, gastando menos tempo com etapas repetitivas e desnecessárias.Seguindo sugestão de um script mestre, um exemplo comentado para o conteúdo arquivo 00-run--.R seria:Essa é primeira vez que usamos funções graphics.e sapply. primeira fecha todas janelas de gráficos abertas. Essas tendem acumular decorrer trabalho e devem ser fechadas início de um novo script. O comando sapply aplica uma função, nesse caso source, para uma série de elementos. O efeito prático em sapply(my_R_files, source) é que todos arquivos com extensão .R localizados na pasta R-Fct serão executados. Ou seja, todas funções que escrevermos nos arquivos fct_models.R e fct_clean_data.R serão carregadas em nossa sessão de trabalho. Futuramente, capítulos 10 e 8, iremos voltar ao assunto de uso de funções customizadas.Note que, assumindo que todos os pacotes já estão instalados computador, o script 00-run--.R é facilmente compartilhável e irá rodar em outro computador com nenhum problema. Caso o leitor quiser ir um passo além, pode também utilizar função file.copy para copiar todos os arquivos de figuras para pasta de escrita artigo ou documento acadêmico. partir disso, crie um link texto para cada arquivo copiado anteriormente. Como exemplo, LaTex você pode incluir um arquivo de figura com o comando \\includegraphics{filenamehere}. Pode também criar um link direto entre o arquivo de escrita e figura da pesquisa, apesar de esse método não ser recomendado, uma vez que ele cria uma dependência externa ao arquivo de escrita. Em ambas formas, todas figuras da pesquisa serão automaticamente atualizadas texto e estarão sincronizadas com os arquivos provenientes código da pesquisa. Para tabelas, importação não é tão simples, pois uma tabela pode ser escrita em diversos formatos. Existem, porém, pacotes específicos para lidar com isso. capítulo 12 estudaremos uma forma eficiente de reportar resultados utilizando os pacotes xtable (Dahl et al. 2019), texreg (Leifeld 2022), entre outros.","code":"/Capital Markets and Inflation/\n    /data/\n        stock_indices.csv\n        inflation_data.csv\n    /figs/\n        SP500_and_inflation.png\n    /tables/\n        Table1_descriptive_table.tex\n        Table2_model_results.tex\n    /R-Fcts/\n        fct_models.R\n        fct_clean_data.R\n    0-run-it-all.R\n    1-import-and-clean-data.R\n    2-run-research.R\n# clean up workspace\nrm(list=ls())\n\n# close all figure windows created with x11()\ngraphics.off()\n\n# load packages\nlibrary(pkg1)\nlibrary(pkg2)\nlibrary(pkg3)\n\n# change directory\nmy_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)\nsetwd(my.d)\n\n# list  functions in 'R-Fcts'\nmy_R_files <- list.files(path='R-Fcts',\n                         pattern = '*.R',\n                         full.names=TRUE)\n\n# Load all functions in R\nsapply(my_R_files,source)\n\n# Import data script\nsource('01-import-and-clean-data.R')\n\n# run models and report results\nsource('02-run-research.R')"},{"path":"scripts-pesquisa.html","id":"pontos-importantes-em-uma-pesquisa","chapter":"Capítulo 3 Desenvolvendo Rotinas de Pesquisa","heading":"3.3 Pontos Importantes em uma Pesquisa","text":"Aproveitando o tópico de execução de pesquisa, vou colocar aqui algumas sugestões para realização de pesquisas com o R. Deixo claro que essas são posições pessoais, oriundas das minha experiência de trabalho. Muitos pontos levantados aqui são específicos para o ambiente acadêmico, porém podem ser facilmente estendíveis para prática de pesquisa fora das universidades.Em primeiro lugar, conheça os seus dados! Entendo que o primeiro instinto ao se deparar com uma nova base de dados é instantaneamente importá-la R e sair realizando análises. Aqui, um certo nível de cautela é necessário. Toda vez que se deparar com um conjunto de dados novos, se pergunte o quanto você realmente conhece esses dados:Como os dados foram coletados? Para que fim?Como estes dados se comparam com dados já utilizados em outros trabalhos?Existe alguma possibilidade de viés na forma de coleta dos dados?Lembre-se que o propósito final de qualquer pesquisa é comunicação. Certamente irás reportar os resultados para pessoas que irão ter algum tipo de opinião informada sobre pesquisa. É provável que os avaliadores terão mais experiência que você assunto, incluindo sobre fontes e individualidades dos dados. Não desejo para ninguém estar em uma situação onde um esforço de pesquisa, com investimento de 3 6 meses de trabalho entre programação e escrita, é anulado por um simples lapso na checagem dos dados. Infelizmente, isso não é incomum.Portanto, seja muito cauteloso sobre os dados que estás utilizando. Um detalhe que passa despercebido pode invalidar toda uma pesquisa. Caso tiver sorte e base de dados vier acompanhada de um manual escrito, destrinche o mesmo até os últimos detalhes. Elenque principais dúvidas em relação aos dados e, em caso das informações não estarem claras, não seja tímido em enviar os questionamentos para o responsável.O segundo ponto é o código. Após terminar de ler este livro, o seu computador se tornará um poderoso aliado em fazer realidade suas ideias de pesquisa, por mais gigantescas e mirabolantes que forem. Porém, um grande poder vem acompanhado de grande responsabilidade. Um erro de código pode facilmente inviabilizar ou tendenciar sua pesquisa.Lembre que analisar dados é sua profissão e sua reputação é o seu maior ativo. Caso não tenhas confiança código produzido, não publique ou comunique os seus resultados. O código de sua pesquisa é de total responsabilidade sua e de mais ninguém. Verifique e questione o mesmo quantas vezes necessário. Seja, sempre, o avaliador mais criterioso seu trabalho:estatísticas descritivas das variáveis relatam fielmente base de dados?Existe alguma relação entre variáveis que pode ser verificada na tabela descritiva?Os resultados encontrados fazem sentido para literatura atual assunto? Caso não, como explicá-los?É possível que um bug código tenha produzido o resultado encontrado?Ainda surpreendo como pesquisas submetidas respeitados periódicos podem ser negadas publicação baseado em uma simples análise da tabela descritiva dos dados construídos. Erros básicos de cálculos de variáveis são facilmente encontrados para um olho treinado, que sabe onde procurar. Esse processo de avaliação contínua da sua pesquisa não somente o deixará mais forte como pesquisador() mas também servirá de treino para prática de avaliação de pares, muito utilizada na pesquisa acadêmica. Caso não tenhas confiança suficiente para reportar os resultados, teste o seu código ostensivamente. Caso já o tenha feito e ainda não estás confiante, identifique linhas de código que tens mais dificuldade e busque ajuda com um colega ou o seu orientador, caso existir. Este último é um forte aliado que pode ajudá-lo com sua maior experiência.Todo o trabalho de pesquisa é, de certa forma, baseado em trabalhos já existentes. Atualmente é extremamente difícil realizar algum tipo de pesquisa que seja totalmente inovadora. O conhecimento é construído na forma de blocos, um sobre o outro. Sempre existe uma parcela de literatura que deve ser consultada. Particularmente para o caso de pesquisa em dados, deves sempre comparar os seus resultados com os resultados já apresentados na literatura assunto, principalmente quando é um estudo replicado. Caso os resultados principais não forem semelhantes aos encontrados na literatura, questione-se o porquê disso. Será que um erro de código pode ter criado esse resultado?Deixo claro que é possível sim que resultados de uma pesquisa sejam diferentes dos da literatura, porém, o contrário é mais provável. O conhecimento disso demanda cuidado com o seu código. Bugs e erros de código são bastante comuns, principalmente nas primeiras versões das rotinas. É importante reconhecer este risco e saber administrá-lo.","code":""},{"path":"scripts-pesquisa.html","id":"exerc-scripts-pesquisa","chapter":"Capítulo 3 Desenvolvendo Rotinas de Pesquisa","heading":"3.4 Exercícios","text":"","code":""},{"path":"scripts-pesquisa.html","id":"q.1-2","chapter":"Capítulo 3 Desenvolvendo Rotinas de Pesquisa","heading":"Q.1","text":"Imagine uma pesquisa envolvendo análise seu orçamento doméstico ao longo tempo. Dados estão disponíveis em planilhas eletrônicas separadas por mês, durante 10 anos. O objetivo da pesquisa é entender se é possível compra de um imóvel daqui cinco anos. partir disso, detalhe em texto os elementos em cada etapa estudo, desde importação dos dados até construção relatório.\n\nSolução\n\npossíveis etapas estudo são:Importação 01: Importar todos os dados relativos à renda e orçamento familiar, taxa de retorno em investimentos – renda fixa ou renda variável – e históricos de preços de imóveis nos locais desejados;Importação 01: Importar todos os dados relativos à renda e orçamento familiar, taxa de retorno em investimentos – renda fixa ou renda variável – e históricos de preços de imóveis nos locais desejados;Limpeza 01: Limpe os dados para outliers e dados faltantes (NA);Limpeza 01: Limpe os dados para outliers e dados faltantes (NA);Manipulação 01: Use os dados de renda pessoal para encontrar necessidade de economia mensal para cada ano.Manipulação 01: Use os dados de renda pessoal para encontrar necessidade de economia mensal para cada ano.Manipulação 02: Com base nos retornos históricos dos investimentos em renda fixa/variável e na inflação imóvel, verifique quantos anos leva para economizar quantidade de dinheiro necessária para comprar o imóvel.Manipulação 02: Com base nos retornos históricos dos investimentos em renda fixa/variável e na inflação imóvel, verifique quantos anos leva para economizar quantidade de dinheiro necessária para comprar o imóvel.","code":""},{"path":"scripts-pesquisa.html","id":"q.2-2","chapter":"Capítulo 3 Desenvolvendo Rotinas de Pesquisa","heading":"Q.2","text":"Com base estudo proposto anteriormente, crie uma estrutura de diretórios em seu computador para acomodar pesquisa. Em um arquivo texto na pasta raiz da pesquisa, assinale arquivos fictícios para cada subdiretório (veja estrutura de diretórios início da seção 3.2). Note que criação dos diretórios pode ser realizada pelo próprio R.\n\nSolução\n\n","code":"library(fs)\n\n# set temp dir for solving exercise\ntemp_dir <- path(tempdir(), 'Chapter 3 exercise')\n\n# create folder\ndir_create(temp_dir)\n\n# create files\nfile_create(path(temp_dir, '01-import_data.R'))\nfile_create(path(temp_dir, '02-clean_data.R'))\nfile_create(path(temp_dir, '03-build_budget_table.R'))\nfile_create(path(temp_dir, '04-build_investment_realstate_table.R'))\nfile_create(path(temp_dir, '05-build_report.R'))\n\n# create dirs\ndir_create(path(temp_dir, 'data'))\ndir_create(path(temp_dir, 'tabs'))\ndir_create(path(temp_dir, 'figs'))\n\n# fill with files\nfor (i_year in 2009:2019) {\n  file_create(path(temp_dir, 'data', \n                   paste0('annual_budget_', i_year, '.xlsx')) )\n}\n\nfile_create(path(temp_dir, 'data', 'fixed_income_index.csv'))\nfile_create(path(temp_dir, 'data', 'real_state_data.rds'))\nfile_create(path(temp_dir, 'figs', 'Income_and_HousePrices.png'))\nfile_create(path(temp_dir, 'tabs',  'Table_with_Results.xlsx'))\n\ndir_tree(temp_dir)"},{"path":"importacao-exportacao.html","id":"importacao-exportacao","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"Capítulo 4 Importação e Exportação de Dados Locais","text":"Sem dúvida, primeira etapa de um script de pesquisa é carregar os seus dados em uma sessão R. Neste capítulo iremos aprender importar e exportar dados contidos em arquivos locais. Apesar de não ser uma tarefa particularmente difícil, um analista de dados deve entender diferentes características de cada formato de arquivo e como tirar vantagem deste conhecimento em cada situação. Enquanto algumas facilitam colaboração e troca de dados, outras podem oferecer um ganho significativo em tempo de execução na leitura e gravação.Aqui iremos traçar uma lista abrangente com os seguintes formatos e extensões de arquivos:Dados delimitados em texto (csv);Microsoft Excel (xls, xlsx);Arquivos de dados nativos R (RData e rds)Formato fst (fst)SQLite (SQLITE)Texto não estruturado (txt).primeira lição na importação de dados para o R é que o local arquivo deve ser indicado explicitamente código. Este endereço é passado para função que irá ler o arquivo. Veja definição seguir:Note o uso de barras (/) para designar o diretório arquivo. Referências relativas também funcionam, tal como em:Neste caso, assume-se que na pasta atual de trabalho existe um diretório chamado Data e, dentro desse, um arquivo denominado MyData.csv. Se o endereço arquivo é simplesmente o seu nome, assume-se que o mesmo encontra-se na raiz da pasta de trabalho. Para verificar o endereço atual de trabalho, utilize função getwd. \nAqui novamente reforço o uso tab e autocomplete\nRStudio. É muito mais fácil e prático encontrar\narquivos disco rígido computador usando navegação via\ntab que copiar e colar o endereço seu explorador de\narquivos. Para usar, abra aspas RStudio, coloque o cursor \nmouse entre aspas e aperte tab.\nUm ponto importante aqui é que os dados serão importados e exportados R como objetos tipo dataframe. Isto é, uma tabela contida em um arquivo Excel ou .csv se transformará em um objeto tipo dataframe ambiente de trabalho R. Quando exportarmos dados, o formato mais comum é esse mesmo tipo de objeto. Convenientemente, dataframes são nada mais que tabelas, com linhas e colunas.Cada coluna dataframe importado terá sua própria classe, sendo mais comuns numérica (numeric), texto (character), fator (factor) e data (Date). Quando realizando importação, é de fundamental importância que os dados sejam representados na classe correta. Uma vasta quantidade de erros podem ser evitados pela simples checagem das classes das colunas dataframe resultante processo de importação. Por enquanto somente é necessário entender esta propriedade básica de dataframes. Estudaremos esse objeto mais profundamente capítulo 6.","code":"\nmy_file <- 'C:/Data/MyData.csv'\nmy_file <- 'Data/MyData.csv'"},{"path":"importacao-exportacao.html","id":"pacote-adfer","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.1 Pacote adfeR","text":"Nas seções futuras iremos utilizar o pacote livro – adfeR – para carregar diversos exemplos de arquivos. Se você seguiu instruções da seção Material Suplementar localizada prefácio livro, já deves ter o pacote instalado. Caso contrário, execute o seguinte código:Uma vez que você instalou o pacote adfeR, todos os arquivos de dados usados livro foram baixados. Podemos verificar os cinco primeiros arquivos disponíveis com o comando adfeR::list_available_data:Os arquivos anteriores estão salvos na pasta de instalação dos pacote adfeR. Para ter o caminho completo, basta usar função adfeR::get_data_file tendo o nome arquivo como entrada:partir de agora iremos usar função adfeR::get_data_file para obter o caminho dos arquivos utilizados nos exemplos. Note que, desde que tenha o pacote adfeR instalado, podes facilmente reproduzir todos os exemplos livro seu computador.","code":"\n# install devtools (if not installed)\nif (!require(devtools)) install.packages ('devtools')\n\n# install book package\ndevtools::install_github ('msperlin/adfeR')\n# list available data files\nprint(adfeR::list_available_data()[1:5])R> [1] \"batchgetsymbols_parallel_example.rds\"\nR> [2] \"Brazil_footbal_games.csv\"            \nR> [3] \"example_tsv.csv\"                     \nR> [4] \"FileWithLatinChar_Latin1.txt\"        \nR> [5] \"FileWithLatinChar_UTF-8.txt\"\n# get location of file\nmy_f <- adfeR::get_data_file('grunfeld.csv')\n\n# print it\nprint(my_f)"},{"path":"importacao-exportacao.html","id":"arquivos-csv","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.2 Arquivos csv","text":"Considere o arquivo de dados formato csv chamado 'Ibov.csv', pertencente ao repositório livro. Vamos copiar o mesmo para pasta “Meus Documentos” com o uso tilda (~):Caso seja primeira vez trabalhando com arquivos tipo .csv, sugiro usar o explorador de arquivos Windows e abrir Ibov.csv com qualquer editor de texto instalado, tal como o Notepad (veja figura 4.1). Observe que primeiras linhas arquivo definem os nomes das colunas: “ref.date” e “price.close”. Conforme notação internacional, linhas são definidas pela quebra texto e colunas pelo uso da vírgula (,).\nFigura 4.1: Ibov.csv Notepad\n\nQuando trabalhando com dados brasileiros, notação internacional\npode gerar uma confusão desnecessária. Dados locais tendem usar \nvírgula para indicar valores decimais em números. Assim, é comum que\ndados locais Brasil sejam exportados usando semi-vírgula\n(;) como separador de colunas e própria vírgula como\nsímbolo de decimais. Como regra de bolso, nunca mude o formato\narquivo de texto original. Deixe esse serviço para o próprio\nR e seus pacotes.\nO conteúdo de Ibov.csv é bastante conservador e não será difícil importar o seu conteúdo. Porém, saiba que muitas vezes o arquivo .csv vem com informações extras de cabeçalho – o chamado metadata – ou diferentes formatações que exigem adaptações. Como sugestão para evitar problemas, antes de prosseguir para importação de dados em um arquivo .csv, abra o arquivo em um editor de texto qualquer e siga os seguintes passos:Verifique existência de texto antes dos dados e necessidade de ignorar algumas linhas iniciais. maioria dos arquivos .csv não contém cabeçalho, porém deves sempre checar. R, função de leitura de arquivos .csv possui uma opção para ignorar um definido número de linhas antes de começar leitura arquivo;Verifique existência de texto antes dos dados e necessidade de ignorar algumas linhas iniciais. maioria dos arquivos .csv não contém cabeçalho, porém deves sempre checar. R, função de leitura de arquivos .csv possui uma opção para ignorar um definido número de linhas antes de começar leitura arquivo;Verifique existência ou não dos nomes das colunas na primeira linha com os dados. Em caso negativo, verifique com o autor qual o nome (e significado) das colunas;Verifique existência ou não dos nomes das colunas na primeira linha com os dados. Em caso negativo, verifique com o autor qual o nome (e significado) das colunas;Verifique qual o símbolo de separador de colunas. Comumente, seguindo notação internacional, será vírgula, porém nunca se tem certeza sem checar;Verifique qual o símbolo de separador de colunas. Comumente, seguindo notação internacional, será vírgula, porém nunca se tem certeza sem checar;Para dados numéricos, verifique o símbolo de decimal, o qual deve ser o ponto (.) tal como em 2.5. Caso necessário, podes ajustar o símbolo na própria função de leitura;Para dados numéricos, verifique o símbolo de decimal, o qual deve ser o ponto (.) tal como em 2.5. Caso necessário, podes ajustar o símbolo na própria função de leitura;Verifique codificação arquivo de texto. Normalmente é UTF-8, Latin1 (ISO-8859) ou windows1252. Esses são formatos amplos e devem ser suficientes para maioria dos idiomas. Sempre que você encontrar símbolos estranhos nas colunas de texto dataframe resultante, o problema é devido uma diferença na codificação entre o arquivo e o R. Os usuários Windows podem verificar codificação de um arquivo de texto abrindo-o software Notepad++15. informações sobre codificação estarão disponíveis canto inferior direito editor. entanto, você precisa estar ciente de que o Notepad++ não faz parte da instalação Windows e pode ser necessário instalá-lo em seu computador. Os usuários de Linux e Mac podem encontrar mesmas informações em qualquer software editor de texto avançado, como o Kate16.Verifique codificação arquivo de texto. Normalmente é UTF-8, Latin1 (ISO-8859) ou windows1252. Esses são formatos amplos e devem ser suficientes para maioria dos idiomas. Sempre que você encontrar símbolos estranhos nas colunas de texto dataframe resultante, o problema é devido uma diferença na codificação entre o arquivo e o R. Os usuários Windows podem verificar codificação de um arquivo de texto abrindo-o software Notepad++15. informações sobre codificação estarão disponíveis canto inferior direito editor. entanto, você precisa estar ciente de que o Notepad++ não faz parte da instalação Windows e pode ser necessário instalá-lo em seu computador. Os usuários de Linux e Mac podem encontrar mesmas informações em qualquer software editor de texto avançado, como o Kate16.\nSempre que você encontrar uma estrutura de texto inesperada em um\narquivo .csv, use os argumentos da função de leitura\ncsv para importar informações corretamente. Repetindo,\nnunca modifique dados brutos manualmente. É muito mais\neficiente usar o código R para lidar com diferentes estruturas de\narquivos em .csv. Pode parecer mais trabalhoso, mas essa\npolítica vai economizar muito tempo futuro, pois, em algumas semanas,\nvocê provavelmente esquecerá como limpou manualmente aquele arquivo\n.csv utilizado em pesquisa passada. Com o uso de código para \nadaptação da importação de dados, sempre que você precisar atualizar o\narquivo de dados, o código irá resolver todos os problemas,\nautomatizando o processo.\n","code":"\n# get location of file\nmy_f <- adfeR::get_data_file('Ibov.csv')\n\n# copy to ~\nfile.copy(from = my_f, \n          to = '~' )R> [1] TRUER> [1] TRUE"},{"path":"importacao-exportacao.html","id":"importação-de-dados","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.2.1 Importação de Dados","text":"O R possui uma função nativa chamada base::read.csv para importar dados de arquivos .csv. Porém, esse é um dos muitos casos em que alternativa tidyverse – readr::read_csv – é mais eficiente e mais fácil de trabalhar. Resumindo, readr::read_csv lê arquivos mais rapidamente que base::read.csv, além de usar regras mais inteligentes para definir classes das colunas importadas.Este é primeira vez que usamos um pacote tidyverse, neste caso o readr. Antes de fazer isso, é necessário instalá-lo em sua sessão R. Uma maneira simples de instalar todos os pacotes pertencentes ao tidyverse é instalar o módulo de mesmo nome:Após executar o código anterior, todos os pacotes tidyverse serão instalados em seu computador. Você também deve ter em mente que alguns aspectos dessa instalação podem demorar um pouco. Assim que terminar, carregue o conjunto de pacotes tidyverse.De volta à importação de dados de arquivos .csv, use função readr::read_csv para carregar o conteúdo arquivo Ibov.csv R: O conteúdo arquivo importado é convertido para um objeto tipo dataframe R. Conforme mencionado capítulo anterior, cada coluna de um dataframe tem uma classe. Podemos verificar classes de my_df_ibov usando função glimpse pacote dplyr, que também faz parte tidyverse:Observe que coluna de datas (ref.date) foi importada como um vetor Date e os preços de fechamento como numéricos (dbl, precisão dupla). Isso é exatamente o que esperávamos. Internamente, função read_csv identifica classes das colunas de acordo com seu conteúdo.Observe também como o código anterior apresentou mensagem “Parsed column specification: …”. Essa mensagem mostra como função identifica classes das colunas lendo primeiras 1000 linhas arquivo. Regras inteligentes tentam prever classe com base conteúdo importado. Podemos usar essas informações em nosso próprio código copiando o texto e atribuindo-o uma variável: Como um exercício, vamos importar os mesmos dados, porém usando classe character (texto) para colunas ref.date:Como esperado, coluna de datas – ref.date – agora foi importada como texto. Assim, o uso de readr::read_csv pode ser resumido em duas etapas: 1) leia o arquivo sem argumentos em read_csv; 2) copie o texto das classes de coluna padrão da mensagem de saída e adicione como entrada col_types. O conjunto de passos anterior é suficiente para grande maioria dos casos. O uso da mensagem com classes das colunas é particularmente útil quando o arquivo importado tem várias colunas e definição manual de cada classe exige muita digitação.Uma alternativa mais prática uso read_csv é confiar na heurística da função e usar definição padrão das colunas automaticamente. Para isto, basta definir entrada col_types como cols(). Veja seguir:Agora, vamos estudar um caso mais anormal de arquivo .csv. pacote livro temos um arquivo chamado funky_csv_file.csv onde:o cabeçalho possui texto com informações dos dados;o arquivo usará vírgula como decimal;o texto arquivo conterá caracteres latinos.primeiras 10 linhas dos arquivos contém o seguinte conteúdo:Note existência cabeçalho até linha de número 7 e colunas sendo separadas pela semi-vírgula (“;”).Ao importar os dados com opções padrões (e erradas), teremos o resultado seguir:Claramente importação deu errado, com emissão de diversas mensagens de warning. Para resolver, utilizamos o seguinte código, estruturando todas particularidades arquivo:Veja que agora os dados foram corretamente importados, com classes corretas das colunas. Para isso, usamos função alternativa readr::read_delim. O pacote readr também possui várias outras funções para situações específicas de importação. Caso função read_csv não resolva o seu problema na leitura de algum arquivo de dados estruturado em texto, certamente outra função desse pacote resolverá.","code":"\ninstall.packages('tidyverse')\n# load library\nlibrary(tidyverse)\n# set file to read\nmy_f <- adfeR::get_data_file('Ibov.csv')\n\n# read data\nmy_df_ibov <- read_csv(my_f)R> Rows: 2716 Columns: 2\nR> ── Column specification ────────────────────────────────────\nR> Delimiter: \",\"\nR> dbl  (1): price.close\nR> date (1): ref.date\nR> \nR> ℹ Use `spec()` to retrieve the full column specification for this data.\nR> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n# check content\nglimpse(my_df_ibov)R> Rows: 2,716\nR> Columns: 2\nR> $ ref.date    <date> 2010-01-04, 2010-01-05, 2010-01-06, 2…\nR> $ price.close <dbl> 70045, 70240, 70729, 70451, 70263, 704…\n# set cols from readr import message\nmy_cols <- cols(\n  price.close = col_double(),\n  ref.date = col_date(format = \"\")\n)\n\n# read file with readr::read_csv\nmy_df_ibov <- read_csv(my_f,\n                       col_types = my_cols)\n# set cols from readr import message\nmy_cols <- cols(\n  price.close = col_double(),\n  ref.date = col_character()\n)\n\n# read file with readr::read_csv\nmy_df_ibov <- read_csv(my_f,\n                       col_types = my_cols)\n\n# check content\nglimpse(my_df_ibov)R> Rows: 2,716\nR> Columns: 2\nR> $ ref.date    <chr> \"2010-01-04\", \"2010-01-05\", \"2010-01-0…\nR> $ price.close <dbl> 70045, 70240, 70729, 70451, 70263, 704…\n# read file with readr::read_csv\nmy_df_ibov <- read_csv(my_f,\n                       col_types = cols())R> Exemplo de arquivo .csv com formato alternativo:\nR> - colunas separadas por \";\"\nR> - decimal como \",\"\nR> \nR> Dados retirados em 2021-01-13\nR> Origem: www.funkysite.com.br\nR> \nR> COD.UF;COD;NOME;state;SIGLA;number_col\nR> 35;3546306;Santa Cruz das Palmeiras;São Paulo; SP;1,90208656713367\nR> 21;2103109;Cedral;Maranhão; MA;69,8087496915832\nmy_f <- adfeR::get_data_file('funky_csv_file.csv')\n\ndf_funky <- read_csv(my_f, \n                     col_types = cols())\n\nglimpse(df_funky)R> Rows: 2\nR> Columns: 1\nR> $ `Exemplo de arquivo .csv com formato alternativo:` <chr> …\ndf_not_funky <- read_delim(file = my_f, \n                           skip = 7, # how many lines do skip\n                           delim = ';', # column separator\n                           col_types = cols(), # column types\n                           locale = locale(decimal_mark = ',')# locale\n)\n\nglimpse(df_not_funky)R> Rows: 100\nR> Columns: 6\nR> $ COD.UF     <dbl> 35, 21, 35, 35, 41, 31, 31, 21, 29, 26,…\nR> $ COD        <dbl> 3546306, 2103109, 3514700, 3538105, 411…\nR> $ NOME       <chr> \"Santa Cruz das Palmeiras\", \"Cedral\", \"…\nR> $ state      <chr> \"São Paulo\", \"Maranhão\", \"São Paulo\", \"…\nR> $ SIGLA      <chr> \" SP\", \" MA\", \" SP\", \" SP\", \" PR\", \" MG…\nR> $ number_col <dbl> 1.902087, 69.808750, 81.509312, 56.8400…"},{"path":"importacao-exportacao.html","id":"exportação-de-dados","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.2.2 Exportação de Dados","text":"Para exportar tabelas em um arquivo .csv, basta utilizar função readr::write_csv. próximo exemplo iremos criar dados artificiais, salvar em um dataframe e exportar para um arquivo .csv temporário. Veja seguir: exemplo anterior, salvamos o dataframe chamado my_df para o arquivo file11cf64c4af67.csv, localizado na pasta temporária computador. Podemos verificar o arquivo importando o seu conteúdo:O resultado está conforme o esperado, um dataframe com duas colunas, primeira com números e segunda com texto.Note que toda exportação com função write_csv irá ser formatada, por padrão, com notação internacional. Caso quiser algo diferentes, verifique opções disponíveis na função write_delim, qual é muito mais flexível.","code":"\nlibrary(readr)\n\n# set number of observations\nN <- 100\n\n# create dataframe with random data\nmy_df <- data.frame(y = runif(N),\n                    z = rep('a', N))\n\n# write to file\nf_out <- tempfile(fileext = '.csv')\nwrite_csv(x = my_df, file = f_out)\nmy_df <- read_csv(f_out,\n                  col_types = cols(y = col_double(),\n                                   z = col_character() ) )\nprint(head(my_df))R> # A tibble: 6 × 2\nR>        y z    \nR>    <dbl> <chr>\nR> 1 0.810  a    \nR> 2 0.953  a    \nR> 3 0.120  a    \nR> 4 0.0578 a    \nR> 5 0.821  a    \nR> 6 0.312  a"},{"path":"importacao-exportacao.html","id":"arquivos-excel-xls-e-xlsx","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.3 Arquivos Excel (xls e xlsx)","text":"Em Finanças e Economia, é bastante comum encontrarmos dados salvos em arquivos tipo Microsoft Excel, com extensão .xls ou .xlsx. Apesar de não ser um formato de armazenamento de dados eficiente, esse é um programa de planilhas bastante popular devido às suas funcionalidades. É muito comum que informações sejam armazenadas e distribuídas dessa forma. Por exemplo, dados históricos Tesouro Direto são disponibilizados como arquivos .xls site tesouro nacional. CVM (Comissão de Valores Mobiliários) e ANBIMA (Associação Brasileira das Entidades dos Mercados Financeiro e de Capitais) também tem preferência por esse tipo de formato em alguns dados publicados em seu site.desvantagem de usar arquivos Excel para armazenar dados é sua baixa portabilidade e o maior tempo necessário para leitura e gravação. Isso pode não ser um problema para tabelas pequenas, mas ao lidar com um grande volume de dados, o uso de arquivos Excel é frustrante e não aconselhável. Se possível, evite o uso de arquivos Excel em seu ciclo de trabalho.","code":""},{"path":"importacao-exportacao.html","id":"importação-de-dados-1","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.3.1 Importação de Dados","text":"O R não possui uma função nativa para importar dados Excel e, portanto, deve-se instalar e utilizar certos pacotes para realizar essa operação. Existem diversas opções, porém, os principais pacotes são XLConnect (Mirai Solutions GmbH 2022), xlsx (Dragulescu Arendt 2020), readxl (Wickham Bryan 2022) e tidyxl (Garmonsway 2022). .Apesar de os pacotes anteriores terem objetivos semelhantes, cada um tem suas peculiaridades. Caso leitura de arquivos Excel seja algo importante seu trabalho, aconselho-o fortemente estudar diferenças entre esses pacotes. Por exemplo, pacote tidyxl permite leitura de dados não-estruturados de um arquivo Excel, enquanto XLConnect possibilita abertura de uma conexão ativa entre o R e o Excel, onde o usuário pode transmitir dados entre um e o outro, formatar células, criar gráficos Excel e muito mais.Nesta seção, daremos prioridade para funções pacote readxl, que é um dos mais fáceis e diretos de se utilizar, além de não necessitar de outros softwares instalados (tal como o Java). Para instalar o referido pacote, basta utilizar função install.packages: Imagine agora existência de um arquivo chamado Ibov_xls.xlsx que contenha os mesmos dados Ibovespa que importamos na seção anterior. importação das informações contidas nesse arquivo para o R será realizada através da função read_excel: Observe que, nesse caso, datas já foram importadas com formatação correta na classe dttm (datetime). Essa é uma vantagem ao utilizar arquivos Excel: classe dos dados arquivo original é levada em conta momento da importação. O lado negativo desse formato é baixa portabilidade dos dados e o maior tempo necessário para execução da importação. Como regra geral, dados importados Excel apresentarão um tempo de carregamento mais alto que dados importados de arquivos .csv.","code":"\ninstall.packages('readxl')\nlibrary(readxl)\nlibrary(dplyr)\n\n# set file\nmy_f <- '00-text-resources/data/Ibov_xlsx.xlsx'\n\n# read xlsx into dataframe\nmy_df <- read_excel(my_f, sheet = 'Sheet1')\n\n# glimpse contents\nglimpse(my_df)R> Rows: 2,721\nR> Columns: 2\nR> $ ref.date    <dttm> 2010-01-04, 2010-01-05, 2010-01-06, 2…\nR> $ price.close <dbl> 70045, 70240, 70729, 70451, 70263, 704…"},{"path":"importacao-exportacao.html","id":"exportação-de-dados-1","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.3.2 Exportação de Dados","text":"exportação para arquivo Excel também é fácil. Assim como para importação, não existe uma função nativa R que execute esse procedimento. Para tal tarefa, temos pacotes xlsx e writexl (Ooms 2022). Uma diferença aqui é que o pacote xlsx oferece mais funcionalidade mas exige instalação Java JDK sistema operacional. caso Windows, basta visitar o site Java e instalar o software na versão 64 bits (opção Windows -line (64 bits)). Logo após, instale o pacote xlsx normalmente R com o comando install.packages('xlsx'). Vamos começar com um exemplo para xlsxNote que uma diferença nos argumentos da função write.xlsx é que é necessário incluir o nome da aba arquivo Excel onde os dados da tabela serão exportados. Para exportar várias informações para um mesmo arquivo, é necessário utilizar o argumento append da função write.xlsx. Caso contrário, função irá criar um novo arquivo em cada chamada da mesma. Veja o exemplo seguir, onde exportamos dois dataframes para duas abas diferentes mesmo arquivo Excel:Após exportação, podes verificar abas disponíveis arquivo exportado com função xlsx::getSheets:O diferencial pacote writexl em relação xlsx é não necessidade Java, e rapidez de execução. O lado negativo é que, na versão atual (1.4.1 – 2022-11-23), não permite escrita em arquivos já existentes. Veja seguir: Para comparar o desempenho, vamos verificar diferença de tempo de execução entre um e outro:Após execução, vamos verificar diferença de tempo:Como podemos ver, mesmo para dados de pouco volume, um dataframe com 2500 linhas e 2 colunas, diferença de tempo de execução é significativa. Caso estiveres trabalhando com grandes planilhas, o uso de pacotes readxl e writexl é fortemente recomendado. Porém, como já mostrado anteriormente, funções de xlsx oferecem algumas funcionalidades extras.","code":"\nlibrary(xlsx)\n\n# set number of rows\nN <- 50\n\n# create random dataframe\nmy_df <- data.frame(y = seq(1,N),\n                    z = rep('a',N))\n\n# write to xlsx\nf_out <- tempfile(fileext = '.xlsx')\nwrite.xlsx(x = my_df,\n           file = f_out,\n           sheetName = \"my df\")\n# set number of rows\nN <- 25\n\n# create random dfs\nmy_df_A <- data.frame(y = seq(1,N),\n                      z = rep('a',N))\n\nmy_df_B <- data.frame(z = rep('b',N))\n\n# write both df to single file\nf_out <- tempfile(fileext = '.xlsx')\nwrite.xlsx(x = my_df_A,\n           file = f_out,\n           sheetName = \"Tabela A\")\n\nwrite.xlsx(x = my_df_B,\n           file = f_out,\n           sheetName = \"Tabela B\",\n           append = TRUE )\nreadxl::excel_sheets(f_out)R> [1] \"Tabela A\" \"Tabela B\"\nlibrary(writexl)\n# set number of rows\nN <- 25\n\n# create random dfs\nmy_df_A <- data.frame(y = seq(1,N),\n                      z = rep('a',N))\n\nwrite_xlsx(x = my_df_A,\n           file = f_out)\nlibrary(writexl)\nlibrary(readxl)\nlibrary(xlsx)\n\n# set number of rows\nN <- 2500\n\n# create random dfs\nmy_df_A <- data.frame(y = seq(1,N),\n                      z = rep('a',N))\n\n# set files\nmy_file_1 <- '00-text-resources/data/temp_writexl.xlsx'\nmy_file_2 <- '00-text-resources/data/temp_xlsx.xlsx'\n\n# test export\ntime_write_writexl <- system.time(write_xlsx(x = my_df_A,\n                                             path = my_file_1))\n\ntime_write_xlsx <- system.time(write.xlsx(x = my_df_A,\n                                          file = my_file_2))\n\n# test read\ntime_read_readxl <- system.time(read_xlsx(path = my_file_1 ))\ntime_read_xlsx <- system.time(read.xlsx(file = my_file_2,\n                                        sheetIndex = 1 ))\n# results\nmy_formats <- c('xlsx', 'readxl')\nresults_read <- c(time_read_xlsx[3], time_read_readxl[3])\nresults_write<- c(time_write_xlsx[3], time_write_writexl[3])\n\n# print text\nmy_text <- paste0('\\nTime to WRITE dataframe with ',\n                  my_formats, ': ',\n                  format(results_write, digits = 4),\n                  ' seconds', collapse = '')\nmessage(my_text)R> \nR> Time to WRITE dataframe with xlsx: 1.545 seconds\nR> Time to WRITE dataframe with readxl: 0.011 seconds\nmy_text <- paste0('\\nTime to READ dataframe with ',\n                  my_formats, ': ',\n                  format(results_read, digits = 4),\n                  ' seconds', collapse = '')\nmessage(my_text)R> \nR> Time to READ dataframe with xlsx: 2.547 seconds\nR> Time to READ dataframe with readxl: 0.007 seconds"},{"path":"importacao-exportacao.html","id":"formato-.rdata-e-.rds","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.4 Formato .RData e .rds","text":"O R possui dois formatos nativos para salvar objetos de sua área de trabalho para um arquivo local com extensão RData ou rds. O grande benefício, em ambos os casos, é que o arquivo resultante é compacto e o seu acesso é muito rápido. desvantagem é que os dados perdem portabilidade para outros programas. diferença entre um formato e outro é que arquivos RData podem salvar mais de um objeto, enquanto o formato .rds salva apenas um. Na prática, porém, essa não é uma restrição forte. R existe um objeto tipo lista que incorpora outros. Portanto, caso salvarmos uma lista em um arquivo .rds, podemos gravar disco quantos objetos forem necessário.","code":""},{"path":"importacao-exportacao.html","id":"importação-de-dados-2","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.4.1 Importação de Dados","text":"Para carregar os dados de um aquivo RData, utilizamos função load: O arquivo temp.RData possui dois objetos, my_x e my_y, os quais se tornam disponíveis na área de trabalho depois da chamada de load.O processo de importação para arquivos .rds é muito semelhante. diferença é uso da função readr::read_rds:Comparando o código entre o uso de arquivos .RData e .rds, note que um benefício uso de .rds é explícita definição objeto na área de trabalho. Isto é, o conteúdo de my_file em readr::read_rds é explicitamente salvo em my_x. Quando usamos função load, código não fica claro qual o nome objeto que foi importado. Isso é particularmente inconveniente quando é necessário modificar o nome objeto importado.\nComo sugestão, dê preferência ao uso formato .rds, o qual\nresulta em códigos mais transparentes. diferença de velocidade de\nacesso e gravação entre um e outro é mínima. O benefício de importar\nvários objetos em um mesmo arquivo com o formato RData\ntorna-se irrelevante quando uso de objetos tipo lista, os quais\npodem incorporar outros objetos seu conteúdo.\n","code":"\n# set a object\nmy_x <- 1:100\n\n# set temp name of RData file\nmy_file <- adfeR::get_data_file('temp.RData')\n\n# load it\nload(file = my_file)\n# set file path\nmy_file <- adfeR::get_data_file('temp.rds')\n\n# load content into workspace\nmy_x <- readr::read_rds(file = my_file)"},{"path":"importacao-exportacao.html","id":"exportação-de-dados-2","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.4.2 Exportação de Dados","text":"Para criar um novo arquivo RData, utilizamos função save. Veja o exemplo seguir, onde criamos um arquivo RData com dois objetos:Podemos verificar existência arquivo com função file.exists:Observe que o arquivo file11cf1ededbdc.RData está disponível na pasta temporária.Já para arquivos .rds, salvamos o objeto com função saveRDS:O comando identical testa igualdade entre os objetos e, como esperado, verificamos que my_x e my_x2 são exatamente iguais.","code":"\n# set vars\nmy_x <- 1:100\nmy_y <- 1:100\n\n# write to RData\nmy_file <- tempfile(fileext = '.RData')\nsave(list = c('my_x', 'my_y'),\n     file = my_file)\nfile.exists(my_file)R> [1] TRUE\n# set data and file\nmy_x <- 1:100\nmy_file <- '00-text-resources/data/temp.rds'\n\n# save as .rds\nsaveRDS(object = my_x,\n        file = my_file)\n\n# read it\nmy_x2 <- readRDS(file = my_file)\n\n# test equality\nprint(identical(my_x, my_x2))R> [1] TRUE"},{"path":"importacao-exportacao.html","id":"arquivos-fst-pacote-fst","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.5 Arquivos fst (pacote fst)","text":"O formato fst foi especialmente desenhado para possibilitar gravação e leitura de dados tabulares de forma rápida e com mínimo uso espaço disco. O uso deste formato é particularmente benéfico quando se está trabalhando com volumosas bases de dados em computadores potentes. O grande truque formato fst é usar todos núcleos computador para importar e exportar dados, enquanto todos os demais formatos se utilizam de apenas um. Como logo veremos, o ganho em velocidade é bastante significativo. ","code":""},{"path":"importacao-exportacao.html","id":"importação-de-dados-3","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.5.1 Importação de Dados","text":"O uso formato fst é bastante simples. Utilizamos função read_fst para ler arquivos:Assim como para os demais casos, os dados estão disponíveis na área de trabalho após importação.","code":"\nlibrary(fst)\n\nmy_file <- adfeR::get_data_file('temp.fst')\nmy_df <- read_fst(my_file)\n\nglimpse(my_df)R> Rows: 1,000\nR> Columns: 1\nR> $ x <dbl> 0.70968891, 0.83903044, 0.70026554, 0.78120026, …"},{"path":"importacao-exportacao.html","id":"exportação-de-dados-3","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.5.2 Exportação de Dados","text":"Utilizamos função write_fst para gravar arquivos formato fst, :","code":"\nlibrary(fst)\n\n# create dataframe\nN <- 1000\nmy_file <- tempfile(fileext = '.fst')\nmy_df <- data.frame(x = runif(N))\n\n# write to fst\nwrite_fst(x = my_df, path = my_file)"},{"path":"importacao-exportacao.html","id":"testando-o-tempo-de-execução-do-formato-fst","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.5.3 Testando o Tempo de Execução do Formato fst","text":"Como um teste potencial pacote fst, seguir vamos cronometrar o tempo de leitura e gravação entre fst e rds para um dataframe com grande quantidade de dados: 5,000,000 linhas e 2 colunas. Iremos reportar também o tamanho arquivo resultante.Após execução, vamos verificar o resultado:diferença é gritante! O formato fst não somente lê e grava com mais rapidez mas o arquivo resultante também é menor. Porém, saiba que os resultados anteriores foram compilados em um computador com 16 núcleos. É possível que diferença de tempo para um computador mais modesto não seja tão significativa.\nDevido ao uso de todos os núcleos computador, o formato\nfst é altamente recomendado quando estiver trabalhando com\ndados volumosos em um computador potente. Não somente os arquivos\nresultantes serão menores, mas o processo de gravação e leitura será\nconsideravelmente mais rápido.\n","code":"\nlibrary(fst)\n\n# set number of rows\nN <- 5000000\n\n# create random dfs\nmy_df <- data.frame(y = seq(1,N),\n                    z = rep('a',N))\n\n# set files\nmy_file_1 <- '00-text-resources/data/temp_rds.rds'\nmy_file_2 <- '00-text-resources/data/temp_fst.fst'\n\n# test write\ntime_write_rds <- system.time(write_rds(my_df, my_file_1 ))\ntime_write_fst <- system.time(write_fst(my_df, my_file_2 ))\n\n# test read\ntime_read_rds <- system.time(readRDS(my_file_1))\ntime_read_fst <- system.time(read_fst(my_file_2))\n\n# test file size (MB)\nfile_size_rds <- file.size(my_file_1)/1000000\nfile_size_fst <- file.size(my_file_2)/1000000\n# results\nmy_formats <- c('.rds', '.fst')\nresults_read <- c(time_read_rds[3], time_read_fst[3])\nresults_write<- c(time_write_rds[3], time_write_fst[3])\nresults_file_size <- c(file_size_rds , file_size_fst)\n\n# print text\nmy_text <- paste0('\\nTime to WRITE dataframe with ',\n                  my_formats, ': ',\n                  results_write, ' seconds', collapse = '')\nmessage(my_text)R> \nR> Time to WRITE dataframe with .rds: 1.04099999999994 seconds\nR> Time to WRITE dataframe with .fst: 0.0950000000000273 seconds\nmy_text <- paste0('\\nTime to READ dataframe with ',\n                  my_formats, ': ',\n                  results_read, ' seconds', collapse = '')\nmessage(my_text)R> \nR> Time to READ dataframe with .rds: 1.03099999999995 seconds\nR> Time to READ dataframe with .fst: 0.0939999999998236 seconds\nmy_text <- paste0('\\nResulting FILE SIZE for ',\n                  my_formats, ': ',\n                  results_file_size, ' MBs', collapse = '')\nmessage(my_text)R> \nR> Resulting FILE SIZE for .rds: 65.01011 MBs\nR> Resulting FILE SIZE for .fst: 14.791938 MBs"},{"path":"importacao-exportacao.html","id":"arquivos-sqlite","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.6 Arquivos SQLite","text":"O uso de arquivos csv, rds e fst para armazenar conjuntos de dados tem seus limites medida que o tamanho dos arquivos aumenta e os dados fragmentam-se em várias tabelas. Se você está esperando muito tempo para ler apenas uma tabela de um arquivo com várias tabelas, deves procurar alternativas mais eficientes. Da mesma forma, se você estiver trabalhando em uma rede de computadores e muitas pessoas estão usando os mesmos dados, faz sentido manter e distribuir informações de um servidor central. Dessa forma, cada usuário pode ter acesso à mesma informação, simultaneamente.Isso nos leva ao tópico de programas de armazenamento e distribuição de banco de dados. Esses programas específicos geralmente funcionam com uma linguagem de consulta chamada SQL (Structured Query Language), e permitem ao usuário ler partes dos dados e mesmo manipulá-lo de forma eficiente. Existem muitas opções de software de banco de dados que se integra muito bem com R. lista inclui mySQL, SQLite e MariaDB. Aqui, forneceremos um tutorial rápido sobre esse tópico usando o SQLite, que é o mais fácil de usar, uma vez que não precisa de nenhuma configuração servidor e todos dados estão contidos em um único arquivo. Antes de irmos para os exemplos, precisamos entender como se usa o software de banco de dados. Primeiro, um banco de dados deve existir em seu computador ou rede. Segundo, o R se conectará ao banco de dados e retornará um objeto de conexão. Com base nessa conexão, enviaremos consultas para importar dados desse banco de dados usando linguagem SQL. principal vantagem é que podemos ter um grande banco de dados de, digamos, 10 GB e carregar apenas uma pequena porção dele na área de trabalho R. Essa operação também é muito rápida, permitindo um acesso eficiente às tabelas disponíveis.","code":""},{"path":"importacao-exportacao.html","id":"importação-de-dados-4","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.6.1 Importação de Dados","text":"Assumindo existência de um arquivo com formato SQLite, podemos importar suas tabelas com o pacote RSQLite: Outro exemplo uso SQLITE é com instruções de um comando SQL. Observe que, código anterior, usamos função dbReadTable para obter o conteúdo de todas linhas da tabela MyTable1. Agora, vamos usar o comando dbGetQuery para obter dados da tabela myTable2 apenas quando coluna G é igual : Nesse exemplo simples podemos ver como é fácil criar uma conexão com um banco de dados, recuperar tabelas e desconectar. Se você estiver trabalhando com dados volumosos e diversas tabelas, vale pena utilizar um software de banco de dados apropriado. Caso existir um servidor de banco de dados disponível em seu local de trabalho, eu recomendo fortemente aprender conectar-se ele e carregar dados diretamente de uma sessão R.","code":"\nlibrary(RSQLite)\n\n# set name of SQLITE file\nf_sqlite <- adfeR::get_data_file('SQLite_db.SQLITE')\n\n# open connection\nmy_con <- dbConnect(drv = SQLite(), f_sqlite)\n\n# read table\nmy_df <- dbReadTable(conn = my_con,\n                     name = 'MyTable1') # name of table in sqlite\n\n# print with str\nglimpse(my_df)R> Rows: 1,000,000\nR> Columns: 2\nR> $ x <dbl> 0.007504194, 0.439465174, 0.178387480, 0.9857759…\nR> $ G <chr> \"B\", \"B\", \"B\", \"B\", \"A\", \"B\", \"A\", \"B\", \"B\", \"B\"…\n# set sql statement\nmy_SQL_statement <- \"select * from myTable2 where G='A'\"\n\n# get query\nmy_df_A <- dbGetQuery(conn = my_con, \n                      statement = my_SQL_statement)\n\n# disconnect from db\ndbDisconnect(my_con)\n\n# print with str\nprint(str(my_df_A))R> 'data.frame':    499522 obs. of  2 variables:\nR>  $ x: num  0.0637 0.1982 0.2894 0.7389 0.0669 ...\nR>  $ G: chr  \"A\" \"A\" \"A\" \"A\" ...\nR> NULL"},{"path":"importacao-exportacao.html","id":"exportação-de-dados-4","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.6.2 Exportação de Dados","text":"Como exemplo, vamos criar dois dataframes com dados aleatórios e salvar ambos em um arquivo SQLite usando pacote RSQLite. saída TRUE de dbWriteTable indica que tudo ocorreu bem. Uma conexão foi aberta usando função dbConnect e os dataframes foram escritos em um arquivo SQLITE temporário chamado file11cf144d347f.SQLITE. É boa política de programação sempre se desconectar banco de dados após utilização. Fizemos isso com função dbDisconnect. ","code":"\nlibrary(RSQLite)\n\n# set number of rows in df\nN = 10^6 \n\n# create simulated dataframe\nmy_large_df_1 <- data.frame(x=runif(N), \n                            G= sample(c('A','B'),\n                                      size = N,\n                                      replace = TRUE))\n\nmy_large_df_2 <- data.frame(x=runif(N), \n                            G = sample(c('A','B'),\n                                       size = N,\n                                       replace = TRUE))\n\n# set name of SQLITE file\nf_sqlite <- tempfile(fileext = '.SQLITE')\n\n# open connection\nmy_con <- dbConnect(drv = SQLite(), f_sqlite)\n\n# write df to sqlite\ndbWriteTable(conn = my_con, name = 'MyTable1', \n             value = my_large_df_1)\ndbWriteTable(conn = my_con, name = 'MyTable2', \n             value = my_large_df_2)\n\n# disconnect\ndbDisconnect(my_con)"},{"path":"importacao-exportacao.html","id":"dados-não-estruturados-e-outros-formatos","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.7 Dados Não-Estruturados e Outros Formatos","text":"Os pacotes e formatos anteriores são suficientes para resolver o problema de importação de dados na grande maioria das situações. Apesar disso, vale destacar que o R possui outras funções específicas para diferentes formatos. Isso inclui arquivos exportados de outros softwares, tal como SPSS, Matlab, entre vários outros. Se esse o seu caso, sugiro um estudo aprofundado pacote foreign (R Core Team 2022).Em alguns casos nos deparamos com dados armazenados de uma forma não estruturada, tal como um texto qualquer. Pode-se importar o conteúdo de um arquivo de texto linha por linha através da função readr::read_lines. Veja o exemplo seguir, onde importamos o conteúdo inteiro livro Pride Prejudice:Neste exemplo, arquivo pride_and_prejudice.txt contém todo o conteúdo livro Pride Prejudice de Jane Austen, disponível gratuitamente pelo projeto Gutenberg17. Importamos todo o conteúdo arquivo como um vetor de texto denominado my_txt. Cada elemento de my_txt é uma linha arquivo texto original. Com base nisso, podemos calcular o número de linhas livro e o número de vezes que o nome 'Bennet', um dos protagonistas, aparece texto:exemplo, mais uma vez usamos sapply. Neste caso, função nos permitiu usar outra função para cada elemento de my_txt. Neste caso, procuramos e contamos o número de vezes que palavra “Bennet” foi encontrada texto. Observe que poderíamos simplesmente mudar name_to_search por qualquer outro nome, caso quiséssemos.","code":"\n# set file to read\nmy_f <- adfeR::get_data_file('pride_and_prejudice.txt')\n\n# read file line by line\nmy_txt <- read_lines(my_f)\n\n# print 50 characters of first fifteen lines\nprint(str_sub(string = my_txt[1:15], \n              start = 1, \n              end = 50))R>  [1] \"The Project Gutenberg EBook of Pride and Prejudice\"\nR>  [2] \"\"                                                  \nR>  [3] \"This eBook is for the use of anyone anywhere at no\"\nR>  [4] \"almost no restrictions whatsoever.  You may copy i\"\nR>  [5] \"re-use it under the terms of the Project Gutenberg\"\nR>  [6] \"with this eBook or online at www.gutenberg.org\"    \nR>  [7] \"\"                                                  \nR>  [8] \"\"                                                  \nR>  [9] \"Title: Pride and Prejudice\"                        \nR> [10] \"\"                                                  \nR> [11] \"Author: Jane Austen\"                               \nR> [12] \"\"                                                  \nR> [13] \"Posting Date: August 26, 2008 [EBook #1342]\"       \nR> [14] \"Release Date: June, 1998\"                          \nR> [15] \"Last Updated: March 10, 2018\"\n# count number of lines\nn_lines <- length(my_txt)\n\n# set target text\nname_to_search <- 'Bennet'\n\n# set function for counting words\nfct_count_bennet <- function(str_in, target_text) {\n  \n  require(stringr)\n  \n  \n  n_words <- length(str_locate_all(string = str_in, \n                                   pattern = target_text)[[1]])\n  \n  return(n_words)\n}\n\n# use fct for all lines of Pride and Prejudice\nn_times <- sum(sapply(X = my_txt, \n                      FUN = fct_count_bennet, \n                      target_text = name_to_search))\n\n# print results\nmy_msg <- paste0('The number of lines found in the file is ', \n                 n_lines, '.\\n',\n                 'The word \"', name_to_search, '\" appears ', \n                 n_times, ' times in the book.')\nmessage(my_msg)R> The number of lines found in the file is 13427.\nR> The word \"Bennet\" appears 664 times in the book."},{"path":"importacao-exportacao.html","id":"exportando-de-dados-não-estruturados","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.7.1 Exportando de Dados Não-Estruturados","text":"Em algumas situações, é necessário exportar algum tipo de texto para um arquivo. Por exemplo: quando se precisa salvar o registro de um procedimento em um arquivo de texto; ou quando se precisa gravar informações em um formato específico não suportado pelo R. Esse procedimento é bastante simples. Junto à função readr::write_lines, basta indicar um arquivo de texto para saída com o argumento file. Veja seguir:exemplo, criamos um objeto de texto com uma mensagem sobre data atual e gravamos saída arquivo temporário file11cf6e0160ac.txt. Podemos checar o resultado com função readr::read_lines:","code":"\n# set file\nmy_f <- tempfile(fileext = '.txt')\n\n# set some string\nmy_text <- paste0('Today is ', Sys.Date(), '\\n', \n                  'Tomorrow is ', Sys.Date()+1)\n\n# save string to file\nwrite_lines(x = my_text, file = my_f, append = FALSE)\nprint(read_lines(my_f))R> [1] \"Today is 2022-11-23\"    \"Tomorrow is 2022-11-24\""},{"path":"importacao-exportacao.html","id":"selecionando-o-formato","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.8 Selecionando o Formato","text":"Após entendermos forma de salvar e carregar dados de arquivos locais em diferentes formatos, é importante discutirmos sobre escolha formato. O usuário deve levar em conta três pontos nessa decisão:velocidade de importação e exportação;tamanho arquivo resultante;compatibilidade com outros programas e sistemas.Na grande maioria das situações, o uso de arquivos csv satisfaz esses quesitos. Ele nada mais é que um arquivo de texto que pode ser aberto, visualizado e importado em qualquer programa. Desse modo, fica muito fácil compartilhar dados compatíveis com outros usuários. Além disso, o tamanho de arquivos csv geralmente não é exagerado em computadores modernos. Caso necessário, podes compactar o arquivo .csv usando o programa 7zip, por exemplo, o qual irá diminuir consideravelmente o tamanho arquivo. Por esses motivos, o uso de arquivos csv para importações e exportações é preferível na grande maioria das situações. Existem casos, porém, onde velocidade de importação e exportação pode fazer diferença. Caso abrir mão de portabilidade não faça diferença ao projeto, o formato rds é ótimo e prático. Se este não foi suficiente, então melhor alternativa é partir para o fst, o qual usa maior parte hardware computador para importar os dados. Como sugestão, caso puder, apenas evite o formato Excel, o qual é o menos eficiente de todos.","code":""},{"path":"importacao-exportacao.html","id":"exerc-importacao-exportacao","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"4.9 Exercícios","text":"","code":""},{"path":"importacao-exportacao.html","id":"q.1-3","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"Q.1","text":"Crie um dataframe com o código seguir:Exporte o dataframe resultante para cada um dos cinco formatos: csv, rds, xlsx, fst. Qual dos formatos ocupou maior espaço na memória computador? Dica: file.size calcula o tamanho de arquivos dentro próprio R.\n\nSolução\n\n","code":"library(dplyr)\n\nmy_N <- 10000\nmy_df <- tibble(x = 1:my_N,\n                y = runif(my_N))library(tidyverse)\n\ndo_tests <- function(my_N) {\n  \n  my_df <- tibble(x = 1:my_N,\n                  y = runif(my_N))\n  \n  # csv\n  my_f <- tempfile(pattern = 'temp', fileext = '.csv')\n  time.csv <- system.time({\n    write_csv(my_df, my_f)\n  })['elapsed']\n  size.csv <- file.size(my_f)/1000000\n  \n  # rds\n  my_f <- tempfile(pattern = 'temp', fileext = '.rds')\n  time.rds <- system.time({\n    write_rds(my_df, my_f)\n  })['elapsed']\n  \n  size.rds <- file.size(my_f)/1000000\n  \n  # xlsx\n  my_f <- tempfile(pattern = 'temp', fileext = '.xlsx')\n  library(writexl) \n  time.xlsx <- system.time({\n    write_xlsx(my_df, my_f)\n  })['elapsed']\n  \n  size.xlsx <- file.size(my_f)/1000000\n  \n  # fst\n  library(fst)\n  my_f <- tempfile(pattern = 'temp', fileext = '.fst')\n  time.fst <- system.time({\n    write_fst(my_df, my_f)\n  })['elapsed']\n  \n  size.fst <- file.size(my_f)/1000000\n  \n  print(c(size.csv, size.rds, size.xlsx, size.fst))\n  \n  print(c(time.csv, time.rds, time.xlsx, time.fst))\n  \n  tab <- tibble(Result = c('csv', 'rds', 'xlsx', 'fst'), \n                Size =  c(size.csv, size.rds, size.xlsx, size.fst),\n                Time = c(time.csv, time.rds, time.xlsx, time.fst))\n  \n  return(tab)\n}\n\nmy_N <- 10000\n\ntab <- do_tests(my_N)\nprint(tab)\n\nmy_msg <- paste0('The format with largest disk space for N = ', my_N, ' is ', \n                 tab$Result[which.max(tab$Size)], '.')\nmessage(my_msg)"},{"path":"importacao-exportacao.html","id":"q.2-3","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"Q.2","text":"Melhore o código anterior com mensuração tempo de execução necessário para gravar os dados nos diferentes formatos. Qual formato teve gravação mais rápida? Dica: use função system.time ou pacote tictoc para calcular os tempos de execução.\n\nSolução\n\n","code":"# do notice that this chunk requires the execution of previous solution\nmy_msg <- paste0('The format with least execution time for N = ', my_N, ' is ', \n                 tab$Result[which.min(tab$Time)], '.')\nmessage(my_msg)"},{"path":"importacao-exportacao.html","id":"q.3-2","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"Q.3","text":"Para o código anterior, redefina o valor de my_N para 1000000. Esta mudança modifica respostas das duas últimas perguntas?\n\nSolução\n\n","code":"# do notice that this chunk requires the execution of previous solution\nmy_N <- 1000000\n\ntab <- do_tests(my_N)\nprint(tab)\n\nmy_msg <- paste0('The format with largest disk space for N = ', my_N, ' is ', \n                 tab$Result[which.max(tab$Size)], '.')\n\nmessage(my_msg)\n\nmy_msg <- paste0('The format with least execution time for N = ', my_N, ' is ', \n                 tab$Result[which.min(tab$Time)], '.')\nmessage(my_msg)"},{"path":"importacao-exportacao.html","id":"q.4-2","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"Q.4","text":"Use função adfeR::get_data_file para acessar o arquivo SP500.csv repositório de dados livro. Importe o conteúdo arquivo R com função readr::read_csv. Quantas linhas existem dataframe resultante?\n\nSolução\n\n","code":"my_f <- adfeR::get_data_file('SP500.csv')\n\ndf_SP500 <- readr::read_csv(my_f, \n                     col_types = readr::cols())\n\nmy_msg <- paste0('There are ', nrow(df_SP500), ' rows and ', \n                 ncol(df_SP500), ' columns in file ', basename(my_f))\nmessage(my_msg)\n\nmy_sol <- nrow(df_SP500)"},{"path":"importacao-exportacao.html","id":"q.5-2","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"Q.5","text":"link https://eeecon.uibk.ac./~zeileis/grunfeld/Grunfeld.csv você encontrará um arquivo .csv para os dados Grunfeld. Esta é uma tabela particularmente famosa devido ao seu uso como dados de referência em modelos econométricos. Usando função readr::read_csv, leia este arquivo usando o link direto como entrada em read_csv. Quantas colunas você encontra dataframe resultante?\n\nSolução\n\n","code":"library(tidyverse)\n\nmy_url <- 'https://eeecon.uibk.ac.at/~zeileis/grunfeld/Grunfeld.csv'\n\ndf_grunfeld <- read_csv(my_url, col_types = cols())\n\nmy_sol <- ncol(df_grunfeld)"},{"path":"importacao-exportacao.html","id":"q.6-2","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"Q.6","text":"Use função adfeR::get_data_file para acessar o arquivo example_tsv.csv repositório de dados livro. Note que colunas dos dados estão separadas pelo símbolo de tabulação ('\\t'). Após ler o manual readr::read_delim, importe informações deste arquivo para o seu computador. Quantas linhas o arquivo contém?\n\nSolução\n\n","code":"library(tidyverse)\n\nmy_f <- adfeR::get_data_file('example_tsv.csv')\n\ndf_tsv <- read_delim(my_f, delim = '\\t', col_types = cols())\n\nmy_sol <- nrow(df_tsv)\n\n#check_answers(my_answers)"},{"path":"importacao-exportacao.html","id":"q.7-2","chapter":"Capítulo 4 Importação e Exportação de Dados Locais","heading":"Q.7","text":"pacote livro existe um arquivo de dados chamado 'funky_csv2.csv'. Este possui um formato particularmente bizarro para os dados. Abra o mesmo em um editor de texto e procure entender como colunas são separadas e qual o símbolo para o decimal. Após isso, veja entradas da função read.table e importe tabela na sessão R. Caso somarmos o número de linhas com o número de colunas da tabela importada, qual o resultado?\n\nSolução\n\n","code":"library(tidyverse)\n\nmy_f <- adfeR::get_data_file('funky_csv2.csv')\n\ndf_funky <- read.table(file = my_f, \n           dec = '?', \n           skip = 7, \n           sep = '|', \n           header = TRUE)\n\nmy_sol <- nrow(df_funky) + ncol(df_funky)"},{"path":"importacao-pacotes.html","id":"importacao-pacotes","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"Capítulo 5 Importação de Dados via Pacotes","text":"Uma das grandes vantagens de se utilizar o R é quantidade de dados que podem ser importados através da internet. Isso é especialmente prático pois uma base de dados pode ser atualizada através de um simples comando, evitando o tedioso trabalho de coleta manual. Ao usarmos pacotes para importar dados, esta etapa da pesquisa se torna reproduzível e mais rápida, facilitando o compartilhamento e futura execução nosso código.Neste capítulo vou descrever e dar exemplos de importação de dados para os mais importantes e estáveis pacotes especializados na importação de para dados financeiros e econômicos Brasil e exterior. lista inclui:GetQuandlData (M. S. Perlin 2019)\nImporta dados econômicos e financeiros vasto repositório de dados da plataforma Quandl.\nBatchGetSymbols (M. Perlin 2022a)\nImporta dados de preços diários de ações e índices Yahoo Finance.\nGetTDData (M. Perlin 2022c)\nImporta dados de títulos de dívida pública Brasil diretamente site Tesouro Direto.\nGetBCBData (M. Perlin 2022b)\nImporta dados grande repositório de séries temporais Banco Central Brasil, local obrigatório para qualquer economista que trabalha com dados.\nGetDFPData2 (M. Perlin Kirch 2022a)\nImporta dados sistema DFP – Demonstrativos Financeiros Padronizados – de empresas negociadas na B3, bolsa Brasileira. O repositório inclui documentos financeiros tal como o balanço patrimonial, demonstrativos de resultados, entre vários outros.\nGetFREData (M. Perlin Kirch 2022b)\nImporta dados sistema FRE – Formulário de Referência – da bolsa Brasileira. Esta inclui diversos eventos e informações corporativas tal como composição conselho e diretoria, remuneração dos conselheiros, entre outras.\n","code":""},{"path":"importacao-pacotes.html","id":"quandl","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"5.1 Pacote GetQuandlData","text":"Quandl é um repositório de dados abrangente, fornecendo acesso uma série de tabelas gratuitas e pagas disponibilizadas por diversas instituições de pesquisa. Como ponto inicial, recomendo fortemente que você navegue nas tabelas disponíveis site da Quandl18. Verás que uma grande proporção dos repositórios de dados abertos em economia e finanças também estão disponíveis Quandl. Pacote Quandl (Raymond McTaggart, Gergely Daroczi, Clement Leung 2021) é extensão oficial oferecida pela empresa e disponível CRAN. entanto, o pacote tem alguns problemas quanto estrutura de dados de saída19 e, para resolver, escrevi o meu próprio pacote GetQuandlData (M. S. Perlin 2019). O diferencial de GetQuandlData é saída de dados já estruturados, prontos para uma posterior análise.primeira e obrigatória etapa uso de GetQuandlData é registrar o usuário site. Logo em seguida, vá para Account Settings e procure pela seção API Key. Este local deve mostrar uma senha, tal como Asv8Ac7zuZzJSCGxynfG. Copie o texto para área de transferência (control + c) e, R, defina um objeto de contendo o conteúdo copiado da seguinte maneira:Essa chave API é exclusiva para cada usuário e apresentada aqui não funcionará seu computador. Você precisará obter sua própria chave de API para executar os exemplos livro. Depois de encontrar e definir sua chave, vá para o site Quandl e use caixa de pesquisa para procurar o símbolo da série temporal de interesse.Como exemplo, usaremos dados preço ouro mercado Londrino. O código para esta série Quandl é 'LBMA/GOLD'. Observe que estrutura de um identificador de tabelas Quandl é sempre mesma, com o nome banco de dados primeiro e o nome da tabela depois, separados por uma barra (/).Agora, com chave API e o identificador da tabela, usamos função get_Quandl_series para baixar os dados de 1980-01-01 2021-01-01: Observe como definimos o nome da série temporal em linha id_in =  c('GOLD' = 'LBMA/GOLD'). O nome elemento – GOLD – se torna uma coluna chamada series_name dataframe de saída. Se tivéssemos mais séries temporais, elas seriam empilhadas na mesma tabela.Para verificar os dados, vamos criar um gráfico com os preços ouro ao longo tempo. Aqui, usaremos o pacote ggplot2 para criar figura. Por enquanto você não precisa se preocupar com o código de criação de gráficos. Teremos o capítulo 10 inteiro dedicado ao tópico.De modo geral, os preços ouro permaneceram relativamente estáveis entre 1980 e 2000, atingindo um pico após 2010. Uma possível explicação é maior demanda por ativos mais seguros, como o ouro, após crise financeira de 2009. entanto, o ouro nunca foi um investimento eficiente longo prazo. Para mostrar isso, vamos calcular seu retorno anual composto de 1980-01-02 2022-08-03:Encontramos o resultado de que os preços ouro em USD apresentam um retorno composto equivalente 2,74% ao ano. Este não é um resultado de investimento impressionante de forma alguma. Como comparação, inflação anual para os EUA mesmo período é de 3,22% ao ano. Isso significa que, ao comprar ouro em 1980, o investidor recebeu menos que inflação como retorno nominal, resultando em perda de poder de compra.","code":"\n# set FAKE api key to quandl\nmy_api_key <- 'Asv8Ac7zuZzJSCGxynfG'\nlibrary(GetQuandlData)\nlibrary(tidyverse)\n\n# set symbol and dates\nmy_symbol <- c('GOLD' = 'LBMA/GOLD')\nfirst_date <- '1980-01-01'\nlast_date <- '2021-01-01'\n\n# get data!\ndf_quandl <- get_Quandl_series(id_in = my_symbol,\n                               api_key = my_api_key, \n                               first_date = first_date,\n                               last_date = last_date)\n\n# check it\nglimpse(df_quandl)R> Rows: 10,763\nR> Columns: 9\nR> $ `USD (AM)`  <chr> \"1766.6\", \"1772.9\", \"1766.75\", \"1758.9…\nR> $ `USD (PM)`  <chr> \"1761.25\", \"1779.75\", \"1772.4\", \"1753.…\nR> $ `GBP (AM)`  <chr> \"1450.03\", \"1452.36\", \"1443.26\", \"1447…\nR> $ `GBP (PM)`  <chr> \"1451.62\", \"1457.26\", \"1444.86\", \"1451…\nR> $ `EURO (AM)` <chr> \"1734.09\", \"1732.3\", \"1722.23\", \"1724.…\nR> $ `EURO (PM)` <chr> \"1735.54\", \"1743.62\", \"1727.91\", \"1725…\nR> $ series_name <chr> \"GOLD\", \"GOLD\", \"GOLD\", \"GOLD\", \"GOLD\"…\nR> $ ref_date    <date> 2022-08-03, 2022-08-02, 2022-08-01, 2…\nR> $ id_quandl   <chr> \"LBMA/GOLD\", \"LBMA/GOLD\", \"LBMA/GOLD\",…\n# sort the rows\ndf_quandl <- df_quandl %>%\n  mutate(USD = as.numeric(`USD (AM)`)) %>%\n  arrange(ref_date)\n\ntotal_ret <- last(df_quandl$USD)/first(df_quandl$USD) - 1\ntotal_years <- as.numeric(max(df_quandl$ref_date) - \n                            min(df_quandl$ref_date) )/365\n\ncomp_ret_per_year <- (1 + total_ret)^(1/total_years) - 1\n\nprint(comp_ret_per_year)R> [1] 0.02737004"},{"path":"importacao-pacotes.html","id":"importando-múltiplas-séries","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"5.1.1 Importando Múltiplas Séries","text":"Ao solicitar várias séries temporais Quandl, pacote GetQuandlData empilha todos os dados em um único dataframe, tornando mais fácil trabalhar com ferramentas tidyverse. Como exemplo, vamos olhar para o banco de dados RATEINF, o qual contém séries temporais das taxas de inflação ao redor mundo. Primeiro, precisamos ver quais são os conjuntos de dados disponíveis:Coluna name contém descrição das tabelas com os seguintes nomes:O que estamos buscando são séries 'Inflation YOY - *', quais contém inflação ano-ao-ano (Year Year – YOY) de diferentes países. Vamos agora filtrar o dataframe para manter apenas séries de inflação anual para quatro países selecionados:Agora importamos séries usando get_Quandl_series:Por fim, construimos um gráfico para vizualizar séries de inflação:Como podemos ver, com algumas linhas de código R conseguimos importar dados atualizados da inflação de diferentes regiões mundo. O retorno de um dataframe formato empilhado facilitou o processo de análise pois essa é estrutura de dados que o ggplot2 espera.","code":"\nlibrary(GetQuandlData)\nlibrary(tidyverse)\n\n# databse to get info\ndb_id <- 'RATEINF'\n\n# get info \ndf_db <- get_database_info(db_id, my_api_key)\n\nglimpse(df_db)R> Rows: 26\nR> Columns: 8\nR> $ code         <chr> \"CPI_ARG\", \"CPI_AUS\", \"CPI_CAN\", \"CPI…\nR> $ name         <chr> \"Consumer Price Index - Argentina\", \"…\nR> $ description  <chr> \"Please visit <a href=http://www.rate…\nR> $ refreshed_at <dttm> 2020-10-10 02:03:32, 2022-11-19 02:0…\nR> $ from_date    <date> 1988-01-31, 1948-09-30, 1989-01-31, …\nR> $ to_date      <date> 2013-12-31, 2022-09-30, 2022-10-31, …\nR> $ quandl_code  <chr> \"RATEINF/CPI_ARG\", \"RATEINF/CPI_AUS\",…\nR> $ quandl_db    <chr> \"RATEINF\", \"RATEINF\", \"RATEINF\", \"RAT…\nprint(unique(df_db$name))R>  [1] \"Consumer Price Index - Argentina\"  \nR>  [2] \"Consumer Price Index - Australia\"  \nR>  [3] \"Consumer Price Index - Canada\"     \nR>  [4] \"Consumer Price Index - Switzerland\"\nR>  [5] \"Consumer Price Index - Germany\"    \nR>  [6] \"Consumer Price Index - Euro Area\"  \nR>  [7] \"Consumer Price Index - France\"     \nR>  [8] \"Consumer Price Index - UK\"         \nR>  [9] \"Consumer Price Index - Italy\"      \nR> [10] \"Consumer Price Index - Japan\"      \nR> [11] \"Consumer Price Index - New Zealand\"\nR> [12] \"Consumer Price Index - Russia\"     \nR> [13] \"Consumer Price Index - USA\"        \nR> [14] \"Inflation YOY - Argentina\"         \nR> [15] \"Inflation YOY - Australia\"         \nR> [16] \"Inflation YOY - Canada\"            \nR> [17] \"Inflation YOY - Switzerland\"       \nR> [18] \"Inflation YOY - Germany\"           \nR> [19] \"Inflation YOY - Euro Area\"         \nR> [20] \"Inflation YOY - France\"            \nR> [21] \"Inflation YOY - UK\"                \nR> [22] \"Inflation YOY - Italy\"             \nR> [23] \"Inflation YOY - Japan\"             \nR> [24] \"Inflation YOY - New Zealand\"       \nR> [25] \"Inflation YOY - Russia\"            \nR> [26] \"Inflation YOY - USA\"\nselected_series <- c('Inflation YOY - USA',\n                     'Inflation YOY - Canada',\n                     'Inflation YOY - Euro Area',\n                     'Inflation YOY - Australia')\n\n# filter selected countries\nidx <- df_db$name %in% selected_series\ndf_db <- df_db[idx, ]\nmy_id <- df_db$quandl_code\nnames(my_id) <- df_db$name\nfirst_date <- '2010-01-01'\nlast_date <- '2021-01-01'\n\ndf_inflation <- get_Quandl_series(id_in = my_id, \n                                  api_key = my_api_key,\n                                  first_date = first_date,\n                                  last_date = last_date)\n\nglimpse(df_inflation)R> Rows: 500\nR> Columns: 4\nR> $ series_name <chr> \"Inflation YOY - Australia\", \"Inflatio…\nR> $ ref_date    <date> 2022-06-30, 2022-03-31, 2021-12-31, 2…\nR> $ value       <dbl> 6.1, 5.1, 3.5, 3.0, 3.8, 1.1, 0.9, 0.7…\nR> $ id_quandl   <chr> \"RATEINF/INFLATION_AUS\", \"RATEINF/INFL…"},{"path":"importacao-pacotes.html","id":"pacote-batchgetsymbols","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"5.2 Pacote BatchGetSymbols","text":"Pacote BatchGetSymbols faz comunicação R com os dados financeiros disponíveis Yahoo Finance. Essa gigantesca base de dados inclui valores agregados de preços e volumes negociados de ações na B3 e outras bolsas internacionais na frequência diária. Tudo que se precisa saber para acessar base de dados são os identificadores das ações (tickers) e um período de tempo.Os diferenciais BatchGetSymbols são:Limpeza e organização: todos os dados financeiros de diferentes tickers são mantidos mesmo dataframe, facilitando análise futura com ferramentas tidyverse.Controle de erros de importação: todos erros de download são registrados na saída programa. Caso uma ação em particular não exista Yahoo Finance, esta será ignorada e apenas demais disponíveis serão retornadas na saída código;Comparação de datas um benchmark: os dados de ativos individuais são comparados com dados disponíveis para um ativo benchmark, geralmente um índice de mercado. Caso o número de datas faltantes seja maior que um determinado limite imposto pelo usuário, ação é retirada dataframe final.Uso de sistema de cache: momento de acesso aos dados, os mesmos são salvos localmente computador usuário e são persistentes para cada sessão. Caso o usuário requisitar os mesmos dados na mesma sessão R, o sistema de cache será utilizado. Se os dados desejados não estão disponíveis cache, função irá comparar e baixar apenas informações que faltam. Isso aumenta significativamente velocidade de acesso aos dados, ao mesmo tempo em que minimiza o uso da conexão Internet;\nDesde versão 2.6 (2020-11-22) de BatchGetSymbols pasta\ndefault de cache BatchGetSymbols se localiza \ndiretório temporário da sessão R. Assim, o cache é persistente apenas\npara sessão usuário. Esta mudança foi motivada por quebras\nestruturais nos dados Yahoo Finance, onde os dados passados\nregistrados em cache não mais estavam corretos devido eventos\ncoporativos. O usuário, porém, pode trocar pasta de cache usando \nentrada cache.folder.\nAcesso tickers em índices de mercado: O pacote inclui funções para baixar composição dos índices Ibovespa, SP500 e FTSE100. Isso facilita importação de dados para uma grande quantidade de ações. Podes, por exemplo, baixar cotações de todas ações que fazem parte de certo índice.Processamento paralelo: Caso o usuário estiver baixando um grande volume de dados Yahoo Finance, uma opção para execução paralela está disponível. Isto é, ao invés de usar apenas um núcleo na requisição dos dados, usamos vários ao mesmo tempo. O efeito prático é, dependendo número de núcleos computador, uma diminuição significativa tempo total de importação.Flexibilidade de formato: O pacote também oferece funções para modificar o formato dos dados. Caso o usuário deseje uma saída dataframe formato largo, onde tickers são colunas e linhas os preços/retornos, basta chamar função BatchGetSymbols::reshape.wide. Da mesma forma, uma transformação temporal também é possível. Se o usuário desejar dados na frequência semanal, mensal ou anual, basta indicar na entrada freq.data da função.Como exemplo de uso, vamos baixar dados financeiros referentes quatro ações último ano (360 dias) usando função de mesmo nome pacote. Os tickers de cada ação podem ser encontrados nos próprios sites Yahoo Finance. Note que adicionamos texto .SA cada um deles. Essa é uma notação específica site e vale para qualquer ação Brasileira.Na chamada da função BatchGetSymbols, utilizamos um valor de 0.95 (95%) para o input thresh.bad.data e '^BVSP' para bench.ticker. Isso faz com que função compare datas obtidas para cada ativo em relação ao nosso benchmark, o índice Ibovespa, cujo ticker Yahoo Finance é ^BVSP. Se, durante o processo de importação, uma ação individual não apresenta mais de 95% de casos válidos em relação ao benchmark, esta é retirada da saída.\nsaída de BatchGetSymbols é um objeto tipo lista, ainda não visto livro. Por enquanto, tudo que precisas saber é que uma lista é um objeto flexível, acomodando outros objetos em sua composição. O acesso cada elemento de uma lista pode ser feito pelo operador $. capítulo 6 iremos estudar melhor esta classe de objetos.\nNote que entradas da função\nBatchGetSymbols::BatchGetSymbols usam o “.” em seus nomes,\ntal como thresh.bad.data, e bench.ticker,\nenquanto o livro está escrito usando o traço baixo (_), tal\ncomo thresh_bad_data, e bench_ticker. Esta\ndiferença pode resultar em problemas se, na falta de atenção, o usuário\ntrocar um pelo outro. Como regra, procure dar prioridade para o uso de\ntraço baixo nos nomes de objetos. Infelizmente algumas funções escritas\npassado acabaram ficando com estrutura antiga e, para não\nprejudicar os usuários, os nomes das entradas foram mantidos.\nVoltando ao nosso exemplo, função BatchGetSymbols retorna uma lista com dois elementos: um dataframe com o resultado processo de importação – df_control – e outro dataframe com os dados das ações – df_tickers. Vamos checar o conteúdo primeiro dataframe.Objeto df.control mostra que todos tickers foram válidos, com um total de 246 observações para cada ativo. Note que datas batem 100% com o Ibovespa (coluna perc.benchmark.dates).Quanto aos dados financeiros, esses estão contidos em l_out$df.tickers:Como esperado, informação sobre preços, retornos e volumes está lá, com devidas classes de colunas: dbl (double) para valores numéricos e date para datas. Observe que uma coluna chamada ticker também está incluída. Essa indica em que linhas da tabela os dados de uma ação começam e terminam. Mais tarde, capítulo 9, usaremos essa coluna para fazer diversos cálculos para cada ação.","code":"\nlibrary(BatchGetSymbols)\nlibrary(dplyr)\n\n# set tickers\nmy_tickers <- c('PETR4.SA', 'CIEL3.SA',\n                'GGBR4.SA', 'GOAU4.SA')\n\n# set dates and other inputs\nfirst_date <- Sys.Date()-360\nlast_date <- Sys.Date()\nthresh_bad_data <- 0.95   # sets percent threshold for bad data\nbench_ticker <- '^BVSP'   # set benchmark as ibovespa\n\nl_out <- BatchGetSymbols(tickers = my_tickers,\n                         first.date = first_date,\n                         last.date = last_date,\n                         bench.ticker = bench_ticker,\n                         thresh.bad.data = thresh_bad_data)\n# print result of download process\nprint(l_out$df.control)R> # A tibble: 4 × 6\nR>   ticker   src   download.status total.obs perc.be…¹ thres…²\nR>   <chr>    <chr> <chr>               <int>     <dbl> <chr>  \nR> 1 PETR4.SA yahoo OK                    246         1 KEEP   \nR> 2 CIEL3.SA yahoo OK                    246         1 KEEP   \nR> 3 GGBR4.SA yahoo OK                    246         1 KEEP   \nR> 4 GOAU4.SA yahoo OK                    246         1 KEEP   \nR> # … with abbreviated variable names ¹​perc.benchmark.dates,\nR> #   ²​threshold.decision\n# print df_tickers\nglimpse(l_out$df.tickers)R> Rows: 984\nR> Columns: 10\nR> $ price.open          <dbl> 29.36, 29.30, 29.84, 26.99, 28…\nR> $ price.high          <dbl> 29.82, 29.64, 30.67, 28.49, 28…\nR> $ price.low           <dbl> 28.81, 28.86, 29.48, 26.20, 28…\nR> $ price.close         <dbl> 29.47, 29.43, 29.60, 28.36, 28…\nR> $ volume              <dbl> 84672200, 129384600, 135078600…\nR> $ price.adjusted      <dbl> 15.33113, 15.31032, 15.39875, …\nR> $ ref.date            <date> 2021-11-29, 2021-11-30, 2021-…\nR> $ ticker              <chr> \"PETR4.SA\", \"PETR4.SA\", \"PETR4…\nR> $ ret.adjusted.prices <dbl> NA, -0.0013573042, 0.005776432…\nR> $ ret.closing.prices  <dbl> NA, -0.0013572786, 0.005776418…"},{"path":"importacao-pacotes.html","id":"baixando-dados-da-composição-do-ibovespa","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"5.2.1 Baixando Dados da Composição do Ibovespa","text":"Outra função útil pacote é BatchGetSymbols::GetIbovStocks, qual importa composição atual índice Ibovespa diretamente site da B3. Esse índice é um termômetro mercado local e ações que o compõem são selecionadas devido sua alta negociabilidade. Portanto, sequenciando o uso de GetIbovStocks e BatchGetSymbols, podemos facilmente baixar uma volumosa quantidade de dados de ações para o mercado Brasileiro. Considere o seguinte fragmento de código, onde realizamos essa operação: Note que utilizamos função paste0 para adicionar o texto '.SA' para cada ticker em df_ibov$tickers. saída código anterior não foi mostrada para não encher páginas e páginas com mensagens processamento. Destaco que, caso necessário, poderíamos facilmente exportar os dados em l_out para um arquivo .rds e futuramente carregá-los localmente para realizar algum tipo de análise.\nSaiba que os preços Yahoo Finance não são ajustados \ndividendos. O ajuste realizado pelo sistema é apenas para\ndesdobramentos das ações. Isso significa que, ao olhar séries de preços\nem um longo período, existe um viés de retorno para baixo. Ao comparar\ncom outro software que faça o ajustamento dos preços por dividendos,\nverás uma grande diferença na rentabilidade total das ações. Como regra,\nem uma pesquisa formal, evite usar dados de ações individuais \nYahoo Finance para períodos longos. excessão é para índices\nfinanceiros, tal como o Ibovespa, onde os dados Yahoo Finance são\nbastante confiáveis uma vez que índices não sofrem os mesmos\najustamentos que ações individuais.\n","code":"\nlibrary(BatchGetSymbols)\n\n# set tickers\ndf_ibov <- GetIbovStocks()\nmy_tickers <- paste0(df_ibov$tickers,'.SA')\n\n\n# set dates and other inputs\nfirst_date <- Sys.Date()-30\nlast_date <- Sys.Date()\nthresh_bad_data <- 0.95   # sets percent threshold for bad data\nbench_ticker <- '^BVSP'   # set benchmark as ibovespa\ncache_folder <- 'data/BGS_Cache' # set folder for cache\n\n\nl_out <- BatchGetSymbols(tickers = my_tickers,\n                         first.date = first_date,\n                         last.date = last_date,\n                         bench.ticker = bench_ticker,\n                         thresh.bad.data = thresh_bad_data,\n                         cache.folder = cache_folder)"},{"path":"importacao-pacotes.html","id":"pacote-gettddata","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"5.3 Pacote GetTDData","text":"Arquivos com informações sobre preços e retornos de títulos emitidos pelo governo brasileiro podem ser baixados manualmente site Tesouro Nacional. O tesouro direto é um tipo especial de mercado onde pessoa física pode comprar e vender dívida pública. Os contratos de dívida vendidos na plataforma são bastante populares devido atratividade das taxas de retorno e alta liquidez oferecida ao investidor comum.Pacote GetTDData importa os dados das planilhas em Excel site Tesouro Nacional e os organiza. O resultado é um dataframe com dados empilhados. Como exemplo, vamos baixar dados de um título prefixado tipo LTN com vencimento em 2021-01-01. Esse é o tipo de contrato de dívida mais simples que o governo brasileiro emite, não pagando nenhum cupom20 durante sua validade e, na data de vencimento, retorna 1.000 R$ ao comprador. Para baixar os dados da internet, basta usar o código seguir: Vamos checar o conteúdo dataframe:Temos informações sobre data de referência (ref.date), retorno contratado (yield.bid), preço contrato na data (price.bid), nome contrato (asset.code) e dia de maturidade (matur.date). gráfico seguir checamos os dados:Como esperado de um título de dívida pré-fixado, os preços possuem uma tendência positiva ao longo tempo, chegando ao valor esperado de 1000 R$ vencimento em 2021-01-01. Podemos também visualizar mudanças yield título:Os retornos título tiveram forte queda ao longo dos anos. Este resultado é esperado pois o juros mercado – taxa SELIC – caiu bastante nos últimos cinco anos.funções GetTDData também funcionam com vários argumentos como asset.codes e maturity. Suponhamos que desejamos visualizar todos os preços de todos os prazos disponíveis para títulos tipo LTN partir de 2010. Tudo o que precisamos fazer é adicionar o valor NULL ao argumento maturity e filtrar datas:Após importação das informações, plotamos os preços dos diferentes ativos:Note como todos contratos tipo LTN terminam com valor R$ 1.000 em sua data de expiração e possuem uma dinâmica linear de crescimento de preço ao longo tempo.Outra funcionalidade pacote GetTDData é o acesso curva de juros atual sistema financeiro brasileiro diretamente site da Anbima. Para isso, basta utilizar função get.yield.curve:Os dados incluem curva de juros nominal, juros real e da inflação. Para melhor visualizar informações, vamos plotá-las em um gráfico:curva de juros é uma ferramente utilizada mercado financeiro com o propósito de representar graficamente expectatica mercado sobre juros futuro. Baseada nos preços dos títulos públicos, calcula-se e extrapola-se o juros implícito para cada período futuro. Uma curva ascendente, o formato esperado, indica que é mais caro (maior o juro) tomar dinheiro emprestado longo prazo.","code":"\nlibrary(GetTDData)\n\nasset_codes <- 'LTN'   # Identifier of assets\nmaturity <- '010121'  # Maturity date as string (ddmmyy)\n\n# download\nmy_flag <- download.TD.data(asset.codes = asset_codes)\n\n# read files\ndf_TD <- read.TD.files()\n# check content\nglimpse(df_TD)R> Rows: 24,733\nR> Columns: 5\nR> $ ref.date   <date> 2002-03-18, 2002-03-19, 2002-03-20, 20…\nR> $ yield.bid  <dbl> 0.1977, 0.1975, 0.1967, 0.2005, 0.1983,…\nR> $ price.bid  <dbl> 720.96, 721.70, 723.09, 719.48, 722.38,…\nR> $ asset.code <chr> \"LTN 070104\", \"LTN 070104\", \"LTN 070104…\nR> $ matur.date <date> 2004-01-07, 2004-01-07, 2004-01-07, 20…\nlibrary(GetTDData)\n\nasset_codes <- 'LTN'   # Name of asset\nmaturity <- NULL      # = NULL, downloads all maturities\n\n# download data\nmy_flag <- download.TD.data(asset.codes = asset_codes,\n                            do.clean.up = F)\n\n# reads data\ndf_TD <- read.TD.files()\n\n# remove data prior to 2010\ndf_TD <- dplyr::filter(df_TD,\n                       ref.date >= as.Date('2010-01-01'))\nlibrary(GetTDData)\n\n# get yield curve\ndf_yield <- get.yield.curve()\n\n# check result\ndplyr::glimpse(df_yield)R> Rows: 114\nR> Columns: 5\nR> $ n.biz.days   <dbl> 126, 252, 378, 504, 630, 756, 882, 10…\nR> $ type         <chr> \"real_return\", \"real_return\", \"real_r…\nR> $ value        <dbl> 6.1355, 6.6490, 6.7057, 6.6214, 6.512…\nR> $ ref.date     <date> 2023-05-24, 2023-11-23, 2024-05-27, …\nR> $ current.date <date> 2022-11-22, 2022-11-22, 2022-11-22, …"},{"path":"importacao-pacotes.html","id":"pacote-getbcbdata","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"5.4 Pacote GetBCBData","text":"O Banco Central Brasileiro (BCB) disponibiliza em seu Sistema de Séries Temporais (SGS) uma vasta quantidade de tabelas relativas economia Brasil. Mais importante, estas tabelas são atualizadas constantemente e o acesso é gratuito e sem necessidade de registro.Como um exemplo, vamos usar o pacote para estudar inadimplência de crédito sistema financeiro Brasileiro. O primeiro passo uso de GetBCBData é procurar o símbolo da série de interesse. Acessando o sistema de séries temporais BCB, vemos que o código identificador para o percentual total de inandimplência Brasil é 21082.código, basta indicar série de interesse e o período de tempo desejado:Note que indicamos o nome da coluna na própria definição da entrada id. Assim, coluna series.name toma o nome de perc.default. Esta configuração é importante pois irá diferenciar os dados caso da importação de diversas séries diferentes. O gráfico apresentado seguir mostra o valor da série tempo:Como podemos ver, percentagem de inadimplência aumentou partir de 2015. Para ter uma idéia mais clara problema, vamos incluir gráfico percentagem para pessoa física e pessoa jurídica. Olhando novamente o sistema BCB, vemos que o símbolos de interesse são 21083 e 21084, respectivamente. O próximo código baixa os dados das duas séries.diferença na saída código anterior é que agora temos duas séries temporais empilhadas mesmo dataframe. Partimos então para visualização das sériesComo podemos ver, inadimplência de crédito para pessoa física aumentou muito mais que para pessoa jurídica (empresas) nos últimos anos. Poderiámos, facilmente, integrar o código anterior para uma análise mais completa dos dados em algum problema de pesquisa.\nO sistema BCB-SGS é local obrigatório para qualquer economista sério.\nquantidade e variedade de dados é imensa. Podes usar os dados \nsistema para automatizar qualquer tipo de relatório econômico.\n","code":"\nlibrary(GetBCBData)\nlibrary(dplyr)\n\n# set ids and dates\nid_series <- c(perc_default = 21082)\nfirst_date = '2010-01-01'\n\n# get series from bcb\ndf_cred <- gbcbd_get_series(id = id_series,\n                            first.date = first_date,\n                            last.date = Sys.Date(), \n                            use.memoise = FALSE)R> \nR> Fetching perc_default [21082] from BCB-SGS from Online API \nR>   Found 139 observations\n# check it\nglimpse(df_cred)R> Rows: 139\nR> Columns: 4\nR> $ ref.date    <date> 2011-03-01, 2011-04-01, 2011-05-01, 2…\nR> $ value       <dbl> 3.17, 3.24, 3.37, 3.32, 3.42, 3.45, 3.…\nR> $ id.num      <dbl> 21082, 21082, 21082, 21082, 21082, 210…\nR> $ series.name <chr> \"perc_default\", \"perc_default\", \"perc_…\n# set ids\nid.series <- c(credit_default_people = 21083,\n               credit_default_companies = 21084)\nfirst.date = '2010-01-01'\n\n# get series from bcb\ndf_cred <- gbcbd_get_series(id = id.series,\n                            first.date = first.date,\n                            last.date = Sys.Date(), \n                            use.memoise = FALSE)R> \nR> Fetching credit_default_people [21083] from BCB-SGS from Online API \nR>   Found 139 observations\nR> Fetching credit_default_companies [21084] from BCB-SGS from Online API \nR>   Found 139 observations\n# check output\nglimpse(df_cred)R> Rows: 278\nR> Columns: 4\nR> $ ref.date    <date> 2011-03-01, 2011-04-01, 2011-05-01, 2…\nR> $ value       <dbl> 1.96, 2.04, 2.15, 2.09, 2.18, 2.15, 2.…\nR> $ id.num      <dbl> 21083, 21083, 21083, 21083, 21083, 210…\nR> $ series.name <chr> \"credit_default_people\", \"credit_defau…"},{"path":"importacao-pacotes.html","id":"pacote-getdfpdata2","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"5.5 Pacote GetDFPData2","text":"Pacote GetDFPData2 (M. Perlin Kirch 2022a) é uma evolução pacote GetDFPData (M. Perlin 2021) e fornece uma interface aberta para todas demonstrações financeiras distribuídas pela B3 e pela CVM nos sistemas DFP (dados anuais) e ITR (dados trimestrais). Ele não só faz o download dos dados, mas também ajusta à inflação e torna tabelas prontas para pesquisa dentro de um formato tabular. Os diferenciais pacote em relação outros distribuidores de dados comerciais são: livre acesso, facilidade para baixar dados em larga escala e variedade de dados disponíveis.\nUma versão web de GetDFPData2 foi desenvolvida e\npublicada na internet como um aplicativo shiny em http://www.msperlin.com/shiny/GetDFPData/.\nEsse fornece uma interface gráfica direta e simples para principais\nfuncionalidade pacote. Usuários podem selecionar empresas\ndisponíveis, o intervalo de datas e baixar os dados como uma planilha \nExcel ou um arquivo compactado com vários arquivos csv.\n\nSaiba também que dados históricos completos e atualizados partir de\n2010 DFP e ITR estão disponibilizados na seção Data meu site pessoal.\nO ponto de partida uso de GetDFPData2 é baixar informações atuais sobre empresas disponíveis. O acesso tabela é possível com função get_info_companies: Essa tabela disponibiliza os identificadores numéricos das empresas, setores de atividades, atual segmento de governança, tickers negociados na bolsa e situação atual (ativa ou não). O número atual de empresas ativas e inativas, partir de 2022-11-23, está disponível na coluna SIT_REG. Observa-se 786 empresas ativas e 1771 canceladas. Essa é uma excelente fonte de informação para um estudo exploratório. Pode-se facilmente filtrar empresas para datas, setores, tickers ou segmentos de governança corporativa.Toda empresa banco de dados é identificada pelo seu número único da CVM. Função search_company permite que o usuário procure o identificador de uma empresa através de seu nome. Dado um texto de entrada – o nome da empresa –, função procurará uma correspondência parcial com os nomes de todas empresas disponíveis banco de dados. Em seu uso, caracteres latinos e maiúsculas e minúsculas são ignorados. Vamos encontrar o nome oficial nome da Grendene, uma das maiores empresas Brasil. Para isso, basta usar o comando search_company('grendene').Vemos que existe um registro para Grendene: “GRENDENE SA”, com código identificador equivalente 19615. Com o identificador da empresa disponível, usamos função principal pacote, get_dfp_data, para baixar os dados. Definimos o nome oficial da empresa como entrada companies_cvm_codes e o período de tempo como entradas first_year e last_year.mensagens de GetDFPData2::get_dfp_data relatam os estágios processo, desde aquisição de dados da tabela de referência ao download e leitura dos arquivos da B3. Observe que os arquivos de três sistemas são acessados: DFP (Demostrativos Financeiros Padronizados), FRE (Formulário de Referência) e FCA (Formulário Cadastral). Observe também o uso de um sistema de cache, o qual acelera significativamente o uso software ao salvar localmente informações importadas.Explicando demais entradas da função GetDFPData2::get_dfp_data:companies_cvm_codes\nCódigo numérico das empresas (encontrado via GetDFPData2::search_company('ambev'))\ntype_docs\nSímbolo tipo de documento financeiro ser retornado. Definições: ’*’ = retorna todos documentos, ‘BPA’ = Ativo, ‘BPP’ = passivo, ‘DRE’ = demonstrativo de resultados exercício, ‘DFC_MD’ = fluxo de caixa pelo metodo direto, ‘DFC_MI’ = fluxo de caixa pelo metodo indireto, ‘DMPL’ = mutacoes patrimonio liquido, ‘DVA’ = demonstrativo de valor agregado.\ntype_format\nTipo de formato dos documentos: consolidado (‘con’) ou individual (‘ind’). Como regra, dê preferência ao tipo consolidado, o qual incluirá dados completos de subsidiárias.\nfirst_year\nPrimeiro ano para os dados\nlast_year\nÚltimo ano para os dados\nO objeto resultante de get_dfp_data é uma lista com diversas tabelas. Vamos dar uma olhada conteúdo de l_dfp ao buscar os nomes dos itens da lista, limitando o número de caracteres:Como podemos ver, os dados retornados são vastos. Cada item da lista em l_dfp é um tabela indexada ao tempo. explicação de cada coluna não cabe aqui mas, para fins de exemplo, vamos dar uma olhada balanço patrimonial da empresa, disponível em l_dfp$\"DF Consolidado - Balanço Patrimonial Ativo\":exportação dos dados para o Excel também é fácil, basta usar função GetDFPData2::export_xlsx: O arquivo Excel resultante conterá cada tabela de l_dpf em uma aba diferente da planilha, com uma truncagem nos nomes. Podemos checar o resultado com função readxl::excel_sheets:","code":"\nlibrary(GetDFPData2)\n\n# get info for companies in B3\ndf_info <- get_info_companies()R> Fetching info on B3 companiesR>  Dowloading file from CVMR>  File not found, downloading it..R>  SuccessR>  Reading file from CVMR>  Saving cache dataR>  Got 2559 lines for 2425 companies [Actives = 701 Inactives = 1736]\n# check it\nnames(df_info)R>  [1] \"CNPJ\"               \"DENOM_SOCIAL\"      \nR>  [3] \"DENOM_COMERC\"       \"DT_REG\"            \nR>  [5] \"DT_CONST\"           \"DT_CANCEL\"         \nR>  [7] \"MOTIVO_CANCEL\"      \"SIT_REG\"           \nR>  [9] \"DT_INI_SIT\"         \"CD_CVM\"            \nR> [11] \"SETOR_ATIV\"         \"TP_MERC\"           \nR> [13] \"CATEG_REG\"          \"DT_INI_CATEG\"      \nR> [15] \"SIT_EMISSOR\"        \"DT_INI_SIT_EMISSOR\"\nR> [17] \"CONTROLE_ACIONARIO\" \"TP_ENDER\"          \nR> [19] \"LOGRADOURO\"         \"COMPL\"             \nR> [21] \"BAIRRO\"             \"MUN\"               \nR> [23] \"UF\"                 \"PAIS\"              \nR> [25] \"CEP\"                \"DDD_TEL\"           \nR> [27] \"TEL\"                \"DDD_FAX\"           \nR> [29] \"FAX\"                \"EMAIL\"             \nR> [31] \"TP_RESP\"            \"RESP\"              \nR> [33] \"DT_INI_RESP\"        \"LOGRADOURO_RESP\"   \nR> [35] \"COMPL_RESP\"         \"BAIRRO_RESP\"       \nR> [37] \"MUN_RESP\"           \"UF_RESP\"           \nR> [39] \"PAIS_RESP\"          \"CEP_RESP\"          \nR> [41] \"DDD_TEL_RESP\"       \"TEL_RESP\"          \nR> [43] \"DDD_FAX_RESP\"       \"FAX_RESP\"          \nR> [45] \"EMAIL_RESP\"         \"CNPJ_AUDITOR\"      \nR> [47] \"AUDITOR\"\ndf_search <- search_company('grendene')\n\nprint(df_search)R> # A tibble: 1 × 47\nR>   CNPJ      DENOM…¹ DENOM…² DT_REG     DT_CONST   DT_CANCEL\nR>   <chr>     <chr>   <chr>   <date>     <date>     <date>   \nR> 1 89.850.3… GRENDE… GRENDE… 2004-10-26 1971-02-25 NA       \nR> # … with 41 more variables: MOTIVO_CANCEL <chr>,\nR> #   SIT_REG <chr>, DT_INI_SIT <date>, CD_CVM <dbl>,\nR> #   SETOR_ATIV <chr>, TP_MERC <chr>, CATEG_REG <chr>,\nR> #   DT_INI_CATEG <date>, SIT_EMISSOR <chr>,\nR> #   DT_INI_SIT_EMISSOR <date>, CONTROLE_ACIONARIO <chr>,\nR> #   TP_ENDER <chr>, LOGRADOURO <chr>, COMPL <chr>,\nR> #   BAIRRO <chr>, MUN <chr>, UF <chr>, PAIS <chr>, …\nlibrary(GetDFPData2)\nlibrary(dplyr)\n\n# set options\nid_companies <- 19615\nfirst_year <- 2017\nlast_year  <- 2018\n\n# download data\nl_dfp <- get_dfp_data(companies_cvm_codes = id_companies,\n                      type_docs = '*', # get all docs  \n                      type_format = 'con', # consolidated\n                      first_year = first_year,\n                      last_year = last_year)\nstringr::str_sub(names(l_dfp), 1, 40)R> [1] \"DF Consolidado - Balanço Patrimonial Ati\"\nR> [2] \"DF Consolidado - Balanço Patrimonial Pas\"\nR> [3] \"DF Consolidado - Demonstração das Mutaçõ\"\nR> [4] \"DF Consolidado - Demonstração de Valor A\"\nR> [5] \"DF Consolidado - Demonstração do Fluxo d\"\nR> [6] \"DF Consolidado - Demonstração do Resulta\"\n# save assets in df\nfr_assets <- l_dfp$`DF Consolidado - Balanço Patrimonial Ativo`\n\n# check it\ndplyr::glimpse(fr_assets)R> Rows: 122\nR> Columns: 16\nR> $ CNPJ_CIA     <chr> \"89.850.341/0001-60\", \"89.850.341/000…\nR> $ CD_CVM       <dbl> 19615, 19615, 19615, 19615, 19615, 19…\nR> $ DT_REFER     <date> 2017-12-31, 2017-12-31, 2017-12-31, …\nR> $ DT_INI_EXERC <date> NA, NA, NA, NA, NA, NA, NA, NA, NA, …\nR> $ DT_FIM_EXERC <date> 2017-12-31, 2017-12-31, 2017-12-31, …\nR> $ DENOM_CIA    <chr> \"GRENDENE S.A.\", \"GRENDENE S.A.\", \"GR…\nR> $ VERSAO       <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\nR> $ GRUPO_DFP    <chr> \"DF Consolidado - Balanço Patrimonial…\nR> $ MOEDA        <chr> \"REAL\", \"REAL\", \"REAL\", \"REAL\", \"REAL…\nR> $ ESCALA_MOEDA <chr> \"MIL\", \"MIL\", \"MIL\", \"MIL\", \"MIL\", \"M…\nR> $ ORDEM_EXERC  <chr> \"ÚLTIMO\", \"ÚLTIMO\", \"ÚLTIMO\", \"ÚLTIMO…\nR> $ CD_CONTA     <chr> \"1\", \"1.01\", \"1.01.01\", \"1.01.02\", \"1…\nR> $ DS_CONTA     <chr> \"Ativo Total\", \"Ativo Circulante\", \"C…\nR> $ VL_CONTA     <dbl> 3576008, 2846997, 30119, 1537477, 836…\nR> $ COLUNA_DF    <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\nR> $ source_file  <chr> \"dfp_cia_aberta_BPA_con_2017.csv\", \"d…\ntemp_xlsx <- tempfile(fileext = '.xlsx')\n\nexport_xlsx(l_dfp = l_dfp, f_xlsx = temp_xlsx)\nreadxl::excel_sheets(temp_xlsx)R> [1] \"DF Consolidado - Balanço Pat\"  \nR> [2] \"DF Consolidado - Balanço Pat_1\"\nR> [3] \"DF Consolidado - Demonstraçã\"  \nR> [4] \"DF Consolidado - Demonstraçã_1\"\nR> [5] \"DF Consolidado - Demonstraçã_2\"\nR> [6] \"DF Consolidado - Demonstraçã_3\""},{"path":"importacao-pacotes.html","id":"pacote-getfredata","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"5.6 Pacote GetFREData","text":"O pacote GetFREData importa dados sistema FRE – Formulário de Referência – da bolsa Brasileira, incluindo eventos e informações corporativas tal como composição conselho e diretoria, remuneração dos conselhos, entre outras.estrutura de uso e saída das funções de GetFREData são muito semelhante pacote GetDFPData2. Veja seguir um exemplo de uso.Note que o tempo de execução de get_fre_data é significativo. Isto deve-se ao download e leitura dos arquivos sistema FRE direto da bolsa. Cada tabela FRE é importada na lista de saída:Por exemplo, vamos verificar conteúdo da tabela df_board_composition, qual contém informações sobre os componentes dos conselhos das empresas:Como podemos ver, para um pesquisador de finanças corporativas, o sistema FRE oferece uma série de informações interessantes. Discutir o conteúdo de cada tabela, porém, vai muito além propósito dessa seção. Aos interessados, mais detalhes sobre tabelas FRE estão disponíveis em M. Perlin, Kirch, Vancin (2018).\nNote que importação dos dados FRE inclui uma versão dos\narquivos. Toda vez que uma empresa modifica informações oficiais \nsistema da B3, uma nova versão FRE é criada. Devido isso, é\nbastante comum que os dados de um ano para uma empresa possua diferentes\nversões. Para resolver este problema, o código \nGetFREData, por default, importa versão mais\nantiga para cada ano. Caso o usuário queira mudar, basta utilizar \nentrada fre_to_read.\n","code":"\nlibrary(GetFREData)\n\n# set options\nid_companies <- 23264\nfirst_year <- 2017\nlast_year  <- 2018\n\n# download data\nl_fre <- get_fre_data(companies_cvm_codes = id_companies,\n                      first_year = first_year,\n                      last_year = last_year)\nnames(l_fre)R>  [1] \"df_stockholders\"            \nR>  [2] \"df_capital\"                 \nR>  [3] \"df_stock_values\"            \nR>  [4] \"df_mkt_value\"               \nR>  [5] \"df_increase_capital\"        \nR>  [6] \"df_capital_reduction\"       \nR>  [7] \"df_compensation\"            \nR>  [8] \"df_compensation_summary\"    \nR>  [9] \"df_transactions_related\"    \nR> [10] \"df_other_events\"            \nR> [11] \"df_stock_repurchases\"       \nR> [12] \"df_debt_composition\"        \nR> [13] \"df_board_composition\"       \nR> [14] \"df_committee_composition\"   \nR> [15] \"df_family_relations\"        \nR> [16] \"df_family_related_companies\"\nR> [17] \"df_auditing\"                \nR> [18] \"df_responsible_docs\"        \nR> [19] \"df_stocks_details\"          \nR> [20] \"df_dividends_details\"       \nR> [21] \"df_intangible_details\"\nglimpse(l_fre$df_board_composition)R> Rows: 59\nR> Columns: 22\nR> $ CNPJ_CIA                 <chr> \"07.526.557/0001-00\", \"07…\nR> $ DENOM_CIA                <chr> \"AMBEV S.A.\", \"AMBEV S.A.…\nR> $ DT_REFER                 <date> 2017-01-01, 2017-01-01, …\nR> $ CD_CVM                   <dbl> 23264, 23264, 23264, 2326…\nR> $ ID_DOC                   <dbl> 74969, 74969, 74969, 7496…\nR> $ VERSAO                   <dbl> 10, 10, 10, 10, 10, 10, 1…\nR> $ person.name              <chr> \"Paula Nogueira Lindenber…\nR> $ person.cpf               <dbl> 26712117836, 25661215835,…\nR> $ person.profession        <chr> \"Administradora\", \"Engenh…\nR> $ person.cv                <chr> \"Nos últimos 5 anos, ocup…\nR> $ person.dob               <date> NA, NA, NA, NA, NA, NA, …\nR> $ code.type.board          <chr> \"1\", \"1\", \"1\", \"1\", \"1\", …\nR> $ desc.type.board          <chr> \"Director\", \"Director\", \"…\nR> $ desc.type.board2         <chr> \"Diretora de Marketing\", …\nR> $ code.type.job            <chr> \"19\", \"19\", \"19\", \"19\", \"…\nR> $ desc.job                 <chr> \"Não aplicável, uma vez q…\nR> $ date.election            <date> 2016-05-11, 2016-05-11, …\nR> $ date.effective           <date> 2016-05-11, 2016-05-11, …\nR> $ mandate.duration         <chr> \"11/05/2019\", \"30/06/2018…\nR> $ ellected.by.controller   <lgl> TRUE, TRUE, TRUE, TRUE, T…\nR> $ qtd.consecutive.mandates <dbl> 2, 2, 2, 2, 2, 1, 2, 1, 1…\nR> $ percentage.participation <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0…"},{"path":"importacao-pacotes.html","id":"outros-pacotes","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"5.7 Outros Pacotes","text":"Nas seções anteriores destacamos os principais pacotes gratuitos para aquisição de dados financeiros e econômicos Brasil. Muitos desses foram escritos pelo próprio autor livro e representam uma pequena parcela da totalidade. Não seria justo ignorar o trabalho de outros autores. Assim, reporto abaixo uma seleção de pacotes que vale pena conhecer:","code":""},{"path":"importacao-pacotes.html","id":"pacotes-de-acesso-gratuito","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"5.7.1 Pacotes de Acesso Gratuito","text":"BETS (Ferreira, Speranza, Costa 2018)\nPacote construído e mantido pela equipe da FGV. Permite o acesso aos dados BCB (Banco Central Brasil) e IBGE (Instituto Brasileiro de Geografia e Estatística). Também inclui ferramentas para administração, análise e manipulação dos dados em relatórios técnicos.\nsimfinapi (Gomolka 2021)\nPacote para acesso ao projeto simfin, incluindo dados financeiros de diversas empresas internacionais. O acesso livre é restrito um número de chamadas diárias.\n","code":""},{"path":"importacao-pacotes.html","id":"pacotes-comerciais","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"5.7.2 Pacotes Comerciais","text":"Rblpapi (Armstrong, Eddelbuettel, Laing 2022)\nPermite acesso aos dados da Bloomberg, sendo necessário uma conta comercial.\nIBrokers (Ryan Ulrich 2022a)\nAPI para o acesso aos dados da Interactive Brokers. Também é necessário uma conta comercial.\nCRAN você encontrará muitos outros. interface para fontes de dados comerciais também é possível. Várias empresas fornecem APIs para facilitar o envio de dados aos seus clientes. Se empresa de fornecimento de dados que você usa trabalho não apresentada aqui, lista de pacotes CRAN pode ajudá-lo encontrar uma alternativa viável.","code":""},{"path":"importacao-pacotes.html","id":"acessando-dados-de-páginas-na-internet-webscraping","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"5.8 Acessando Dados de Páginas na Internet (Webscraping)","text":"Os pacotes destacados anteriormente são muito úteis pois facilitam importação de dados específicos diretamente da internet. Em muitos casos, porém, os dados de interesse não estão disponíveis via API formal, mas sim em uma página na internet - geralmente formato de uma tabela. O processo de extrair informações de páginas da internet chama-se webscraping (raspagem de dados). Dependendo da estrutura e da tecnologia da página da web acessada, importar essas informações diretamente para o R pode ser um procedimento trivial – mas também pode se tornar um processo extremamente trabalhoso. Como um exemplo, seguir vamos raspar dados Wikipedia sobre composição índice SP500.","code":""},{"path":"importacao-pacotes.html","id":"raspando-dados-do-wikipedia","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"5.8.1 Raspando Dados do Wikipedia","text":"Em seu site, Wikipedia oferece uma seção21 com os componentes Índice SP500. Essas informações são apresentadas em um formato tabular, Figura 5.1.\nFigura 5.1: Imagem da página Wikipedia\ninformações desta página são constantemente atualizadas, e podemos utilizá-las para importar informações sobre ações pertencentes ao índice SP500. Antes de nos aprofundarmos código R, precisamos entender como uma página da web funciona. Resumidamente, uma página da web nada mais é que uma árvore com nódulos, representada por um código HTML (Hypertext Markup Language) extenso interpretado pelo seu navegador. Um valor numérico ou texto apresentado site geralmente pode ser encontrado dentro próprio código. Este código tem uma estrutura particular em forma de árvore com ramificações, classes, nomes e identificadores. Além disso, cada elemento de uma página da web possui um endereço, denominado xpath. Nos navegadores Chrome e Firefox, você pode ver o código HTML de uma página da web usando o mouse. Para isto, basta clicar com o botão direito em qualquer parte da página e selecionar View Page Source (ou “Ver Código Fonte”).primeira etapa processo de raspagem de dados é descobrir localização das informações de que você precisa. navegador Chrome, você pode fazer isso clicando com o botão direito local específico número/texto site e selecionando inspect. Isso abrirá uma janela extra navegador direita. Depois de fazer isso, clique com o botão direito na seleção e escolha copy e copy xpath. Na Figura 5.2, vemos um espelho que você deve estar vendo em seu navegador.\nFigura 5.2: Encontrando o xpath da tabela\nAqui, o texto copiado é:Este é o endereço cabeçalho da tabela. Para todo o conteúdo da tabela, incluindo cabeçalho, linhas e colunas, precisamos definir um nível superior da árvore. Isso é equivalente ao endereço //*[@id =\" mw-content-text\"]/table[1].Agora que temos localização que queremos, vamos carregar o pacote rvest (Wickham 2022a) e usar funções read_html, html_nodes ehtml_table para importar tabela desejada para o R: O objeto df_SP500_comp contém um espelho dos dados site da Wikipedia. Os nomes das colunas requerem algum trabalho de limpeza, mas o principal está ali. Observe como saída é semelhante aos dados da função BatchGetSymbols::GetSP500Stocks. razão é simples, ambas buscaram informação na mesma origem. diferença é que função GetSP500Stocks vai um passo além, limpando os dados importados.","code":"\n'//*[@id=\"mw-content-text\"]/table[1]/thead/tr/th[2]'\nlibrary(rvest)\n\n# set url and xpath\nmy_url <- 'https://en.wikipedia.org/wiki/List_of_S%26P_500_companies'\nmy_xpath <- '//*[@id=\"mw-content-text\"]/div/table[1]'\n\n# get nodes from html\nout_nodes <- html_nodes(read_html(my_url),\n                        xpath = my_xpath)\n\n# get table from nodes (each element in \n# list is a table)\ndf_SP500_comp <- html_table(out_nodes)\n\n# isolate it \ndf_SP500_comp <- df_SP500_comp[[1]]\n\n# change column names (remove space)\nnames(df_SP500_comp) <- make.names(names(df_SP500_comp))\n\n# print it\nglimpse(df_SP500_comp)R> Rows: 503\nR> Columns: 9\nR> $ Symbol                <chr> \"MMM\", \"AOS\", \"ABT\", \"ABBV\",…\nR> $ Security              <chr> \"3M\", \"A. O. Smith\", \"Abbott…\nR> $ SEC.filings           <chr> \"reports\", \"reports\", \"repor…\nR> $ GICS.Sector           <chr> \"Industrials\", \"Industrials\"…\nR> $ GICS.Sub.Industry     <chr> \"Industrial Conglomerates\", …\nR> $ Headquarters.Location <chr> \"Saint Paul, Minnesota\", \"Mi…\nR> $ Date.first.added      <chr> \"1976-08-09\", \"2017-07-26\", …\nR> $ CIK                   <int> 66740, 91142, 1800, 1551152,…\nR> $ Founded               <chr> \"1902\", \"1916\", \"1888\", \"201…"},{"path":"importacao-pacotes.html","id":"exerc-importacao-pacotes","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"5.9 Exercícios","text":"","code":""},{"path":"importacao-pacotes.html","id":"q.1-4","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"Q.1","text":"Using yfR package, download daily data ticker TSLA Yahoo Finance period 2019-01-01 2020-03-02. lowest unadjusted closing price (column price_close) analyzed period?\n\nSolução\n\n","code":"possible_tickers <- c('META', \"TSLA\", \"MMM\", \"GE\")\nticker <- sample(possible_tickers, 1)\nfirst_date <- as.Date('2019-01-01')\nlast_date  <- sample(\n  seq(first_date+50, Sys.Date()-10, by = '1 day'),\n  1)\n\ndf_prices <- yfR::yf_get(tickers = ticker, \n                         first_date = first_date, \n                         last_date = last_date)\n\nmy_sol <- min(df_prices$price_close, \n              na.rm = TRUE)"},{"path":"importacao-pacotes.html","id":"q.2-4","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"Q.2","text":"already done , create profile Quandl website22 download arabica coffee price data (id = CEPEA/COFFEE_A) CEPEA database (Center Advanced Studies Applied Economics) 2010-01-01 2019-09-27. maximum price found?\n\nSolução\n\n","code":"library(GetQuandlData)\n\nid_series <- c('CEPEA/COFFEE_A')\n\n# set api key (make sure you got your own!)\nmy_api_key <- readLines('~/GDrive/98-pass-and-bash/.quandl_api.txt')\n\nfirst_date <- as.Date('2010-01-01')\nlast_date <- sample(\n  seq(first_date + 50, \n      Sys.Date(), by = '1 day'),\n  1)\n\ndf_coffee <- get_Quandl_series(id_in = id_series, \n                               first_date = first_date,\n                               last_date = last_date,\n                               api_key = my_api_key,\n                               do_cache = TRUE)\n\n# find max\nmy_sol <- max(as.numeric(df_coffee$`Cash Price US$`))"},{"path":"importacao-pacotes.html","id":"q.3-3","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"Q.3","text":"Utilize pacote GetBCBData para baixar dados IPCA mensal entre 2010-01-01 e 2020-12-31. Para os dados importados, qual é data com o maior valor mensal de inflação?\n\nSolução\n\n","code":"library(GetBCBData)\n\nid_series <- '433'\nfirst_date <- '2010-01-01'\nlast_date <- '2020-12-31'\n\ndf_ipca <- gbcbd_get_series(id = id_series,\n                            first.date = first_date,\n                            last.date = last_date, \n                            use.memoise = FALSE)\n\nmy_sol <-  df_ipca$ref.date[which.max(df_ipca$value)]"},{"path":"importacao-pacotes.html","id":"q.4-3","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"Q.4","text":"Use function simfinapi::sfa_get_entities import data available companies Simfin. many companies find?\n\nSolução\n\n","code":"library(simfinR)\nlibrary(tidyverse)\n\n# set api key - make sure you got your own at https://simfin.com/data/access/api\nmy_api_key <- read_lines('~/GDrive/98-pass-and-bash/.api_key_simfin.txt')\n\ndf_info <- simfinapi::sfa_get_entities(api_key = my_api_key, \n                                       cache_dir = tempdir())\n\n# check it\nn_companies <- n_distinct(df_info$simfin_id)\n\nmy_sol <- n_companies"},{"path":"importacao-pacotes.html","id":"q.5-3","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"Q.5","text":"package simfinapi, download PnL (profit loss) statement FY (final year) data id = 134979) year 2019. latest “Net Income” company?\n\nSolução\n\n","code":"library(tidyverse)\n\n# set api key - make sure you got your own at https://simfin.com/data/access/api\nmy_api_key <- read_lines('~/GDrive/98-pass-and-bash/.api_key_simfin.txt')\n\ndf_info <- simfinapi::sfa_get_entities(api_key = my_api_key, \n                                       cache_dir = tempdir())\n\ncompany_id <- sample(df_info$simfin_id, 1)\ntype_statements <- 'pl' # profit/loss\nperiods = 'FY' # final year\nyear = sample(2015:2020, 1)\n\ndf_pl <- simfinapi::sfa_get_statement(simfin_id = company_id, \n                             statement = 'pl', \n                             fyear = year, api_key = my_api_key,\n                             cache_dir = tempdir())\n\nmy_sol <- df_pl$net_income"},{"path":"importacao-pacotes.html","id":"q.6-3","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"Q.6","text":"Using yfR package, download data 2019-01-01 2021-05-30 following tickers:AAPL: Apple IncBAC: Bank America CorporationGE: General Electric CompanyTSLA: Tesla, Inc.SNAP: Snap Inc.Using adjusted closing price column, company provided higher return stock holder analyzed period?Tip: advanced exercise require coding. solve , check function split split dataframe price data lapply map function dataframe.\n\nSolução\n\n","code":"first_date <- as.Date('2019-01-01')\nlast_date  <- sample(\n  seq(first_date+50, Sys.Date()-10, by = '1 day'),\n  1)\n\nmy_tickers <- c('AAPL', 'BAC', \n                'GE', 'TSLA',\n                'SNAP')\n\ndf_prices <- yfR::yf_get(tickers = my_tickers, \n                         first_date = first_date, \n                         last_date = last_date)\n\nsplit_l <- split(df_prices, df_prices$ticker)\n\nmy_fct <- function(df_in) {\n  price_vec <- df_in$price_adjusted\n  ticker_in <- df_in$ticker[1]\n  \n  total_ret <- last(price_vec)/first(price_vec) - 1\n  \n  return(tibble(ticker = ticker_in,\n                total_ret = total_ret))\n}\n\ndf_results <- bind_rows(\n  lapply(split_l, my_fct)\n)\n\nwinner <- df_results$ticker[which.max(df_results$total_ret)]\n\nmy_sol <- winner"},{"path":"importacao-pacotes.html","id":"q.7-3","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"Q.7","text":"Using package GetDFPData2, download main table available companies. number active companies currently available?\n\nSolução\n\n","code":"df_info <- GetDFPData2::get_info_companies() |>\n  dplyr::filter(SIT_REG == \"ATIVO\")\n\nmy_sol <- nrow(df_info)"},{"path":"importacao-pacotes.html","id":"q.8-2","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"Q.8","text":"Using package GetDFPData2, download net income data (consolidated) companies year 2019. sum profit/loss (thousands, code 3.11 DFP) companies?\n\nSolução\n\n","code":"df_info <- GetDFPData2::get_info_companies() |>\n  dplyr::filter(SIT_REG == \"ATIVO\")\n\nyear <- sample(2015:(lubridate::year(Sys.Date())-1), 1)\n\nl_dfp <- GetDFPData2::get_dfp_data(first_year = year, \n                                   last_year = year)\n\nni <- l_dfp$`DF Consolidado - Demonstração do Resultado` |>\n  dplyr::filter(CD_CONTA == \"3.11\")\n\nmy_sol <- sum(ni$VL_CONTA)"},{"path":"importacao-pacotes.html","id":"q.9-2","chapter":"Capítulo 5 Importação de Dados via Pacotes","heading":"Q.9","text":"Using package GetTDData, download available data debt contract type LTN (pré-fixados).maximum yield (column yield.bid) found contract LTN 010118?\n\nSolução\n\n","code":"my_temp_path <- fs::path_temp('TD')\nGetTDData::download.TD.data(asset.codes = \"LTN\", \n                            dl.folder = my_temp_path)\n\ndf_td <- GetTDData::read.TD.files(dl.folder = my_temp_path)\n\navailable_assets <- unique(df_td$asset.code)\nmy_asset <- sample(available_assets, 1)\n\ndf_asset <- df_td |>\n  dplyr::filter(asset.code == my_asset)\n\nmy_sol <- max(df_asset$yield.bid)"},{"path":"classe-estrutura.html","id":"classe-estrutura","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"Capítulo 6 Dataframes e outros Objetos","text":"R, tudo é um objeto. Sempre que chamamos uma função, tal como nos exemplos dos capítulos anteriores, ela nos retorna um objeto. Cada tipo ou classe de objeto terá uma série de propriedades diferentes. Por exemplo, um dataframe pode ser incrementado com novas colunas ou linhas. Uma coluna numérica de um dataframe pode interagir com outros valores numéricos através de operações de multiplicação, divisão e soma. Para colunas com textos, porém, tal propriedade não é válida, uma vez que não faz sentido somar um valor numérico um texto ou dividir um texto por outro. Entretanto, classe de texto tem outras propriedades, como que permite procurar uma determinada sequência textual dentro de um texto maior, manipulação de partes texto e substituição de caracteres específicos, dentre tantas outras possibilidades. Um dos aspectos mais importantes trabalho com o R é o aprendizado das classes de objetos e suas funcionalidades.classes básicas de objetos R inclui valores numéricos, caracteres (texto), fatores, datas, entre vários outros casos. Na prática, porém, classes básicas são armazenadas em estruturas de dados mais complexas, tal como dataframes e listas. Isso organiza e facilita o trabalho. Imagine realizar um estudo sobre 63 ações que compõem o índice Ibovespa, onde base de dados é composta por preços e volumes negociados ao longo de um ano. Caso fôssemos criar um vetor numérico de preços e de volumes para cada ação, teríamos uma quantidade de 126 objetos para lidar nosso enviromnent. Apesar de ser possível trabalhar dessa forma, o código resultante seria desorganizado, difícil de entender e passível de uma série de erros.Uma maneira mais simples de organizar os nossos dados é criar um objeto com o nome my_data e alocar todos os preços e volumes ali. Todas informações necessárias para executar pesquisa estariam nesse objeto, facilitando importação e exportação dos dados. Esses objetos que armazenam outros objetos de classe básica constituem classe de estrutura de dados. Nessa classificação, estão incluídas listas (list), matrizes (matrix) e tabelas (dataframes).","code":""},{"path":"classe-estrutura.html","id":"dataframes","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.1 Dataframes","text":"Traduzindo para o português, dataframe significa “estrutura ou organização de dados”. Grosso modo, um objeto da classe dataframe nada mais é que uma tabela com linhas e colunas. Sem dúvida, o dataframe é o principal objeto utilizado trabalho com o R e o mais importante de se estudar. Dados externos são, grande maioria dos casos, importados para o R formato de tabelas. É na manipulação desses que gastará maior parte tempo realizando sua análise. Internamente, um dataframe é um tipo especial de lista, onde cada coluna é um vetor atômico com o mesmo número de elementos, porém com sua própria classe. Podemos organizar em um dataframe dados de texto juntamente com números, por exemplo.Note que o formato tabular força sincronização dos dados sentido de linhas, isto é, cada caso de cada variável deve ser pareado com casos de outras variáveis. Apesar de simples, esse tipo de estruturação de dados é intuitiva e pode acomodar uma variedade de informações. Cada acréscimo de dados (informações) incrementa linhas e cada novo tipo de informação incrementa colunas da tabela.Um dos pontos positivos na utilização dataframe para acomodação de dados é que funções de diferentes pacotes irão funcionar partir dessa classe de objetos. Por exemplo, o pacote de manipulação de dados dplyr, assim como o pacote de criação de figuras ggplot2, funcionam partir de um dataframe. Esse objeto, portanto, está centro de uma série de funcionalidades R e, sem dúvida, é uma classe de objeto extremamente importante para aprender utilizar corretamente.O objeto dataframe é uma das classes nativas R e vem implementado pacote base. Entretanto, o universe tidyverse oferece sua própria versão de um dataframe, chamada tibble, qual é utilizada sistematicamente em todos pacotes tidyverse. conversão de um dataframe para tibble é interna e automática. O tibble possui propriedades mais flexíveis que dataframes nativos, facilitando de forma significativa o seu uso. Seguindo nossa preferência para o tidyverse, partir de agora iremos utilizar tibbles como representantes de dataframes.","code":""},{"path":"classe-estrutura.html","id":"criando-dataframes","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.1.1 Criando dataframes","text":"criação de um dataframe tipo tibble ocorre partir da função tibble. Note que criação de um dataframe nativo ocorre com função base::data.frame, enquanto criação tibble parte da função tibble::tibble ou dplyr::tibble. Para manter o código mais limpo, iremos dar preferência dplyr::tibble e utilizar o nome dataframe para se referir um tibble. Veja o exemplo seguir, onde criamos uma tabela correspondente dados financeiros de diferentes ações. Observe que utilizamos função rep para replicar e facilitar criação dos dados dataframe anterior. Assim, não é necessário repetir os valores múltiplas vezes. Destaca-se que, uso dos dataframes, podemos salvar todos os nossos dados em um único objeto, facilitando o acesso e organização código resultante.\nO conteúdo de dataframes também pode ser visualizado \npróprio RStudio. Para isso, basta clicar nome objeto na aba\nenvironment, canto superior direito da tela. Após isso, um\nvisualizador aparecerá na tela principal programa. Essa operação é\nnada mais que uma chamada função utils::View. Portanto,\npoderíamos visualizar o dataframe anterior executando o\ncomando View(my_df).\n","code":"\nlibrary(tibble)\n\n# set tickers\nticker <- c(rep('ABEV3',4),\n            rep('BBAS3', 4),\n            rep('BBDC3', 4))\n\n# set dates\nref_date <- as.Date(rep(c('2010-01-01', '2010-01-04',\n                          '2010-01-05', '2010-01-06'),\n                        3) )\n\n# set prices\nprice <- c(736.67, 764.14, 768.63, 776.47,\n           59.4  , 59.8  , 59.2  , 59.28,\n           29.81 , 30.82 , 30.38 , 30.20)\n\n# create tibble/dataframe\nmy_df <- tibble(ticker, ref_date , price)\n\n# print it\nprint(my_df)R> # A tibble: 12 × 3\nR>    ticker ref_date   price\nR>    <chr>  <date>     <dbl>\nR>  1 ABEV3  2010-01-01 737. \nR>  2 ABEV3  2010-01-04 764. \nR>  3 ABEV3  2010-01-05 769. \nR>  4 ABEV3  2010-01-06 776. \nR>  5 BBAS3  2010-01-01  59.4\nR>  6 BBAS3  2010-01-04  59.8\nR>  7 BBAS3  2010-01-05  59.2\nR>  8 BBAS3  2010-01-06  59.3\nR>  9 BBDC3  2010-01-01  29.8\nR> 10 BBDC3  2010-01-04  30.8\nR> 11 BBDC3  2010-01-05  30.4\nR> 12 BBDC3  2010-01-06  30.2"},{"path":"classe-estrutura.html","id":"inspecionando-um-dataframe","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.1.2 Inspecionando um dataframe","text":"Após criação dataframe, o segundo passo é conhecer o seu conteúdo. Particularmente, é importante tomar conhecimento dos seguintes itens em ordem de importância:Número de linhas e colunas\nO número de linhas e colunas da tabela resultante indicam se operação de importação foi executada corretamente. Caso os valores forem diferentes esperado, deve-se checar o arquivo de importação dos dados e se opções de importação fazem sentido para o arquivo.\nNomes das colunas\nÉ importante que tabela importada tenha nomes que façam sentido e que sejam fáceis de acessar. Portanto, o segundo passo na inspeção de um dataframe é analisar os nomes das colunas e seus respectivos conteúdos. Confirme que cada coluna realmente apresenta um nome intuitivo.\nClasses das colunas\nCada coluna de um dataframe tem sua própria classe. É de suma importância que classes dos dados estejam corretamente especificadas. Caso contrário, operações futuras podem resultar em um erro. Por exemplo, caso um vetor de valores numéricos seja importado com classe de texto (character), qualquer operação matemática nesse vetor irá resultar em um erro R.\nExistência de dados omissos (NA)\nDevemos também verificar o número de valores NA (available) nas diferentes colunas. Sempre que você encontrar uma grande proporção de valores NA na tabela importada, você deve descobrir o que está acontecendo e se informação está sendo importada corretamente. Conforme mencionado capítulo anterior, os valores NA são contagiosos e transformarão qualquer objeto que interagir com um NA, também se tornará um NA.\nUma das funções mais recomendadas para se familiarizar com um dataframe é dplyr::glimpse. Essa mostra na tela o nome e classe das colunas, além número de linhas/colunas. Abusamos dessa função nos capítulos anteriores. Veja um exemplo simples seguir:Em muitas situações, o uso de glimpse é suficiente para entender se o processo de importação de dados ocorreu de forma satisfatória. Porém, uma análise mais profunda é entender qual variação de cada coluna nos dados importados. Aqui entra o papel da função base::summary:Note que summary interpreta cada coluna de forma diferente. Para o primeiro caso, coluna ticker, mostra apenas o tamanho vetor. caso de datas e valores numéricos, essa apresenta o máximo, mínimo, mediana e quartis. Por exemplo, uma observação extrema (outlier) poderia ser facilmente identificada na análise da saída textual de summary.\nToda vez que se deparar com um novo dataframe R,\npegue o hábito de verificar o seu conteúdo com funções\ndplyr::glimpse e base::summary. Assim, poderá\nperceber problemas de importação e/ou conteúdo dos arquivos lidos. Com\nexperiência irás perceber que muitos erros futuros em código podem ser\nsanados por uma simples inspeção das tabelas importadas.\n","code":"\nlibrary(dplyr)\n\n# check content of my_df\nglimpse(my_df)R> Rows: 12\nR> Columns: 3\nR> $ ticker   <chr> \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS…\nR> $ ref_date <date> 2010-01-01, 2010-01-04, 2010-01-05, 2010…\nR> $ price    <dbl> 736.67, 764.14, 768.63, 776.47, 59.40, 59…\n# check variation my_df\nsummary(my_df)R>     ticker             ref_date              price       \nR>  Length:12          Min.   :2010-01-01   Min.   : 29.81  \nR>  Class :character   1st Qu.:2010-01-03   1st Qu.: 30.71  \nR>  Mode  :character   Median :2010-01-04   Median : 59.34  \nR>                     Mean   :2010-01-04   Mean   :283.73  \nR>                     3rd Qu.:2010-01-05   3rd Qu.:743.54  \nR>                     Max.   :2010-01-06   Max.   :776.47"},{"path":"classe-estrutura.html","id":"operador-de-pipeline","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.1.3 Operador de pipeline (%>%)","text":"Uma característica importante universo tidyverse é o uso extensivo operador de pipeline, primeiro proposto por Bache Wickham (2022) e definido pelo símbolo %>%. Esse comando permite que operações de dados sejam realizadas de forma sequencial e modular, como em uma tubulação, facilitando otimização e legibilidade código resultante.Imagine uma situação onde temos três funções para aplicar nos dados salvos em um dataframe. Cada função depende da saída de outra função. Isso requer o encadeamento de suas chamadas. Usando o operador de pipeline, podemos escrever o procedimento de manipulação dataframe com o seguinte código: Usamos símbolo %>% final de cada linha para vincular operações. funções fct* são operações realizadas em cada etapa. O resultado de cada linha é passado para próxima função de forma sequencial. Assim, não há necessidade de criar objetos intermediários. Veja seguir duas formas alternativas de realizar mesma operação sem o operador de pipeline:Observe como alternativas formam um código com estrutura estranha e passível erros. Provavelmente não deves ter notado, mas ambos os códigos possuem erros de digitação. Para o primeiro, o último arg1 deveria ser arg3 e, segundo, função fct3 está usando o dataframe temp1 e não temp2. Este exemplo deixa claro como o uso de pipelines torna o código mais elegante e legível. partir de agora iremos utilizar o operador %>% de forma extensiva.","code":"\nmy_tab <- my_df %>%\n  fct1(arg1) %>%\n  fct2(arg2) %>%\n  fct3(arg3)\n# version 1\nmy_tab <- fct3(fct2(fct1(my_df,\n                         arg1),\n                    arg2),\n               arg1)\n\n# version 2\ntemp1 <- fct1(my_df, arg1)\ntemp2 <- fct2(temp1, arg2)\nmy_tab <- fct3(temp1, arg3)"},{"path":"classe-estrutura.html","id":"acessando-colunas","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.1.4 Acessando Colunas","text":"Um objeto tipo dataframe utiliza-se de diversos comandos e símbolos que também são usados em matrizes e listas. Para descobrir os nomes das colunas de um dataframe, temos duas funções: names ou colnames:Ambas também podem ser usadas para modificar os nomes das colunas:Destaca-se que forma de usar names é bastante distinta das demais funções R. Nesse caso, utilizamos função ao lado esquerdo símbolo de assign (<-). Internamente, o que estamos fazendo é definindo um atributo objeto temp_df, o nome de suas colunas.Para acessar uma determinada coluna, podemos utilizar o nome da mesma:Note o uso duplo colchetes ([[]]) para selecionar colunas. Vale apontar que, R, um objeto da classe dataframe é representado internamente como uma lista, onde cada elemento é uma coluna. Isso é importante saber, pois alguns comandos de listas também funcionam para dataframes. Um exemplo é o uso de duplo colchetes ([[]]) para selecionar colunas por posição:Para acessar linhas e colunas específicas de um dataframe, basta utilizar colchetes simples:Essa seleção de colunas também pode ser realizada utilizando o nome das mesmas da seguinte forma:ou, pelo operador de pipeline e função dplyr::select: ","code":"\n# check names of df\nnames(my_df)R> [1] \"ticker\"   \"ref_date\" \"price\"\ncolnames(my_df)R> [1] \"ticker\"   \"ref_date\" \"price\"\n# set temp df\ntemp_df <- my_df\n\n# check names\nnames(temp_df)R> [1] \"ticker\"   \"ref_date\" \"price\"\n# change names\nnames(temp_df) <- paste0('Col', 1:ncol(temp_df))\n\n# check names\nnames(temp_df)R> [1] \"Col1\" \"Col2\" \"Col3\"\n# isolate columns of df\nmy_ticker <- my_df$ticker\nmy_prices <- my_df[['price']]\n\n# print contents\nprint(my_ticker)R>  [1] \"ABEV3\" \"ABEV3\" \"ABEV3\" \"ABEV3\" \"BBAS3\" \"BBAS3\" \"BBAS3\"\nR>  [8] \"BBAS3\" \"BBDC3\" \"BBDC3\" \"BBDC3\" \"BBDC3\"\nprint(my_prices)R>  [1] 736.67 764.14 768.63 776.47  59.40  59.80  59.20  59.28\nR>  [9]  29.81  30.82  30.38  30.20\nprint(my_df[[2]])R>  [1] \"2010-01-01\" \"2010-01-04\" \"2010-01-05\" \"2010-01-06\"\nR>  [5] \"2010-01-01\" \"2010-01-04\" \"2010-01-05\" \"2010-01-06\"\nR>  [9] \"2010-01-01\" \"2010-01-04\" \"2010-01-05\" \"2010-01-06\"\nprint(my_df[1:5,2])R> # A tibble: 5 × 1\nR>   ref_date  \nR>   <date>    \nR> 1 2010-01-01\nR> 2 2010-01-04\nR> 3 2010-01-05\nR> 4 2010-01-06\nR> 5 2010-01-01\nprint(my_df[1:5,c(1,2)])R> # A tibble: 5 × 2\nR>   ticker ref_date  \nR>   <chr>  <date>    \nR> 1 ABEV3  2010-01-01\nR> 2 ABEV3  2010-01-04\nR> 3 ABEV3  2010-01-05\nR> 4 ABEV3  2010-01-06\nR> 5 BBAS3  2010-01-01\nprint(my_df[1:5, ])R> # A tibble: 5 × 3\nR>   ticker ref_date   price\nR>   <chr>  <date>     <dbl>\nR> 1 ABEV3  2010-01-01 737. \nR> 2 ABEV3  2010-01-04 764. \nR> 3 ABEV3  2010-01-05 769. \nR> 4 ABEV3  2010-01-06 776. \nR> 5 BBAS3  2010-01-01  59.4\nprint(my_df[1:3, c('ticker','price')])R> # A tibble: 3 × 2\nR>   ticker price\nR>   <chr>  <dbl>\nR> 1 ABEV3   737.\nR> 2 ABEV3   764.\nR> 3 ABEV3   769.\nlibrary(dplyr)\n\nmy.temp <- my_df %>%\n  select(ticker, price) %>%\n  glimpse()R> Rows: 12\nR> Columns: 2\nR> $ ticker <chr> \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS3\"…\nR> $ price  <dbl> 736.67, 764.14, 768.63, 776.47, 59.40, 59.8…"},{"path":"classe-estrutura.html","id":"modificando-um-dataframe","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.1.5 Modificando um dataframe","text":"Para criar novas colunas em um dataframe, basta utilizar função mutate. Aqui iremos abusar operador de pipeline (%>%) para sequenciar operações:Note que precisamos indicar o dataframe de origem dos dados, nesse caso o objeto my_df, e colunas são definidas como argumentos em dplyr::mutate. Observe também que usamos coluna price na construção de ret, o retorno aritmético dos preços. Um caso especial é construção de my_seq2 com base em my_seq1, isto é, antes mesmo dela ser explicitamente calculada já é possível utilizar nova coluna para criar outra. Vale salientar que nova coluna deve ter exatamente o mesmo número de elementos que demais. Caso contrário, o R retorna uma mensagem de erro.maneira mais tradicional, e comumente encontrada em código, para criar novas colunas é utilizar o símbolo $:Portanto, o operador $ vale tanto para acessar quanto para criar novas colunas.Para remover colunas de um dataframe, basta usar dplyr::select com operador negativo para o nome das colunas indesejadas:uso de funções nativas R, maneira tradicional de remover colunas é alocar o valor nulo (NULL):","code":"\nlibrary(dplyr)\n\n# add columns with mutate\nmy_df <- my_df %>%\n  mutate(ret = price/lag(price) -1,\n         my_seq1 = 1:nrow(my_df),\n         my_seq2 =  my_seq1 +9) %>%\n  glimpse()R> Rows: 12\nR> Columns: 6\nR> $ ticker   <chr> \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS…\nR> $ ref_date <date> 2010-01-01, 2010-01-04, 2010-01-05, 2010…\nR> $ price    <dbl> 736.67, 764.14, 768.63, 776.47, 59.40, 59…\nR> $ ret      <dbl> NA, 0.037289424, 0.005875887, 0.010199966…\nR> $ my_seq1  <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nR> $ my_seq2  <dbl> 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2…\n# add new column with base R\nmy_df$my_seq3 <- 1:nrow(my_df)\n\n# check it\nglimpse(my_df)R> Rows: 12\nR> Columns: 7\nR> $ ticker   <chr> \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS…\nR> $ ref_date <date> 2010-01-01, 2010-01-04, 2010-01-05, 2010…\nR> $ price    <dbl> 736.67, 764.14, 768.63, 776.47, 59.40, 59…\nR> $ ret      <dbl> NA, 0.037289424, 0.005875887, 0.010199966…\nR> $ my_seq1  <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nR> $ my_seq2  <dbl> 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2…\nR> $ my_seq3  <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\n# removing columns\nmy_df_temp <- my_df %>%\n  select(-my_seq1, -my_seq2, -my_seq3) %>%\n  glimpse()R> Rows: 12\nR> Columns: 4\nR> $ ticker   <chr> \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS…\nR> $ ref_date <date> 2010-01-01, 2010-01-04, 2010-01-05, 2010…\nR> $ price    <dbl> 736.67, 764.14, 768.63, 776.47, 59.40, 59…\nR> $ ret      <dbl> NA, 0.037289424, 0.005875887, 0.010199966…\n# set temp df\ntemp_df <- my_df\n\n# remove cols\ntemp_df$price <- NULL\ntemp_df$ref_date  <- NULL\n\n# check it\nglimpse(temp_df)R> Rows: 12\nR> Columns: 5\nR> $ ticker  <chr> \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\", \"BBAS3…\nR> $ ret     <dbl> NA, 0.037289424, 0.005875887, 0.010199966,…\nR> $ my_seq1 <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nR> $ my_seq2 <dbl> 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20…\nR> $ my_seq3 <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12"},{"path":"classe-estrutura.html","id":"filtrando-um-dataframe","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.1.6 Filtrando um dataframe","text":"Uma operação bastante comum R é filtrar linhas de uma tabela de acordo com uma ou mais condições. Por exemplo, caso quiséssemos apenas os dados da ação ABEV3, poderíamos utilizar função dplyr::filter para filtrar tabela: função também aceita mais de uma condição. Veja seguir onde filtramos os dados para 'ABEV3' em datas após ou igual '2010-01-05':Aqui utilizamos o símbolo == para testar uma igualdade. Iremos estudar mais profundamente classe de testes lógicos capítulo 7.","code":"\nlibrary(dplyr)\n\n# filter df for single stock\nmy_df_temp <- my_df %>%\n  filter(ticker == 'ABEV3') %>%\n  glimpse()R> Rows: 4\nR> Columns: 7\nR> $ ticker   <chr> \"ABEV3\", \"ABEV3\", \"ABEV3\", \"ABEV3\"\nR> $ ref_date <date> 2010-01-01, 2010-01-04, 2010-01-05, 2010-…\nR> $ price    <dbl> 736.67, 764.14, 768.63, 776.47\nR> $ ret      <dbl> NA, 0.037289424, 0.005875887, 0.010199966\nR> $ my_seq1  <int> 1, 2, 3, 4\nR> $ my_seq2  <dbl> 10, 11, 12, 13\nR> $ my_seq3  <int> 1, 2, 3, 4\nlibrary(dplyr)\n# filter df for single stock and date\nmy_df_temp <- my_df %>%\n  filter(ticker == 'ABEV3',\n         ref_date >= as.Date('2010-01-05')) %>%\n  glimpse()R> Rows: 2\nR> Columns: 7\nR> $ ticker   <chr> \"ABEV3\", \"ABEV3\"\nR> $ ref_date <date> 2010-01-05, 2010-01-06\nR> $ price    <dbl> 768.63, 776.47\nR> $ ret      <dbl> 0.005875887, 0.010199966\nR> $ my_seq1  <int> 3, 4\nR> $ my_seq2  <dbl> 12, 13\nR> $ my_seq3  <int> 3, 4"},{"path":"classe-estrutura.html","id":"ordenando-um-dataframe","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.1.7 Ordenando um dataframe","text":"Após criação ou importação de um dataframe, pode-se ordenar seus componentes de acordo com os valores de alguma coluna. Um caso bastante comum em que é necessário realizar uma ordenação explícita é quando importamos dados financeiros em que datas não estão em ordem crescente. Na grande maioria das situações, dados temporais devem estar ordenados de acordo com antiguidade, isto é, dados mais recentes são alocados na última linha da tabela. Essa operação é realizada através uso da função base::order ou dplyr::arrange. Como exemplo, considere criação de um dataframe com os valores seguir:função order retorna os índices relativos à ordenação dos valores dados como entrada. Para o caso da primeira coluna de my_df, os índices dos elementos formadores novo vetor, com seus valores ordenados em forma crescente, são:Portanto, ao utilizar saída da função order como indexador dataframe, acaba-se ordenando o mesmo de acordo com os valores da coluna col1. Veja seguir:Essa operação de ordenamento também pode ser realizada levando em conta mais de uma coluna. Veja o exemplo seguir, onde se ordena o dataframe pelas colunas col2 e col1.tidyverse, forma de ordenar dataframes é pelo uso da função arrange. caso de ordenamento decrescente, encapsulamos o nome das colunas com desc: O resultado prático uso de arrange é o mesmo de order. Um dos seus benefícios é possibilidade de encadeamento de operações através uso pipeline.","code":"\nlibrary(tidyverse)\n\n# set df\nmy_df <- tibble(col1 = c(4,1,2),\n                col2 = c(1,1,3),\n                col3 = c('a','b','c'))\n\n# print it\nprint(my_df)R> # A tibble: 3 × 3\nR>    col1  col2 col3 \nR>   <dbl> <dbl> <chr>\nR> 1     4     1 a    \nR> 2     1     1 b    \nR> 3     2     3 c\nidx <- order(my_df$col1)\nprint(idx)R> [1] 2 3 1\nmy_df_2 <- my_df[order(my_df$col1), ]\nprint(my_df_2)R> # A tibble: 3 × 3\nR>    col1  col2 col3 \nR>   <dbl> <dbl> <chr>\nR> 1     1     1 b    \nR> 2     2     3 c    \nR> 3     4     1 a\nidx <- order(my_df$col2, my_df$col1)\nmy_df_3 <- my_df[idx, ]\nprint(my_df_3)R> # A tibble: 3 × 3\nR>    col1  col2 col3 \nR>   <dbl> <dbl> <chr>\nR> 1     1     1 b    \nR> 2     4     1 a    \nR> 3     2     3 c\n# sort ascending, by col1 and col2\nmy_df <- my_df %>%\n  arrange(col1, col2) %>%\n  print()R> # A tibble: 3 × 3\nR>    col1  col2 col3 \nR>   <dbl> <dbl> <chr>\nR> 1     1     1 b    \nR> 2     2     3 c    \nR> 3     4     1 a\n# sort descending, col1 and col2\nmy_df <- my_df %>%\n  arrange(desc(col1), desc(col2)) %>%\n  print()R> # A tibble: 3 × 3\nR>    col1  col2 col3 \nR>   <dbl> <dbl> <chr>\nR> 1     4     1 a    \nR> 2     2     3 c    \nR> 3     1     1 b"},{"path":"classe-estrutura.html","id":"combinando-e-agregando-dataframes","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.1.8 Combinando e Agregando dataframes","text":"Em muitas situações de análise de dados será necessário juntar dataframes distintos em um único objeto. Tabelas diferentes são importadas R e, antes de analisar os dados, precisamos combinar informações em um único objeto. Nos casos mais simples, onde tabelas serem agregadas possuem o mesmo formato, nós juntamos de acordo com linhas, verticalmente, ou colunas, horizontalmente. Para esse fim, temos funções dplyr::bind_rows e dlyr::bind_cols tidyverse e base::rbind e base::cbind nas funções nativas R. Observe o exemplo seguir. Note que, exemplo anterior, os nomes das colunas são os mesmos. De fato, função dplyr::bind_rows procura os nomes iguais em ambos os objetos para fazer junção dos dataframes corretamente. colunas que não ocorrem em ambos objetos, tal como col3 exemplo, saem como NA objeto final. Já para o caso de bind_cols, os nomes das colunas devem ser diferentes, porém o número de linhas deve ser o mesmo.Para casos mais complexos, onde junção deve ser realizada de acordo com algum índice tal como uma data, é possível juntar dataframes diferentes com o uso das funções da família dplyr::join* tal como dplyr::inner_join dplyr::left_join, dplyr::full_join, entre outras. descrição de todas elas não cabe aqui. Iremos descrever apenas o caso mais provável, inner_join. Essa combina os dados, mantendo apenas os casos onde existe o índice em ambos.Note que os dataframes criados possuem uma coluna em comum, date. partir desta coluna que agregamos tabelas com inner_join:O R automaticamente verifica existência de colunas com mesmo nome nos dataframes e realiza junção por essas. Caso quiséssemos juntar dataframes onde os nomes das colunas para utilizar o índice não são iguais, temos duas soluções: modificar os nomes das colunas ou então utilizar argumento em dplyr::inner_join. Veja seguir:Para o caso de uso da função nativa de agregação de dataframes, base::merge, temos que indicar explicitamente o nome da coluna com argumento : Note que, nesse caso, o dataframe resultante manteve apenas informações compartilhadas entre ambos os objetos, isto é, aquelas linhas onde datas em date eram iguais. Esse é o mesmo resultado quando uso dplyr::inner_join.demais funções de agregação de tabelas – left_join, right_join, outer_join e full_join – funcionam de forma muito semelhante inner_join, exceto na escolha da saída. Por exemplo, full_join retorna todos os casos/linhas entre tabela 1 e 2, incluindo aqueles onde não tem o índice compartilhado. Para estes casos, coluna índice sairá como NA. Veja o exemplo seguir:","code":"\nlibrary(dplyr)\n\n# set dfs\nmy_df_1 <- tibble(col1 = 1:5,\n                  col2 = rep('a', 5))\n\nmy_df_2 <- tibble(col1 = 6:10,\n                  col2 = rep('b', 5),\n                  col3 = rep('c', 5))\n\n# bind by row\nmy_df <- bind_rows(my_df_1, my_df_2) %>%\n  glimpse()R> Rows: 10\nR> Columns: 3\nR> $ col1 <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\nR> $ col2 <chr> \"a\", \"a\", \"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"b\", …\nR> $ col3 <chr> NA, NA, NA, NA, NA, \"c\", \"c\", \"c\", \"c\", \"c\"\n# set dfs\nmy_df_1 <- tibble(col1 = 1:5, col2 = rep('a', 5))\nmy_df_2 <- tibble(col3 = 6:10, col4 = rep('b', 5))\n\n# bind by column\nmy_df <- bind_cols(my_df_1, my_df_2) %>%\n  glimpse()R> Rows: 5\nR> Columns: 4\nR> $ col1 <int> 1, 2, 3, 4, 5\nR> $ col2 <chr> \"a\", \"a\", \"a\", \"a\", \"a\"\nR> $ col3 <int> 6, 7, 8, 9, 10\nR> $ col4 <chr> \"b\", \"b\", \"b\", \"b\", \"b\"\n# set df\nmy_df_1 <- tibble(date = as.Date('2016-01-01')+0:10,\n                  x = 1:11)\n\nmy_df_2 <- tibble(date = as.Date('2016-01-05')+0:10,\n                  y = seq(20,30, length.out = 11))\n# aggregate tables\nmy_df <- inner_join(my_df_1, my_df_2)R> Joining, by = \"date\"\nglimpse(my_df)R> Rows: 7\nR> Columns: 3\nR> $ date <date> 2016-01-05, 2016-01-06, 2016-01-07, 2016-01-…\nR> $ x    <int> 5, 6, 7, 8, 9, 10, 11\nR> $ y    <dbl> 20, 21, 22, 23, 24, 25, 26\n# set df\nmy_df_3 <- tibble(ref_date = as.Date('2016-01-01')+0:10,\n                  x = 1:11)\n\nmy_df_4 <- tibble(my_date = as.Date('2016-01-05')+0:10,\n                  y = seq(20,30, length.out = 11))\n\n# join by my_df_3$ref_date and my_df_4$my_date\nmy_df <- inner_join(my_df_3, my_df_4,\n                    by = c('ref_date' = 'my_date'))\n\nglimpse(my_df)R> Rows: 7\nR> Columns: 3\nR> $ ref_date <date> 2016-01-05, 2016-01-06, 2016-01-07, 2016…\nR> $ x        <int> 5, 6, 7, 8, 9, 10, 11\nR> $ y        <dbl> 20, 21, 22, 23, 24, 25, 26\n# aggregation with base R\nmy_df <- merge(my_df_1, my_df_2, by = 'date')\n\nglimpse(my_df)R> Rows: 7\nR> Columns: 3\nR> $ date <date> 2016-01-05, 2016-01-06, 2016-01-07, 2016-01-…\nR> $ x    <int> 5, 6, 7, 8, 9, 10, 11\nR> $ y    <dbl> 20, 21, 22, 23, 24, 25, 26\n# set df\nmy_df_5 <- tibble(ref_date = as.Date('2016-01-01')+0:10,\n                  x = 1:11)\n\nmy_df_6 <- tibble(ref_date = as.Date('2016-01-05')+0:10,\n                  y = seq(20,30, length.out = 11))\n\n# combine with full_join\nmy_df <- full_join(my_df_5, my_df_6)R> Joining, by = \"ref_date\"\n# print it\nprint(my_df)R> # A tibble: 15 × 3\nR>    ref_date       x     y\nR>    <date>     <int> <dbl>\nR>  1 2016-01-01     1    NA\nR>  2 2016-01-02     2    NA\nR>  3 2016-01-03     3    NA\nR>  4 2016-01-04     4    NA\nR>  5 2016-01-05     5    20\nR>  6 2016-01-06     6    21\nR>  7 2016-01-07     7    22\nR>  8 2016-01-08     8    23\nR>  9 2016-01-09     9    24\nR> 10 2016-01-10    10    25\nR> 11 2016-01-11    11    26\nR> 12 2016-01-12    NA    27\nR> 13 2016-01-13    NA    28\nR> 14 2016-01-14    NA    29\nR> 15 2016-01-15    NA    30"},{"path":"classe-estrutura.html","id":"extensões-ao-dataframe","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.1.9 Extensões ao dataframe","text":"Como já foi relatado nos capítulos anteriores, um dos grandes benefícios uso R é existência de pacotes para lidar com os problemas específicos dos usuários. Enquanto um objeto tabular tipo tibble é suficiente para maioria dos casos, existem benefícios uso de uma classe alternativa. Ao longo tempo, diversas soluções foram disponibilizadas por desenvolvedores.Por exemplo, é muito comum trabalharmos com dados exclusivamente numéricos que são indexados ao tempo. Isto é, situações onde cada informação pertence um índice temporal - um objeto da classe data/tempo. linhas dessa tabela representam um ponto tempo, enquanto colunas indicam variáveis numéricas de interesse. Nesse caso, faria sentido representarmos os nossos dados como objetos tipo xts (Ryan Ulrich 2022b). O grande benefício dessa opção é que agregação e manipulação de variáveis em função tempo é muito fácil. Por exemplo, podemos transformar dados de frequência diária para frequência semanal com apenas uma linha de comando. Além disso, diversas outras funções reconhecem automaticamente que os dados são indexados ao tempo. Um exemplo é criação de uma figura com esses dados. Nesse caso, o eixo horizontal da figura é automaticamente organizado com datas.Veja um caso seguir, onde carregamos os dados anteriores como um objeto xts:O código anterior pode dar impressão de que o objeto my_xts é semelhante um dataframe, porém, não se engane. Por estar indexado um vetor de tempo, objeto xts pode ser utilizado para uma série de procedimentos temporais, tal como uma agregação por período temporal. Veja o exemplo seguir, onde agregamos duas variáveis de tempo através cálculo de uma média cada semana.Em Finanças e Economia, agregações com objetos xts são extremamente úteis quando se trabalha com dados em frequências de tempo diferentes. Por exemplo, é muito comum que se agregue dados de transação mercado financeiro em alta frequência para intervalos maiores. Assim, dados que ocorrem cada segundo são agregados para serem representados de 15 em 15 minutos. Esse tipo de procedimento é facilmente realizado R através da correta representação dos dados como objetos xts. Existem diversas outras funcionalidades desse pacote. Encorajo os usuários ler o manual e aprender o que pode ser feito.Indo além, existem diversos outros tipos de dataframes customizados. Por exemplo, o dataframe proposto pelo pacote data.table (Dowle Srinivasan 2022) prioriza o tempo de operação nos dados e o uso de uma notação compacta para acesso e processamento. O tibbletime (Vaughan Dancho 2022) é uma versão orientada pelo tempo para tibbles. Caso o usuário esteja necessitando realizar operações de agregação de tempo, o uso deste pacote é fortemente recomendado.","code":"\nlibrary(xts)\n\n# set data\nticker <- c('ABEV3', 'BBAS3','BBDC3')\n\ndate <- as.Date(c('2010-01-01', '2010-01-04',\n                  '2010-01-05', '2010-01-06'))\n\nprice_ABEV3 <- c(736.67, 764.14, 768.63, 776.47)\nprice_BBAS3 <- c(59.4, 59.8, 59.2, 59.28)\nprice_BBDC3 <- c(29.81, 30.82, 30.38, 30.20)\n\n# build matrix\nmy_mat <- matrix(c(price_BBDC3, price_BBAS3, price_ABEV3),\n                 nrow = length(date) )\n\n# set xts object\nmy_xts <- xts(my_mat,\n              order.by = date)\n\n# set correct colnames\ncolnames(my_xts) <- ticker\n\n# check it!\nprint(my_xts)R>            ABEV3 BBAS3  BBDC3\nR> 2010-01-01 29.81 59.40 736.67\nR> 2010-01-04 30.82 59.80 764.14\nR> 2010-01-05 30.38 59.20 768.63\nR> 2010-01-06 30.20 59.28 776.47\nN <- 500\n\nmy_mat <- matrix(c(seq(1, N), seq(N, 1)), nrow=N)\n\nmy_xts <- xts(my_mat, order.by = as.Date('2016-01-01')+1:N)\n\nmy_xts.weekly.mean <- apply.weekly(my_xts, mean)\n\nprint(head(my_xts.weekly.mean))R>             X.1   X.2\nR> 2016-01-03  1.5 499.5\nR> 2016-01-10  6.0 495.0\nR> 2016-01-17 13.0 488.0\nR> 2016-01-24 20.0 481.0\nR> 2016-01-31 27.0 474.0\nR> 2016-02-07 34.0 467.0"},{"path":"classe-estrutura.html","id":"outras-funções-úteis","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.1.10 Outras Funções Úteis","text":"head - Retorna os primeiros n elementos de um dataframe.tail - Retorna os últimos n elementos de um dataframe.complete.cases - Retorna um vetor lógico que testa se linhas contêm apenas valores existentes e nenhum NA.na.omit - Retorna um dataframe sem linhas onde valores NA são encontrados.unique - Retorna um dataframe onde todas linhas duplicadas são eliminadas e somente os casos únicos são mantidos.","code":"\nmy_df <- tibble(col1 = 1:5000, col2 = rep('a', 5000))\nhead(my_df, 5)R> # A tibble: 5 × 2\nR>    col1 col2 \nR>   <int> <chr>\nR> 1     1 a    \nR> 2     2 a    \nR> 3     3 a    \nR> 4     4 a    \nR> 5     5 a\ntail(my_df, 5)R> # A tibble: 5 × 2\nR>    col1 col2 \nR>   <int> <chr>\nR> 1  4996 a    \nR> 2  4997 a    \nR> 3  4998 a    \nR> 4  4999 a    \nR> 5  5000 a\nmy_x <- c(1:5, NA, 10)\nmy_y <- c(5:10, NA)\nmy_df <- tibble(my_x, my_y)\n\nprint(my_df)R> # A tibble: 7 × 2\nR>    my_x  my_y\nR>   <dbl> <int>\nR> 1     1     5\nR> 2     2     6\nR> 3     3     7\nR> 4     4     8\nR> 5     5     9\nR> 6    NA    10\nR> 7    10    NA\nprint(complete.cases(my_df))R> [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE\nprint(which(!complete.cases(my_df)))R> [1] 6 7\nprint(na.omit(my_df))R> # A tibble: 5 × 2\nR>    my_x  my_y\nR>   <dbl> <int>\nR> 1     1     5\nR> 2     2     6\nR> 3     3     7\nR> 4     4     8\nR> 5     5     9\nmy_df <- tibble(col1 = c(1,1,2,3,3,4,5),\n                col2 = c('A','A','A','C','C','B','D'))\n\nprint(my_df)R> # A tibble: 7 × 2\nR>    col1 col2 \nR>   <dbl> <chr>\nR> 1     1 A    \nR> 2     1 A    \nR> 3     2 A    \nR> 4     3 C    \nR> 5     3 C    \nR> 6     4 B    \nR> 7     5 D\nprint(unique(my_df))R> # A tibble: 5 × 2\nR>    col1 col2 \nR>   <dbl> <chr>\nR> 1     1 A    \nR> 2     2 A    \nR> 3     3 C    \nR> 4     4 B    \nR> 5     5 D"},{"path":"classe-estrutura.html","id":"listas","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.2 Listas","text":"Uma lista (list) é uma classe de objeto extremamente flexível e já tivemos contato com ela nos capítulos anteriores. Ao contrário de vetores atômicos, lista não apresenta restrição alguma em relação aos tipos de elementos nela contidos. Podemos agrupar valores numéricos com caracteres, fatores com datas e até mesmo listas dentro de listas. Quando agrupamos vetores, também não é necessário que os mesmos tenham um número igual de elementos. Além disso, podemos dar um nome cada elemento. Essas propriedades fazem da lista o objeto mais flexível para o armazenamento e estruturação de dados R. Não é acidental o fato de que listas são muito utilizadas como retorno de funções.","code":""},{"path":"classe-estrutura.html","id":"criando-listas","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.2.1 Criando Listas","text":"Uma lista pode ser criada através comando base::list, seguido por seus elementos separados por vírgula: Note que juntamos mesmo objeto um vetor atômico numérico, outro de texto, um fator e um tibble. apresentação de listas com o comando print é diferente dos casos anteriores. Os elementos são separados verticalmente e os seus índices aparecem com duplo colchete ([[ ]]). Conforme será explicado logo seguir, é dessa forma que os elementos de uma lista são armazenados e acessados.Assim como para os demais tipos de objeto, os elementos de uma lista também podem ter nomes, o que facilita o entendimento e interpretação das informações problema em análise. Por exemplo, considere o caso de uma base de dados com informações sobre determinada ação negociada na bolsa. Nesse caso, podemos definir uma lista como:\nToda vez que trabalhar com listas, facilite sua vida ao nomear\ntodos os elementos de forma intuitiva. Isso facilita o acesso e evito\npossíveis erros código.\n","code":"\nlibrary(dplyr)\n\n# create list\nmy_l <- list(c(1, 2, 3),\n             c('a', 'b'),\n             factor('A', 'B', 'C'),\n             tibble(col1 = 1:5))\n\n# use base::print\nprint(my_l)R> [[1]]\nR> [1] 1 2 3\nR> \nR> [[2]]\nR> [1] \"a\" \"b\"\nR> \nR> [[3]]\nR> [1] <NA>\nR> Levels: C\nR> \nR> [[4]]\nR> # A tibble: 5 × 1\nR>    col1\nR>   <int>\nR> 1     1\nR> 2     2\nR> 3     3\nR> 4     4\nR> 5     5\n# use dplyr::glimpse\nglimpse(my_l)R> List of 4\nR>  $ : num [1:3] 1 2 3\nR>  $ : chr [1:2] \"a\" \"b\"\nR>  $ : Factor w/ 1 level \"C\": NA\nR>  $ : tibble [5 × 1] (S3: tbl_df/tbl/data.frame)\nR>   ..$ col1: int [1:5] 1 2 3 4 5\n# set named list\nmy_named_l <- list(ticker = 'TICK4',\n                   market = 'Bovespa',\n                   df_prices = tibble(P = c(1,1.5,2,2.3),\n                                      ref_date = Sys.Date()+0:3))\n\n# check content\nglimpse(my_named_l)R> List of 3\nR>  $ ticker   : chr \"TICK4\"\nR>  $ market   : chr \"Bovespa\"\nR>  $ df_prices: tibble [4 × 2] (S3: tbl_df/tbl/data.frame)\nR>   ..$ P       : num [1:4] 1 1.5 2 2.3\nR>   ..$ ref_date: Date[1:4], format: \"2022-11-23\" ..."},{"path":"classe-estrutura.html","id":"acessando-os-elementos-de-uma-lista","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.2.2 Acessando os Elementos de uma Lista","text":"Os elementos de uma lista podem ser acessados através uso de duplo colchete ([[ ]]), tal como em:Também é possível acessar os elementos com um colchete simples ([ ]), porém, tome cuidado com essa operação, pois o resultado não vai ser o objeto em si, mas uma outra lista. Esse é um equívoco muito fácil de passar despercebido, resultando em erros código. Veja seguir:Caso tentarmos somar um elemento my_l[2], teremos uma mensagem de erro:Esse erro ocorre devido ao fato de que uma lista não tem operador de soma. Para corrigir, basta utilizar o duplo colchete, tal como em my_l[[2]]+1. O acesso elementos de uma lista com colchete simples somente é útil quando estamos procurando uma sublista dentro de uma lista maior. exemplo anterior, caso quiséssemos obter o primeiro e o segundo elemento da lista my_l, usaríamos:caso de listas com elementos nomeados, os mesmos podem ser acessados por seu nome através uso símbolo $ tal como em my_named_l$df_prices ou [['nome']], tal como em my_named_l[['df_prices']]. Em geral, essa é uma forma mais eficiente e recomendada de interagir com os elementos de uma lista. Como regra geral uso R, sempre dê preferência ao acesso de elementos através de seus nomes, seja em listas, vetores ou dataframes. Isso evita erros, pois, ao modificar os dados e adicionar algum outro objeto na lista, é possível que o ordenamento interno mude e, portanto, posição de determinado objeto pode acabar sendo modificada.\nSaiba que ferramenta de autocomplete RStudio também\nfunciona para listas. Para usar, digite o nome da lista seguido de\n$ e aperte tab. Uma caixa de diálogo com todos os\nelementos disponíveis na lista irá aparecer. partir disso, basta\nselecionar apertando enter.\nVeja os exemplos seguir, onde são apresentadas diferentes formas de se acessar uma lista.Vale salientar que também é possível acessar diretamente os elementos de um vetor que esteja dentro de uma lista através de colchetes encadeados. Veja seguir:Tal operação é bastante útil quando interessa apenas um elemento dentro de um objeto maior criado por alguma função.","code":"\n# accessing elements from list\nprint(my_named_l[[2]])R> [1] \"Bovespa\"\nprint(my_named_l[[3]])R> # A tibble: 4 × 2\nR>       P ref_date  \nR>   <dbl> <date>    \nR> 1   1   2022-11-23\nR> 2   1.5 2022-11-24\nR> 3   2   2022-11-25\nR> 4   2.3 2022-11-26\n# set list\nmy_l <- list('a',\n             c(1,2,3),\n             factor('a','b'))\n\n# check classes\nclass(my_l[[2]])R> [1] \"numeric\"\nclass(my_l[2])R> [1] \"list\"\nmy_l[2] + 1R> Error in my_l[2] + 1: non-numeric argument to binary operator\n# set new list\nmy_new_l <- my_l[c(1,2)]\n\n# check contents\nprint(my_new_l)R> [[1]]\nR> [1] \"a\"\nR> \nR> [[2]]\nR> [1] 1 2 3\nclass(my_new_l)R> [1] \"list\"\n# different ways to access a list\nmy_named_l$ticker\nmy_named_l$price\nmy_named_l[['ticker']]\nmy_named_l[['price']]\n# accessing elements of a vector in a list\nmy_l <- list(c(1,2,3),\n             c('a', 'b'))\n\nprint(my_l[[1]][2])R> [1] 2\nprint(my_l[[2]][1])R> [1] \"a\""},{"path":"classe-estrutura.html","id":"adicionando-e-removendo-elementos-de-uma-lista","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.2.3 Adicionando e Removendo Elementos de uma Lista","text":"remoção, adição e substituição de elementos de uma lista também são procedimentos fáceis. Para adicionar ou substituir, basta definir um novo objeto na posição desejada da lista:operação também é possível com o uso de nomes e operador $:Para remover elementos de uma lista, basta definir o elemento para o símbolo reservado NULL (nulo):Outra maneira de retirar elementos de uma lista é utilizando um índice negativo para os elementos indesejados. Observe seguir, onde eliminamos o segundo elemento de uma lista:Assim como caso de vetores atômicos, essa remoção também pode ser realizada por condições lógicas. Veja seguir:Porém, note que esse atalho só funciona porque todos os elementos de my_l são numéricos.","code":"\n# set list\nmy_l <- list('a', 1, 3)\nglimpse(my_l)R> List of 3\nR>  $ : chr \"a\"\nR>  $ : num 1\nR>  $ : num 3\n# add new elements to list\nmy_l[[4]] <- c(1:5)\nmy_l[[2]] <- c('b')\n\n# print result\nglimpse(my_l)R> List of 4\nR>  $ : chr \"a\"\nR>  $ : chr \"b\"\nR>  $ : num 3\nR>  $ : int [1:5] 1 2 3 4 5\n# set list\nmy_l <- list(elem1 = 'a', name1=5)\n\n# set new element\nmy_l$name2 <- 10\nglimpse(my_l)R> List of 3\nR>  $ elem1: chr \"a\"\nR>  $ name1: num 5\nR>  $ name2: num 10\n# set list\nmy_l <- list(text = 'b', num1 = 2, num2 = 4)\nglimpse(my_l)R> List of 3\nR>  $ text: chr \"b\"\nR>  $ num1: num 2\nR>  $ num2: num 4\n# remove elements\nmy_l[[3]] <- NULL\nglimpse(my_l)R> List of 2\nR>  $ text: chr \"b\"\nR>  $ num1: num 2\nmy_l$num1 <- NULL\nglimpse(my_l)R> List of 1\nR>  $ text: chr \"b\"\n# set list\nmy_l <- list(a = 1, b = 'texto')\n\n# remove second element\nglimpse(my_l[[-2]])R>  num 1\n# set list\nmy_l <- list(1, 2, 3, 4)\n\n# remove elements by condition\nmy_l[my_l > 2] <- NULL\nglimpse(my_l)R> List of 2\nR>  $ : num 1\nR>  $ : num 2"},{"path":"classe-estrutura.html","id":"processando-os-elementos-de-uma-lista","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.2.4 Processando os Elementos de uma Lista","text":"Um ponto importante ser destacado respeito de listas é que os seus elementos podem ser processados e manipulados individualmente através de funções específicas. Este é um tópico particular de programação com o R, mas que vale apresentação aqui.Por exemplo, imagine uma lista com vetores numéricos de diferentes tamanhos, tal como seguir:Caso quiséssemos calcular média de cada elemento de my_l_num e apresentar o resultado na tela como um vetor, poderíamos fazer isso através de um procedimento simples, processando cada elemento individualmente:O código anterior funciona, porém não é recomendado devido sua falta de escabilidade. Isto é, caso aumentássemos o volume de dados ou objetos, o código não funcionaria corretamente. Se, por exemplo, tivéssemos um quarto elemento em my_l_num e quiséssemos manter essa estrutura código, teríamos que adicionar uma nova linha mean_4 <- mean(my_l_num[[4]]) e modificar o comando de saída na tela para print(c(mean_1, mean_2, mean_3, mean_4)).Uma maneira mais fácil, elegante e inteligente seria utilizar função sapply. Nela, basta indicar o nome objeto de tipo lista e função que queremos utilizar para processar cada elemento. Internamente, os cálculos são realizados automaticamente. Veja seguir:O uso da função sapply é preferível por ser mais compacto e eficiente que alternativa – criação de mean_1, mean_2 e mean_3. Note que o primeiro código, com médias individuais, só funciona para uma lista com três elementos. função sapply, ao contrário, funcionaria da mesma forma em listas de qualquer tamanho. Caso tivéssemos mais elementos, nenhuma modificação seria necessária código anterior, o que o torna extensível chegada de novos dados.Essa visão e implementação de código voltado procedimentos genéricos é um dos lemas para tornar o uso R mais eficiente. regra é simples: sempre escreva códigos que sejam adaptáveis chegada de novos dados. Em inglês, isso é chamado de regra DRY (don’t repeat ). Caso você esteja repetindo códigos e abusando control + c/control + v, como exemplo anterior, certamente existe uma solução mais elegante e flexível que poderia ser utilizada. R, existem diversas outras funções da família apply para esse objetivo. Essas funções serão explicadas com maiores detalhes capítulo 8.","code":"\n# set list\nmy_l_num <- list(c(1, 2, 3),\n                 seq(1:50),\n                 seq(-5, 5, by = 0.5))\n# calculate mean of vectors\nmean_1 <- mean(my_l_num[[1]])\nmean_2 <- mean(my_l_num[[2]])\nmean_3 <- mean(my_l_num[[3]])\n\n# print it\nprint(c(mean_1, mean_2, mean_3))R> [1]  2.0 25.5  0.0\n# using sapply\nmy_mean <- sapply(my_l_num, mean)\n\n# print result\nprint(my_mean)R> [1]  2.0 25.5  0.0"},{"path":"classe-estrutura.html","id":"outras-funções-úteis-1","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.2.5 Outras Funções Úteis","text":"unlist - Retorna os elementos de uma lista em um único vetor atômico..list - Converte um objeto para uma lista, tornando cada elemento um elemento da lista.names - Retorna ou define os nomes dos elementos de uma lista. Assim como para o caso de nomear elementos de um vetor atômico, usa-se função names alocada ao lado esquerdo símbolo <-.","code":"\nmy_named_l <- list(ticker = 'XXXX4',\n                   price = c(1,1.5,2,3),\n                   market = 'Bovespa')\nmy_unlisted <- unlist(my_named_l)\nprint(my_unlisted)R>    ticker    price1    price2    price3    price4    market \nR>   \"XXXX4\"       \"1\"     \"1.5\"       \"2\"       \"3\" \"Bovespa\"\nclass(my_unlisted)R> [1] \"character\"\nmy_x <- 10:13\nmy_x_as_list <- as.list(my_x)\nprint(my_x_as_list)R> [[1]]\nR> [1] 10\nR> \nR> [[2]]\nR> [1] 11\nR> \nR> [[3]]\nR> [1] 12\nR> \nR> [[4]]\nR> [1] 13\nmy_l <- list(value1 = 1, value2 = 2, value3 = 3)\nprint(names(my_l))R> [1] \"value1\" \"value2\" \"value3\"\nmy_l <- list(1,2,3)\nnames(my_l) <- c('num1', 'num2', 'num3')\nprint(my_l)R> $num1\nR> [1] 1\nR> \nR> $num2\nR> [1] 2\nR> \nR> $num3\nR> [1] 3"},{"path":"classe-estrutura.html","id":"matrizes","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.3 Matrizes","text":"Como você deve lembrar das aulas de matemática, uma matriz é uma representação bidimensional de diversos valores, arranjados em linhas e colunas. O uso de matrizes é uma poderosa maneira de representar dados numéricos em duas dimensões e, em certos casos, funções matriciais podem simplificar operações matemáticas complexas.R, matrizes são objetos com duas dimensões, onde todos os elementos devem ser da mesma classe. Além disso, linhas e colunas também podem ter nomes. Assim como para listas e dataframes, isso facilita interpretação e contextualização dos dados.Um claro exemplo uso de matrizes em Finanças seria representação dos preços de diferentes ações ao longo tempo. Nesse caso, teríamos linhas representando diferentes datas e colunas representando cada ativo, tal como seguir:matriz anterior poderia ser criada da seguinte forma R:Observe que, na construção da matriz, definimos o número de linhas e colunas explicitamente com os argumentos nrow = 4 e ncol = 3. Já os nomes das linhas e colunas são definidos pelos comandos colnames e rownames. Destaca-se, novamente, que forma de utilizá-los é bastante distinta das demais funções R. Nesse caso, utilizamos função ao lado esquerdo símbolo de assign (<-). Poderíamos, porém, recuperar os nomes das linhas e colunas com mesmas funções. Veja seguir: momento em que temos essa nossa matriz criada, podemos utilizar todas suas propriedades numéricas. Um exemplo simples é o cálculo valor de um portfólio de investimento ao longo tempo. Caso um investidor tenha 200 ações da ABEV3, 300 da BBAS3 e 100 da BBDC3, o valor seu portfólio ao longo tempo poderá ser calculado assim:\\[V _t = \\sum _{=1} ^{3} N _i P_{,t}\\]Onde Ni é o número de ações compradas para ativo e Pit é o preço da ação na data t. Essa é uma operação bastante simples de ser efetuada com uma multiplicação matricial. Traduzindo o procedimento para o R, temos:Nesse último exemplo, utilizamos o símbolo %*%, o qual permite multiplicação matricial entre os objetos. O objeto my_port indica o valor desse portfólio ao longo das datas, resultando em um leve lucro para o investidor.Um ponto importante ressaltar é que uma matriz R não precisa necessariamente ser composta por valores. É possível, também, criar matrizes de caracteres (texto). Veja o exemplo seguir:Essa flexibilidade dos objetos matriciais possibilita fácil representação e visualização de seus dados em casos específicos.","code":"\n# create matrix\ndata <- c(736.67, 764.14, 768.63, 776.47,\n          59.4, 59.8, 59.2, 59.28,\n          29.81, 30.82, 30.38, 30.20)\n\nmy_mat <- matrix(data, nrow = 4, ncol = 3)\n\n# set names of cols and rows\ncolnames(my_mat) <- c('ABEV3', 'BBAS3', 'BBDC3')\nrownames(my_mat) <- c('2010-01-01', '2010-01-04',\n                      '2010-01-05', '2010-01-06')\n\nprint(my_mat)R>             ABEV3 BBAS3 BBDC3\nR> 2010-01-01 736.67 59.40 29.81\nR> 2010-01-04 764.14 59.80 30.82\nR> 2010-01-05 768.63 59.20 30.38\nR> 2010-01-06 776.47 59.28 30.20\ncolnames(my_mat)R> [1] \"ABEV3\" \"BBAS3\" \"BBDC3\"\nrownames(my_mat)R> [1] \"2010-01-01\" \"2010-01-04\" \"2010-01-05\" \"2010-01-06\"\nmy.w <- as.matrix(c(200, 300, 100), nrow = 3)\nmy_port <- my_mat %*% my.w\nprint(my_port)R>              [,1]\nR> 2010-01-01 168135\nR> 2010-01-04 173850\nR> 2010-01-05 174524\nR> 2010-01-06 176098\nmy_mat_char <- matrix(rep(c('a','b','c'), 3) ,\n                      nrow = 3,\n                      ncol = 3)\nprint(my_mat_char)R>      [,1] [,2] [,3]\nR> [1,] \"a\"  \"a\"  \"a\" \nR> [2,] \"b\"  \"b\"  \"b\" \nR> [3,] \"c\"  \"c\"  \"c\""},{"path":"classe-estrutura.html","id":"selecionando-valores-de-uma-matriz","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.3.1 Selecionando Valores de uma Matriz","text":"Tal como caso dos vetores atômicos, também é possível selecionar pedaços de uma matriz através de indexação. Uma diferença aqui é que os objetos de matrizes possuem duas dimensões, enquanto vetores possuem apenas uma.23 Essa dimensão extra requer indexação não apenas de linhas mas também de colunas. Os elementos de uma matriz podem ser acessados pela notação [,j], onde representa linha e j coluna. Veja o exemplo seguir:Para selecionar colunas ou linhas inteiras, basta deixar o índice vazio, tal como exemplo seguir:Observe que indexação retorna um vetor atômico da classe dos dados. Caso quiséssemos que o pedaço da matriz mantivesse sua classe e orientação vertical ou horizontal, poderíamos forçar essa conversão pelo uso de matrix:Pedaços da matriz também podem ser selecionados via indexadores. Caso quiséssemos uma matriz formada partir da seleção dos elementos da segunda linha e primeira coluna até terceira linha e segunda coluna, usaríamos o seguinte código:Por fim, o uso de testes lógicos para selecionar valores de matrizes também é possível. Veja seguir:","code":"\nmy_mat <- matrix(1:9, nrow = 3)\nprint(my_mat)R>      [,1] [,2] [,3]\nR> [1,]    1    4    7\nR> [2,]    2    5    8\nR> [3,]    3    6    9\nprint(my_mat[1,2])R> [1] 4\nprint(my_mat[ , 2])R> [1] 4 5 6\nprint(my_mat[1, ])R> [1] 1 4 7\nprint(as.matrix(my_mat[ ,2]))R>      [,1]\nR> [1,]    4\nR> [2,]    5\nR> [3,]    6\nprint(matrix(my_mat[1, ], nrow=1))R>      [,1] [,2] [,3]\nR> [1,]    1    4    7\nprint(my_mat[2:3,1:2])R>      [,1] [,2]\nR> [1,]    2    5\nR> [2,]    3    6\nmy_mat <- matrix(1:9, nrow = 3)\nprint(my_mat >5)R>       [,1]  [,2] [,3]\nR> [1,] FALSE FALSE TRUE\nR> [2,] FALSE FALSE TRUE\nR> [3,] FALSE  TRUE TRUE\nprint(my_mat[my_mat >5])R> [1] 6 7 8 9"},{"path":"classe-estrutura.html","id":"outras-funções-úteis-2","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.3.2 Outras Funções Úteis","text":".matrix - Transforma dados para classe matrix.t - Retorna transposta da matriz.rbind - Retorna junção (cola) vertical de matrizes, orientando-se pelas linhas.cbind - Retorna junção (cola) horizontal de matrizes, orientando-se pelas colunas.","code":"\nmy_mat <- as.matrix(1:5)\nprint(my_mat)R>      [,1]\nR> [1,]    1\nR> [2,]    2\nR> [3,]    3\nR> [4,]    4\nR> [5,]    5\nmy_mat <- matrix(seq(10,20, length.out = 6), nrow = 3)\nprint(my_mat)R>      [,1] [,2]\nR> [1,]   10   16\nR> [2,]   12   18\nR> [3,]   14   20\nprint(t(my_mat))R>      [,1] [,2] [,3]\nR> [1,]   10   12   14\nR> [2,]   16   18   20\nmy_mat_1 <- matrix(1:5, nrow = 1)\nprint(my_mat_1)R>      [,1] [,2] [,3] [,4] [,5]\nR> [1,]    1    2    3    4    5\nmy_mat_2 <- matrix(10:14, nrow = 1)\nprint(my_mat_2)R>      [,1] [,2] [,3] [,4] [,5]\nR> [1,]   10   11   12   13   14\nmy.rbind.mat <- rbind(my_mat_1, my_mat_2)\nprint(my.rbind.mat)R>      [,1] [,2] [,3] [,4] [,5]\nR> [1,]    1    2    3    4    5\nR> [2,]   10   11   12   13   14\nmy_mat_1 <- matrix(1:4, nrow = 2)\nprint(my_mat_1)R>      [,1] [,2]\nR> [1,]    1    3\nR> [2,]    2    4\nmy_mat_2 <- matrix(10:13, nrow = 2)\nprint(my_mat_2)R>      [,1] [,2]\nR> [1,]   10   12\nR> [2,]   11   13\nmy_cbind_mat <- cbind(my_mat_1, my_mat_2)\nprint(my_cbind_mat)R>      [,1] [,2] [,3] [,4]\nR> [1,]    1    3   10   12\nR> [2,]    2    4   11   13"},{"path":"classe-estrutura.html","id":"exerc-classe-estrutura","chapter":"Capítulo 6 Dataframes e outros Objetos","heading":"6.4 Exercícios","text":"","code":""},{"path":"classes-basicas.html","id":"classes-basicas","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Capítulo 7 As Classes Básicas de Objetos","text":"classes básicas são os elementos mais primários na representação de dados R. Nos capítulos anteriores utilizamos classes básicas como colunas em uma tabela. Dados numéricos viraram uma coluna tipo numeric, enquanto dados de texto viraram um objeto tipo character.Neste capítulo iremos estudar mais fundo classes básicas de objetos R, incluindo sua criação até manipulação seu conteúdo. Este capítulo é de suma importância pois mostrará quais operações são possíveis com cada classe de objeto e como podes manipular informações de forma eficiente. Os tipos de objetos tratados aqui serão:Numéricos (numeric)Texto (character)Fatores (factor)Valores lógicos (logical)Datas e tempo (Date e timedate)Dados Omissos (NA)","code":""},{"path":"classes-basicas.html","id":"objetos-numéricos","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.1 Objetos Numéricos","text":"Uma das classes mais utilizadas em pesquisa empírica. Os valores numéricos são representações de uma quantidade. Por exemplo: o preço de uma ação em determinada data, o volume negociado de um contrato financeiro em determinado dia, inflação anual de um país, entre várias outras possibilidades.","code":""},{"path":"classes-basicas.html","id":"criando-e-manipulando-vetores-numéricos","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.1.1 Criando e Manipulando Vetores Numéricos","text":"criação e manipulação de valores numéricos é fácil e direta. Os símbolos de operações matemáticas seguem o esperado, tal como soma (+), diminuição (-), divisão (/) e multiplicação (*). Todas operações matemáticas são efetuadas com orientação de elemento para elemento e possuem notação vetorial. Isso significa, por exemplo, que podemos manipular vetores inteiros em uma única linha de comando. Veja seguir, onde se cria dois vetores e realiza-se diversas operações entre eles.Um diferencial R em relação outras linguagens é que, nele, são aceitas operações entre vetores diferentes. Por exemplo, podemos somar um vetor numérico de quatro elementos com outro de apenas dois. Nesse caso, aplica-se chamada regra de reciclagem (recycling rule). Ela define que, se dois vetores de tamanho diferente estão interagindo, o vetor menor é repetido tantas vezes quantas forem necessárias para obter-se o mesmo número de elementos vetor maior. Veja o exemplo seguir:O resultado de x + y é equivalente 1:4 + c(2, 1, 2, 1). Caso interagirmos vetores em que o tamanho maior não é múltiplo menor, o R realiza o mesmo procedimento de reciclagem, porém emite uma mensagem de warning:Os três primeiros elementos de x foram somados aos três primeiros elementos de y. O quarto elemento de x foi somado ao primeiro elemento de y. Uma vez que não havia um quarto elemento em y, o ciclo reinicia, resgatando o primeiro elemento de y e resultando em uma soma igual 5.Os elementos de um vetor numérico também podem ser nomeados quando na criação vetor:Para nomear os elementos após criação, podemos utilizar função names. Veja seguir:Vetores numéricos vazios também podem ser criados. Em algumas situações de desenvolvimento de código faz sentido pré-alocar o vetor antes de preenchê-lo com valores. Nesse caso, utilize função numeric:Observe que, nesse caso, os valores de my_x são definidos como zero.","code":"\n# create numeric vectors\nx <- 1:5\ny <- 2:6\n\n# print sum\nprint(x+y)R> [1]  3  5  7  9 11\n# print multiplication\nprint(x*y)R> [1]  2  6 12 20 30\n# print division\nprint(x/y)R> [1] 0.5000000 0.6666667 0.7500000 0.8000000 0.8333333\n# print exponentiation\nprint(x^y)R> [1]     1     8    81  1024 15625\n# set x with 4 elements and y with 2\nx <- 1:4\ny <- 2:1\n\n# print sum\nprint(x + y)R> [1] 3 3 5 5\n# set x = 4 elements and y with 3\nx <- c(1, 2, 3, 4)\ny <- c(1, 2, 3)\n\n# print sum (recycling rule)\nprint(x +y)R> Warning in x + y: longer object length is not a multiple of\nR> shorter object lengthR> [1] 2 4 6 5\n# create named vector\nx <- c(item1 = 10,\n       item2 = 14,\n       item3 = 9,\n       item4 = 2)\n\n# print it\nprint(x)R> item1 item2 item3 item4 \nR>    10    14     9     2\n# create unnamed vector\nx <- c(10, 14, 9, 2)\n\n# set names of elements\nnames(x) <- c('item1', 'item2', 'item3', 'item4')\n\n# print it\nprint(x)R> item1 item2 item3 item4 \nR>    10    14     9     2\n# create empty numeric vector of length 10\nmy_x <- numeric(length = 10)\n\n# print it\nprint(my_x)R>  [1] 0 0 0 0 0 0 0 0 0 0"},{"path":"classes-basicas.html","id":"criando-sequências-de-valores","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.1.1.1 Criando Sequências de Valores","text":"Existem duas maneiras de criar uma sequência de valores R. primeira, que já foi utilizada nos exemplos anteriores, é o uso operador :. Por exemplo, my_seq <- 1:10 ou my_seq <- -5:5. Esse método é bastante prático, pois notação é clara e direta.Porém, o uso operador : limita possibilidades. diferença entre os valores adjacentes é sempre 1 para sequências ascendentes e -1 para sequências descendentes. Uma versão mais poderosa para criação de sequências é o uso da função seq. Com ela, é possível definir os intervalos entre cada valor com o argumento . Veja seguir: Outro atributo interessante da função seq é possibilidade de criar vetores com um valor inicial, um valor final e o número de elementos desejado. Isso é realizado com o uso da opção length.. Observe o código seguir, onde cria-se um vetor de 0 até 10 com 20 elementos:caso anterior, o tamanho final vetor foi definido e própria função se encarregou de descobrir qual variação necessária entre cada valor de my_seq.","code":"\n# set sequence\nmy_seq <- seq(from = -10, to = 10, by = 2)\n\n# print it\nprint(my_seq)R>  [1] -10  -8  -6  -4  -2   0   2   4   6   8  10\n# set sequence with fixed size\nmy_seq <- seq(from = 0, to = 10, length.out = 20)\n\n# print it\nprint(my_seq)R>  [1]  0.0000000  0.5263158  1.0526316  1.5789474  2.1052632\nR>  [6]  2.6315789  3.1578947  3.6842105  4.2105263  4.7368421\nR> [11]  5.2631579  5.7894737  6.3157895  6.8421053  7.3684211\nR> [16]  7.8947368  8.4210526  8.9473684  9.4736842 10.0000000"},{"path":"classes-basicas.html","id":"criando-vetores-com-elementos-repetidos","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.1.1.2 Criando Vetores com Elementos Repetidos","text":"Outra função interessante é que cria vetores com o uso de repetição. Por exemplo: imagine que estamos interessado em um vetor preenchido com o valor 1 dez vezes. Para isso, basta utilizar função rep: função também funciona com vetores. Considere uma situação onde temos um vetor com os valores c(1,2) e gostaríamos de criar um vetor maior com os elementos c(1, 2, 1, 2, 1, 2) - isto é, repetindo o vetor menor três vezes. Veja o resultado seguir:","code":"\n# repeat vector three times\nmy_x <- rep(x = 1, times = 10)\n\n# print it\nprint(my_x)R>  [1] 1 1 1 1 1 1 1 1 1 1\n# repeat vector three times\nmy_x <- rep(x = c(1, 2), times = 3)\n\n# print it\nprint(my_x)R> [1] 1 2 1 2 1 2"},{"path":"classes-basicas.html","id":"criando-vetores-com-números-aleatórios","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.1.1.3 Criando Vetores com Números Aleatórios","text":"Em muitas situações será necessário criação de números aleatórios. Esse procedimento numérico é bastante utilizado para simular modelos matemáticos em Finanças. Por exemplo, o método de simulação de preços de ativos de Monte Carlo parte da simulação de números aleatórios (McLeish 2011). R, existem diversas funções que criam números aleatórios para diferentes distribuições estatísticas. mais utilizadas, porém, são funções rnorm e runif. função rnorm gera números aleatórios da distribuição Normal, com opções para média (tendência) e o desvio padrão (variabilidade). Veja o seu uso seguir:O código anterior gera uma grande quantidade de números aleatórios de uma distribuição Normal com média zero e desvio padrão igual um. Podemos verificar distribuição dos números gerados com um histograma:Como esperado, temos o formato de sino que caracteriza uma distribuição tipo Normal. Como exercício, podes trocar entradas mean e sd e confirmar como isso afeta figura gerada.Já função runif gera valores aleatórios da distribuição uniforme entre um valor máximo e um valor mínimo. Ela é geralmente utilizada para simular probabilidades. função runif tem três parâmetros de entrada: o número de valores aleatórios desejado, o valor mínimo e o valor máximo. Veja exemplo seguir:Observe que ambas funções anteriores são limitadas à sua respectiva distribuição. Uma maneira alternativa e flexível de gerar valores aleatórios é utilizar função sample. Essa tem como entrada um vetor qualquer e retorna uma versão embaralhada de seus elementos. sua flexibilidade reside fato de que o vetor de entrada pode ser qualquer coisa. Por exemplo, caso quiséssemos criar um vetor aleatório com os números c(0, 5, 15, 20, 25) apenas, poderíamos fazê-lo da seguinte forma: função sample também permite seleção aleatória de um certo número de termos. Por exemplo, caso quiséssemos selecionar aleatoriamente apenas um elemento de my_vec, escreveríamos o código da seguinte maneira:Caso quiséssemos dois elementos, escreveríamos:Também é possível selecionar valores de uma amostra menor para criação de um vetor maior. Por exemplo, considere o caso em que se tem um vetor com os números c(10, 15, 20) e deseja-se criar um vetor aleatório com dez elementos retirados desse vetor menor, com repetição. Para isso, podemos utilizar opção replace = TRUE.Vale destacar que função sample funciona para qualquer tipo ou objeto, não sendo, portanto, exclusiva para vetores numéricos. Poderíamos, também, escolher elementos aleatórios de um vetor de texto ou então uma lista:É importante ressaltar que geração de valores aleatórios R (ou qualquer outro programa) não é totalmente aleatória! De fato, o próprio computador escolhe os valores dentre uma fila de valores possíveis. Cada vez que funções tal como rnorm, runif e sample são utilizadas, o computador escolhe um lugar diferente dessa fila de acordo com vários parâmetros, incluindo data e horário atual. Portanto, ponto de vista usuário, os valores são gerados de forma imprevisível. Para o computador, porém, essa seleção é completamente determinística e guiada por regras claras.Uma propriedade interessante R é possibilidade de selecionar uma posição específica na fila de valores aleatórios utilizando função set.seed. É ela que fixa semente para gerar os valores. Na prática, o resultado é que todos os números e seleções aleatórias realizadas pelo código serão iguais em cada execução. O uso de set.seed é bastante recomendado para manter reprodutibilidade dos códigos envolvendo aleatoriedade. Veja o exemplo seguir, onde utiliza-se essa função. código anterior, o valor de set.seed é um inteiro escolhido pelo usuário. Após chamada de set.seed, todas seleções e números aleatórios irão iniciar mesmo ponto e, portanto, serão iguais. Motivo o leitor executar o código anterior R. Verás que os valores de my_rnd_vec_1 e my_rnd_vec_2 serão exatamente iguais aos valores colocados aqui.O uso de set.seed também funciona para o caso de sample. Veja seguir:Novamente, execute os comandos anteriores R e verás que o resultado na tela bate com o apresentado aqui.","code":"\n# generate 10000 random numbers from a Normal distribution\nmy_rnd_vec <- rnorm(n = 10000,\n                    mean = 0,\n                    sd = 1)\n\n# print first 20 elements\nprint(my_rnd_vec[1:20])R>  [1]  2.23119099  1.05644632 -1.71152285  0.08969915\nR>  [5]  0.53618561 -1.18846705  0.49985211  0.24460369\nR>  [9] -1.38991172 -2.18683422  0.11774128  0.59345327\nR> [13]  0.76478439 -1.73273109  0.18912067  1.44049229\nR> [17]  1.05879799  0.80602246 -1.80066481  0.84976441\n# create a random vector with minimum and maximum\nmy_rnd_vec <- runif(n = 10,\n                    min = -5,\n                    max = 5)\n\n# print it\nprint(my_rnd_vec)R>  [1] -1.6703200 -0.2582507  2.4043159  3.4723961  0.6118807\nR>  [6] -4.4737420 -2.8958942 -4.1903425 -2.2709078 -3.1077450\n# create sequence\nmy_vec <- seq(from = 0, to = 25, by=5)\n\n# sample sequence\nmy_rnd_vec <- sample(my_vec)\n\n# print it\nprint(my_rnd_vec)R> [1]  0  5 20 25 15 10\n# sample one element of my_vec\nmy_rnd_vec <- sample(my_vec, size = 1)\n\n# print it\nprint(my_rnd_vec)R> [1] 10\n# sample two elements of my_vec\nmy_rnd_vec <- sample(my_vec, size = 2)\n\n# print it\nprint(my_rnd_vec)R> [1]  0 20\n# create vector\nmy_vec <- c(5, 10, 15)\n\n# sample\nmy_rnd_vec <- sample(x = my_vec, size = 10, replace = TRUE)\nprint(my_rnd_vec)R>  [1] 10 10 10 10  5  5 10 15 15  5\n# example of sample with characters\nprint(sample(c('elem 1', 'elem 2', 'elem 3'),\n             size = 1))R> [1] \"elem 3\"\n# example of sample with list\nprint(sample(list(x = c(1,1,1),\n                  y = c('a', 'b')),\n             size = 1))R> $y\nR> [1] \"a\" \"b\"\n# fix seed\nset.seed(seed = 10)\n\n# set vec and print\nmy_rnd_vec_1 <- runif(5)\nprint(my_rnd_vec_1)R> [1] 0.50747820 0.30676851 0.42690767 0.69310208 0.08513597\n# set vec and print\nmy_rnd_vec_2 <- runif(5)\nprint(my_rnd_vec_2)R> [1] 0.2254366 0.2745305 0.2723051 0.6158293 0.4296715\n# fix seed\nset.seed(seed = 15)\n\n# print vectors\nprint(sample(1:10))R>  [1]  5  2  1  6  8 10  3  7  9  4\nprint(sample(10:20))R>  [1] 13 15 10 17 20 14 19 12 11 18 16"},{"path":"classes-basicas.html","id":"acessando-elementos-de-um-vetor-numérico","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.1.2 Acessando Elementos de um Vetor Numérico","text":"Todos os elementos de um vetor numérico podem ser acessados através uso de colchetes ([ ]). Por exemplo, caso quiséssemos apenas o primeiro elemento de x, teríamos:mesma notação é válida para extrair porções de um vetor. Caso quiséssemos um subvetor de x com o primeiro e o segundo elemento, faríamos essa operação da seguinte forma:Para acessar elementos nomeados de um vetor numérico, basta utilizar seu nome junto aos colchetes.O acesso aos elementos de um vetor numérico também é possível através de testes lógicos. Por exemplo, caso tivéssemos interesse em saber quais os valores de x que são maiores que 0, o código resultante seria da seguinte forma:Os usos de regras de segmentação dos dados de acordo com algum critério é chamado de indexação lógica. Os objetos tipo logical serão tratados mais profundamente em seção futura deste capítulo.","code":"\n# set vector\nx <- c(-1, 4, -9, 2)\n\n# get first element\nfirst_elem_x <- x[1]\n\n# print it\nprint(first_elem_x)R> [1] -1\n# sub-vector of x\nsub_x <- x[1:2]\n\n# print it\nprint(sub_x)R> [1] -1  4\n# set named vector\nx <- c(item1 = 10, item2 = 14, item3 = -9, item4 = -2)\n\n# access elements by name\nprint(x['item2'])R> item2 \nR>    14\nprint(x[c('item2','item4')])R> item2 item4 \nR>    14    -2\n# find all values of x higher than zero\nprint(x[x > 0])R> item1 item2 \nR>    10    14"},{"path":"classes-basicas.html","id":"modificando-e-removendo-elementos-de-um-vetor-numérico","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.1.3 Modificando e Removendo Elementos de um Vetor Numérico","text":"modificação de um vetor numérico é muito simples. Basta indicar posição dos elementos e os novos valores com o símbolo de assign (<-):Essa modificação também pode ser realizada em bloco:O uso de condições para definir elementos é realizada pela indexação:remoção de elementos é realizada com o uso de índices negativos:Note como o uso índice negativo em my_x[-(1:2)] retorna o vetor original sem o primeiro e segundo elemento.","code":"\n# set vector\nmy_x <- 1:4\n\n# modify first element to 5\nmy_x[1] <- 5\n\n# print result\nprint(my_x)R> [1] 5 2 3 4\n# set vector\nmy_x <- 0:5\n\n# set the first three elements to 5\nmy_x[1:3] <- 5\n\n# print result\nprint(my_x)R> [1] 5 5 5 3 4 5\n# set vector\nmy_x <- -5:5\n\n# set any value lower than 2 to 0\nmy_x[my_x<2] <- 0\n\n# print result\nprint(my_x)R>  [1] 0 0 0 0 0 0 0 2 3 4 5\n# create vector\nmy_x <- -5:5\n\n# remove first and second element of my_x\nmy_x <- my_x[-(1:2)]\n\n# show result\nprint(my_x)R> [1] -3 -2 -1  0  1  2  3  4  5"},{"path":"classes-basicas.html","id":"criando-grupos","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.1.4 Criando Grupos","text":"Em algumas situações será necessário entender quantos casos da amostra estão localizados entre um determinado intervalo. Por exemplo, imagine o vetor dos retornos diários de uma ação, isto é, variação percentual dos preços de fechamento entre um dia e outro. Uma possível análise de risco que pode ser realizada é dividir o intervalo de retornos em cinco partes e verificar o percentual de ocorrência dos valores em cada um dos intervalos. Essa análise numérica é bastante semelhante à construção e visualização de histogramas.função cut serve para criar grupos de intervalos partir de um vetor numérico. Veja o exemplo seguir, onde cria-se um vetor aleatório oriundo da distribuição Normal e cinco grupos partir de intervalos definidos pelos dados. Observe que os nomes dos elementos da variável my_cut são definidos pelos intervalos e o resultado é um objeto tipo fator. Em seções futuras, iremos explicar melhor esse tipo de objeto e suas propriedades.exemplo anterior, os intervalos para cada grupo foram definidos automaticamente. uso da função cut, também é possível definir quebras customizadas nos dados e nos nomes dos grupos. Veja seguir:Note que os nomes dos elementos em my_cut foram definidos como intervalos e o resultado é um objeto tipo fator. É possível também definir intervalos e nomes customizados para cada grupo com o uso dos argumentos labels e breaks:Como podemos ver, os nomes dos grupos estão mais amigáveis para uma futura análise.","code":"\n# set rnd vec\nmy_x <- rnorm(10)\n\n# \"cut\" it into 5 pieces\nmy_cut <- cut(x = my_x, breaks = 5)\nprint(my_cut)R>  [1] (-1.57,-1.12]  (0.252,0.71]   (-1.12,-0.66] \nR>  [4] (-0.204,0.252] (-0.66,-0.204] (-1.57,-1.12] \nR>  [7] (0.252,0.71]   (-0.204,0.252] (0.252,0.71]  \nR> [10] (-0.204,0.252]\nR> 5 Levels: (-1.57,-1.12] (-1.12,-0.66] ... (0.252,0.71]\n# set random vector\nmy_x <- rnorm(10)\n\n# create groups with 5 breaks\nmy_cut <- cut(x = my_x, breaks = 5)\n\n# print it!\nprint(my_cut)R>  [1] (-1.3,-0.3]  (-0.3,0.697] (-0.3,0.697] (-2.3,-1.3] \nR>  [5] (-0.3,0.697] (0.697,1.69] (0.697,1.69] (0.697,1.69]\nR>  [9] (-1.3,-0.3]  (1.69,2.7]  \nR> 5 Levels: (-2.3,-1.3] (-1.3,-0.3] ... (1.69,2.7]\n# create random vector\nmy_x <- rnorm(10)\n\n# define breaks manually\nmy_breaks <- c(min(my_x)-1, -1, 1, max(my_x)+1)\n\n# define labels manually\nmy_labels <- c('Low','Normal', 'High')\n\n# create group from numerical vector\nmy_cut <- cut(x = my_x, breaks = my_breaks, labels = my_labels)\n\n# print both!\nprint(my_x)R>  [1]  0.5981759  1.6113647 -0.4373813  1.3526206  0.4705685\nR>  [6]  0.4702481  0.3963088 -0.7304926  0.6531176  1.2279598\nprint(my_cut)R>  [1] Normal High   Normal High   Normal Normal Normal Normal\nR>  [9] Normal High  \nR> Levels: Low Normal High"},{"path":"classes-basicas.html","id":"outras-funções-úteis-3","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.1.5 Outras Funções Úteis","text":".numeric - Converte determinado objeto para numérico.sum - Soma os elementos de um vetor.max - Retorna o máximo valor numérico vetor.min - Retorna o mínimo valor numérico vetor..max - Retorna posição máximo valor numérico vetor..min - Retorna posição mínimo valor numérico vetor.sort - Retorna uma versão ordenada de um vetor.cumsum - Soma os elementos de um vetor de forma cumulativa.prod - Realiza o produto de todos os elementos de um vetor.cumprod - Calcula o produto cumulativo de todos os elementos de um vetor.","code":"\nmy_text <- c('1', '2', '3')\nclass(my_text)R> [1] \"character\"\nmy_x <- as.numeric(my_text)\nprint(my_x)R> [1] 1 2 3\nclass(my_x)R> [1] \"numeric\"\nmy_x <- 1:50\nmy_sum <- sum(my_x)\nprint(my_sum)R> [1] 1275\nx <- c(10, 14, 9, 2)\nmax_x <- max(x)\nprint(max_x)R> [1] 14\nx <- c(12, 15, 9, 2)\nmin_x <- min(x)\nprint(min_x)R> [1] 2\nx <- c(100, 141, 9, 2)\nwhich.max_x <- which.max(x)\ncat(paste('The position of the maximum value of x is ', which.max_x))R> The position of the maximum value of x is  2\ncat(' and its value is ', x[which.max_x])R>  and its value is  141\nx <- c(10, 14, 9, 2)\nwhich.min_x <- which.min(x)\ncat(paste('The position of the minimum value of x is ',\n          which.min_x, ' and its value is ', x[which.min_x]))R> The position of the minimum value of x is  4  and its value is  2\nx <- runif(5)\nprint(sort(x, decreasing = FALSE))R> [1] 0.1623069 0.8347800 0.8553657 0.9099027 0.9935257\nprint(sort(x, decreasing = TRUE))R> [1] 0.9935257 0.9099027 0.8553657 0.8347800 0.1623069\nmy_x <- 1:25\nmy_cumsum <- cumsum(my_x)\nprint(my_cumsum)R>  [1]   1   3   6  10  15  21  28  36  45  55  66  78  91 105\nR> [15] 120 136 153 171 190 210 231 253 276 300 325\nmy_x <- 1:10\nmy_prod <- prod(my_x)\nprint(my_prod)R> [1] 3628800\nmy_x <- 1:10\nmy_prod <- cumprod(my_x)\nprint(my_prod)R>  [1]       1       2       6      24     120     720    5040\nR>  [8]   40320  362880 3628800"},{"path":"classes-basicas.html","id":"classe-de-caracteres-texto","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.2 Classe de Caracteres (texto)","text":"classe de caracteres, ou texto, serve para armazenar informações textuais. Um exemplo prático em Finanças seria o reconhecimento de uma ação através dos seus símbolos de identificação (tickers) ou então por sua classe de ação: ordinária ou preferencial. Este tipo de dado tem sido utilizado cada vez mais em pesquisa empírica (Gentzkow, Kelly, Taddy 2017), resultando em uma diversidade de pacotes.O R possui vários recursos que facilitam criação e manipulação de objetos de tipo texto. funções básicas fornecidas com instalação de R são abrangentes e adequadas para maioria dos casos. entanto, pacote stringr (Wickham 2022b) tidyverse fornece muitas funções que expandem funcionalidade básica R na manipulação de texto.Um aspecto positivo de stringr é que funções começam com o nome str_ e possuem nomes informativos. Combinando isso com o recurso de preenchimento automático (autocomplete) pela tecla tab, fica fácil de localizar os nomes das funções pacote. Seguindo prioridade ao universo tidyverse, esta seção irá dar preferência ao uso das funções pacote stringr. rotinas nativas de manipulação de texto serão apresentadas, porém de forma limitada. ","code":""},{"path":"classes-basicas.html","id":"criando-um-objeto-simples-de-caracteres","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.2.1 Criando um Objeto Simples de Caracteres","text":"Todo objeto de caracteres é criado através da encapsulação de um texto por aspas duplas (\" \") ou simples (' '). Para criar um vetor de caracteres com tickers de ações, podemos fazê-lo com o seguinte código:Confirma-se classe objeto com função class:","code":"\nmy_assets <- c('PETR3', 'VALE4', 'GGBR4')\nprint(my_assets)R> [1] \"PETR3\" \"VALE4\" \"GGBR4\"\nclass(my_assets)R> [1] \"character\""},{"path":"classes-basicas.html","id":"criando-objetos-estruturados-de-texto","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.2.2 Criando Objetos Estruturados de Texto","text":"Em muitos casos uso R, estaremos interessados em criar vetores de texto com algum tipo de estrutura própria. Por exemplo, o vetor c(\"text 1\", \"text 2\", ..., \"text 20\") possui um lógica de criação clara. Computacionalmente, podemos definir sua estrutura como sendo junção texto text e um vetor de sequência, de 1 até 20.Para criar um vetor textual capaz de unir texto com número, utilizamos função stringr::str_c ou base::paste. Veja o exemplo seguir, onde replica-se o caso anterior com e sem espaço entre número e texto: O mesmo procedimento também pode ser realizado com vetores de texto. Veja seguir:Outra possibilidade de construção de textos estruturados é repetição conteúdo de um objeto tipo caractere. caso de texto, utiliza-se função stringr::str_dup/base::strrep para esse fim. Observe o exemplo seguir: ","code":"\nlibrary(stringr)\n\n# create sequence\nmy_seq <- 1:20\n\n# create character\nmy_text <- 'text'\n\n# paste objects together (without space)\nmy_char <- str_c(my_text, my_seq)\nprint(my_char)R>  [1] \"text1\"  \"text2\"  \"text3\"  \"text4\"  \"text5\"  \"text6\" \nR>  [7] \"text7\"  \"text8\"  \"text9\"  \"text10\" \"text11\" \"text12\"\nR> [13] \"text13\" \"text14\" \"text15\" \"text16\" \"text17\" \"text18\"\nR> [19] \"text19\" \"text20\"\n# paste objects together (with space)\nmy_char <- str_c(my_text, my_seq, sep = ' ')\nprint(my_char)R>  [1] \"text 1\"  \"text 2\"  \"text 3\"  \"text 4\"  \"text 5\" \nR>  [6] \"text 6\"  \"text 7\"  \"text 8\"  \"text 9\"  \"text 10\"\nR> [11] \"text 11\" \"text 12\" \"text 13\" \"text 14\" \"text 15\"\nR> [16] \"text 16\" \"text 17\" \"text 18\" \"text 19\" \"text 20\"\n# paste objects together (with space)\nmy_char <- paste(my_text, my_seq)\nprint(my_char)R>  [1] \"text 1\"  \"text 2\"  \"text 3\"  \"text 4\"  \"text 5\" \nR>  [6] \"text 6\"  \"text 7\"  \"text 8\"  \"text 9\"  \"text 10\"\nR> [11] \"text 11\" \"text 12\" \"text 13\" \"text 14\" \"text 15\"\nR> [16] \"text 16\" \"text 17\" \"text 18\" \"text 19\" \"text 20\"\n# set character value\nmy_x <- 'My name is'\n\n# set character vector\nmy_names <- c('Marcelo', 'Ricardo', 'Tarcizio')\n\n# paste and print\nprint(str_c(my_x, my_names, sep = ' '))R> [1] \"My name is Marcelo\"  \"My name is Ricardo\" \nR> [3] \"My name is Tarcizio\"\nmy_char <- str_dup(string = 'abc', times = 5)\nprint(my_char)R> [1] \"abcabcabcabcabc\""},{"path":"classes-basicas.html","id":"objetos-constantes-de-texto","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.2.3 Objetos Constantes de Texto","text":"O R também possibilita o acesso direto todas letras alfabeto. Esses estão guardadas nos objetos reservados chamados letters e LETTERS: Observe que em ambos os casos não é necessário criar os objetos. Por serem constantes embutidas automaticamente na área de trabalho R, elas já estão disponíveis para uso. Podemos sobrescrever o nome objeto com outro conteúdo, porém isso não é aconselhável. Nunca se sabe onde esse objeto constante está sendo usado. Outros objetos de texto constantes R incluem month.abb e month.name. Veja seguir o seu conteúdo: ","code":"\n# print all letters in alphabet (no cap)\nprint(letters)R>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\"\nR> [15] \"o\" \"p\" \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n# print all letters in alphabet (WITH CAP)\nprint(LETTERS)R>  [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\"\nR> [15] \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n# print abreviation and full names of months\nprint(month.abb)R>  [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\"\nR> [10] \"Oct\" \"Nov\" \"Dec\"\nprint(month.name)R>  [1] \"January\"   \"February\"  \"March\"     \"April\"    \nR>  [5] \"May\"       \"June\"      \"July\"      \"August\"   \nR>  [9] \"September\" \"October\"   \"November\"  \"December\""},{"path":"classes-basicas.html","id":"selecionando-pedaços-de-um-texto","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.2.4 Selecionando Pedaços de um Texto","text":"Um erro comum praticado por iniciantes é tentar selecionar pedaços de um texto através uso de colchetes. Observe o código abaixo:O resultado NA indica que o segundo elemento de my_char não existe. Isso acontece porque o uso de colchetes refere-se ao acesso de elementos de um vetor atômico, e não de caracteres dentro de um texto maior. Observe o que acontece quando utilizamos my_char[1]:O resultado é simplesmente o texto ABCDE, que está localizado primeiro item de my_char. Para selecionar pedaços de um texto, devemos utilizar função específica stringr::str_sub/base::substr: Essa função também funciona para vetores atômicos. Vamos assumir que você importou dados de texto e o conjunto de dados bruto contém um identificador de 3 dígitos de uma empresa, sempre na mesma posição texto. Vamos simular situação R:Só estamos interessados na informação das três primeiras letras de cada elemento em my_char_vec. Para selecioná-los, podemos usar mesmas funções que antes.\nOperações vetorizadas são comuns e esperadas R.\nQuase tudo o que você pode fazer para um único elemento pode ser\nexpandido para vetores. Isso facilita o desenvolvimento de rotinas pois\npode-se facilmente realizar tarefas complicadas em uma série de\nelementos, em uma única linha de código.\n","code":"\n# set char object\nmy_char <- 'ABCDE'\n\n# print its second character: 'B' (WRONG - RESULT is NA)\nprint(my_char[2])R> [1] NA\nprint(my_char[1])R> [1] \"ABCDE\"\n# print third and fourth characters\nmy_substr <- str_sub(string = my_char,\n                     start = 4,\n                     end = 4)\nprint(my_substr)R> [1] \"D\"\n# build char vec\nmy_char_vec <- paste0(c('123','231','321'),\n                      ' - other ignorable text')\nprint(my_char_vec)R> [1] \"123 - other ignorable text\"\nR> [2] \"231 - other ignorable text\"\nR> [3] \"321 - other ignorable text\"\n# get ids with stringr::str_sub\nids.vec <- str_sub(my_char_vec, 1, 3)\nprint(ids.vec)R> [1] \"123\" \"231\" \"321\""},{"path":"classes-basicas.html","id":"localizando-e-substituindo-pedaços-de-um-texto","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.2.5 Localizando e Substituindo Pedaços de um Texto","text":"Uma operação útil na manipulação de textos é localização de letras e padrões específicos com funções stringr::str_locate/base::regexpr e stringr::str_locate_all/base::gregexpr. É importante destacar que, por default, essas funções utilizam de expressões tipo regex - expressões regulares (Thompson 1968). Essa é uma linguagem específica para processar textos. Diversos símbolos são utilizados para estruturar, procurar e isolar padrões textuais. Quando utilizada corretamente, o regex é bastante útil e de extrema valia. Usualmente, o caso mais comum em pesquisa é verificar posição ou existência de um texto menor dentro de um texto maior. Isto é, um padrão explícito e fácil de entender. Por isso, localização e substituição de caracteres próximo exemplo será tipo fixo, sem o uso de regex. Tal informação pode ser passada às funções pacote stringr através de outra função chamada stringr::fixed. O exemplo seguir mostra como encontrar o caractere D dentre uma série de caracteres.Observe que função str_locate retorna apenas primeira ocorrência de D. Para resgatar todas ocorrências, devemos utilizar função str_locate_all:Observe também que funções regexp e grepexpr retornam objetos com propriedades específicas, apresentando-na tela.Para substituir caracteres em um texto, basta utilizar função stringr::str_replace ou base::sub e str_replace_all ou base::gsub. Vale salientar que str_replace substitui primeira ocorrência caractere, enquanto str_replace_all executa uma substituição global - isto é, aplica-se todas ocorrências. Veja diferença seguir: E agora fazemos uma substituição global dos caracteres.Mais uma vez, vale ressaltar que operações de substituição também funcionam em vetores. Dê uma olhada próximo exemplo.","code":"\nlibrary(stringr)\n\nmy_char <- 'ABCDEF-ABCDEF-ABC'\npos = str_locate(string = my_char, pattern = fixed('D') )\nprint(pos)R>      start end\nR> [1,]     4   4\n# set object\nmy_char <- 'ABCDEF-ABCDEF-ABC'\n\n# find position of ALL 'D' using str_locate_all\npos = str_locate_all(string = my_char, pattern = fixed('D'))\nprint(pos)R> [[1]]\nR>      start end\nR> [1,]     4   4\nR> [2,]    11  11\n# set char object\nmy_char <- 'ABCDEF-ABCDEF-ABC'\n\n# substitute the FIRST 'ABC' for 'XXX' with sub\nmy_char <- sub(x = my_char,\n               pattern = 'ABC',\n               replacement = 'XXX')\nprint(my_char)R> [1] \"XXXDEF-ABCDEF-ABC\"\n# substitute the FIRST 'ABC' for 'XXX' with str_replace\nmy_char <- 'ABCDEF-ABCDEF-ABC'\nmy_char <- str_replace(string = my_char,\n                       pattern = fixed('ABC'),\n                       replacement = 'XXX')\nprint(my_char)R> [1] \"XXXDEF-ABCDEF-ABC\"\n# set char object\nmy_char <- 'ABCDEF-ABCDEF-ABC'\n\n# substitute the FIRST 'ABC' for 'XXX' with str_replace\nmy_char <- str_replace_all(string = my_char,\n                           pattern = 'ABC',\n                           replacement = 'XXX')\nprint(my_char)R> [1] \"XXXDEF-XXXDEF-XXX\"\n# set char object\nmy_char <- c('ABCDEF','DBCFE','ABC')\n\n# create an example of vector\nmy_char_vec <- str_c(sample(my_char, 5, replace = T),\n                     sample(my_char, 5, replace = T),\n                     sep = ' - ')\n\n# show it\nprint(my_char_vec)R> [1] \"ABCDEF - ABC\"    \"ABCDEF - ABCDEF\" \"ABCDEF - ABC\"   \nR> [4] \"ABCDEF - DBCFE\"  \"DBCFE - ABCDEF\"\n# substitute all occurrences of 'ABC'\nmy_char_vec <- str_replace_all(string = my_char_vec,\n                               pattern = 'ABC',\n                               replacement = 'XXX')\n\n# print result\nprint(my_char_vec)R> [1] \"XXXDEF - XXX\"    \"XXXDEF - XXXDEF\" \"XXXDEF - XXX\"   \nR> [4] \"XXXDEF - DBCFE\"  \"DBCFE - XXXDEF\""},{"path":"classes-basicas.html","id":"separando-textos","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.2.6 Separando Textos","text":"Em algumas situações, principalmente processamento de textos, é possível que se esteja interessado em quebrar um texto de acordo com algum separador. Por exemplo, o texto abc ; bcd ; adf apresenta informações demarcadas pelo símbolo ;. Para separar um texto em várias partes, utilizamos função stringr::str_split/base::strsplit. Essas quebram o texto em diversas partes de acordo com algum caractere escolhido. Observe os exemplos seguir: saída dessa função é um objeto tipo lista. Para acessar os elementos de uma lista, deve-se utilizar o operador [[ ]]. Por exemplo, para acessar o texto bcd da lista split_char, executa-se o seguinte código:Para visualizar um exemplo de dividir textos em vetores, veja o próximo código.Observe como, novamente, um objeto tipo list é retornado. Cada elemento é correspondente ao processo de quebra de texto em my_char.","code":"\n# set char\nmy_char <- 'ABCXABCXBCD'\n\n# split it based on 'X' and using stringr::str_split\nsplit_char <- str_split(my_char, 'X')\n\n# print result\nprint(split_char)R> [[1]]\nR> [1] \"ABC\" \"ABC\" \"BCD\"\nprint(split_char[[1]][2])R> [1] \"ABC\"\n# set char\nmy_char_vec <- c('ABCDEF','DBCFE','ABFC','ACD')\n\n# split it based on 'B' and using stringr::strsplit\nsplit_char <- str_split(my_char_vec, 'B')\n\n# print result\nprint(split_char)R> [[1]]\nR> [1] \"A\"    \"CDEF\"\nR> \nR> [[2]]\nR> [1] \"D\"   \"CFE\"\nR> \nR> [[3]]\nR> [1] \"A\"  \"FC\"\nR> \nR> [[4]]\nR> [1] \"ACD\""},{"path":"classes-basicas.html","id":"descobrindo-o-número-de-caracteres-de-um-texto","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.2.7 Descobrindo o Número de Caracteres de um Texto","text":"Para descobrir o número de caracteres de um texto, utilizamos função stringr::str_length/base::nchar. Ela também funciona para vetores atômicos de texto. Veja os exemplos mostrados seguir: E agora um exemplo com vetores.","code":"\n# set char\nmy_char <- 'abcdef'\n\n# print number of characters using stringr::str_length\nprint(str_length(my_char))R> [1] 6\n#set char\nmy_char <- c('a', 'ab', 'abc')\n\n# print number of characters using stringr::str_length\nprint(str_length(my_char))R> [1] 1 2 3"},{"path":"classes-basicas.html","id":"gerando-combinações-de-texto","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.2.8 Gerando Combinações de Texto","text":"Um truque útil R é usar funções base::outer e base::expand.grid para criar todas combinações possíveis de elementos em diferentes objetos. Isso é útil quando você quer criar um vetor de texto combinando todos os elementos possíveis de diferentes vetores. Por exemplo, se quisermos criar um vetor com todas combinações entre c('' , 'b') e c('', 'B') como c('-', '-B', ...), podemos escrever: saída de outer é um objeto tipo matriz. Se quisermos mudar comb.mat para um vetor atômico, podemos usar função .character: Outra maneira de atingir o mesmo objetivo é usar função expand.grid. Veja o próximo exemplo.Aqui, usamos função expand.grid para criar um dataframe contendo todas combinações possíveis de my_vec_1 e my_vec_2. Posteriormente, colamos o conteúdo das colunas dataframe usando str_c.","code":"\n# set char vecs\nmy_vec_1 <- c('a','b')\nmy_vec_2 <- c('A','B')\n\n# combine in matrix\ncomb.mat <- outer(my_vec_1,\n                  my_vec_2,\n                  paste,sep = '-')\n\n# print it!\nprint(comb.mat)R>      [,1]  [,2] \nR> [1,] \"a-A\" \"a-B\"\nR> [2,] \"b-A\" \"b-B\"\nprint(as.character(comb.mat))R> [1] \"a-A\" \"b-A\" \"a-B\" \"b-B\"\nlibrary(tidyverse)\n\n# set vectors\nmy_vec_1 <- c('John ', 'Claire ', 'Adam ')\nmy_vec_2 <- c('is fishing.', 'is working.')\n\n# create df with all combinations\nmy_df <- expand.grid(name = my_vec_1,\n                     verb = my_vec_2)\n\n# print df\nprint(my_df)R>      name        verb\nR> 1   John  is fishing.\nR> 2 Claire  is fishing.\nR> 3   Adam  is fishing.\nR> 4   John  is working.\nR> 5 Claire  is working.\nR> 6   Adam  is working.\n# paste columns together in tibble\nmy_df <- my_df %>%\n  mutate(phrase = paste0(name, verb) )\n\n# print result\nprint(my_df)R>      name        verb             phrase\nR> 1   John  is fishing.   John is fishing.\nR> 2 Claire  is fishing. Claire is fishing.\nR> 3   Adam  is fishing.   Adam is fishing.\nR> 4   John  is working.   John is working.\nR> 5 Claire  is working. Claire is working.\nR> 6   Adam  is working.   Adam is working."},{"path":"classes-basicas.html","id":"codificação-de-objetos-character","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.2.9 Codificação de Objetos character","text":"Para o R, um string de texto é apenas uma sequência de bytes. tradução de bytes para caracteres é realizada de acordo com uma estrutura de codificação. Para maioria dos casos de uso R, especialmente em países de língua inglesa, codificação de caracteres não é um problema pois os textos importados R já possuem codificação correta. Ao lidar com dados de texto em diferentes idiomas, tal como Português Brasil, codificação de caracteres é algo que você deve entender pois eventualmente precisará lidar com isso.Vamos explorar um exemplo. Aqui, vamos importar dados de um arquivo de texto com codificação 'ISO-8859-9' e verificar o resultado.O conteúdo original arquivo é um texto em português. Como você pode ver, saída de readr::read_lines mostra todos os caracteres latinos com símbolos estranhos. Isso ocorre pois codificação foi manualmente trocada para 'ISO-8859-9', enquanto função read_lines utiliza 'UTF-8' como default. solução mais fácil e direta é modificar codificação esperada arquivo nas entradas de read_lines. Veja seguir, onde importamos um arquivo com codificação correta ('Latin1'):Os caracteres latinos agora estão corretos pois codificação em read_lines é mesma arquivo, 'Latin1'. Uma boa política neste tópico é sempre verificar codificação de arquivos de texto importados e combiná-lo em R. maioria das funções de importação tem uma opção para fazê-lo. Quando possível, sempre dê preferência para 'UTF-8'. Caso necessário, programas de edição de texto, tal como o notepad++, possuem ferramentas para verificar e trocar codificação de um arquivo.","code":"\n# read text file\nmy_f <- adfeR::get_data_file('FileWithLatinChar_Latin1.txt')\n\nmy_char <- readr::read_lines(my_f)\n\n# print it\nprint(my_char)R> [1] \"A casa \\xe9 bonita e tem muito espa\\xe7o\"\nmy_char <- readr::read_lines(my_f, \n                             locale = readr::locale(encoding='Latin1'))\n\n# print it\nprint(my_char)R> [1] \"A casa é bonita e tem muito espaço\""},{"path":"classes-basicas.html","id":"outras-funções-úteis-4","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.2.10 Outras Funções Úteis","text":"stringr::str_to_lower/base::tolower - Converte um objeto de texto para letras minúsculas.stringr::str_to_upper/base::toupper - Convertem um texto em letras maiúsculas.","code":"\nprint(stringr::str_to_lower('ABC'))R> [1] \"abc\"\nprint(toupper('abc'))R> [1] \"ABC\"\nprint(stringr::str_to_upper('abc'))R> [1] \"ABC\""},{"path":"classes-basicas.html","id":"fatores","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.3 Fatores","text":"classe de fatores (factor) é utilizada para representar grupos ou categorias dentro de uma base de dados formato tabular. Por exemplo, imagine um banco de informações com os gastos de diferentes pessoas ao longo de um ano. Nessa base de dados existe um item que define o gênero indivíduo: masculino ou feminino (M ou F). Essa respectiva coluna pode ser importada e representada como texto, porém, R, melhor maneira de representá-la é através objeto fator, uma vez que mesma representa uma categoria.classe de fatores oferece um significado especial para denotar grupos dentro dos dados. Essa organização é integrada aos pacotes e facilita muito vida usuário. Por exemplo, caso quiséssemos criar um gráfico para cada grupo dentro da nossa base de dados, poderíamos fazer o mesmo simplesmente indicando existência de uma variável de fator para função de criação da figura. Outra possibilidade é determinar se diferentes médias de uma variável numérica são estatisticamente diferentes para os grupos dos nossos dados. Podemos também estimar um determinado modelo estatístico para cada grupo. Quando os dados de categorias são representados apropriadamente, o uso das funções R torna-se mais fácil e eficiente.","code":""},{"path":"classes-basicas.html","id":"criando-fatores","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.3.1 Criando Fatores","text":"criação de fatores dá-se através da função factor: Observe, exemplo anterior, que apresentação de fatores com função print mostra os seus elementos e também o item chamado Levels. Esse último identifica os possíveis grupos que abrangem o vetor - nesse caso apenas M e F. Se tivéssemos um número maior de grupos, o item Levels aumentaria. Veja seguir:Um ponto importante na criação de fatores é que os Levels são inferidos através dos dados criados, e isso pode não corresponder à realidade. Por exemplo, observe o seguinte exemplo:Nota-se que, por ocasião, os dados mostram apenas uma categoria: Solteiro. Entretanto, sabe-se que outra categoria tipo Casado é esperada. caso de utilizarmos o objeto my_status da maneira que foi definida anteriormente, omitiremos informação de outros gêneros, e isso pode ocasionar problemas futuro tal como criação de gráficos incompletos. Nessa situação, o correto é definir os Levels manualmente da seguinte maneira:","code":"\nmy_factor <- factor(c('M', 'F', 'M', 'M', 'F'))\nprint(my_factor)R> [1] M F M M F\nR> Levels: F M\nmy_factor <- factor(c('M','F','M','M','F','ND'))\nprint(my_factor)R> [1] M  F  M  M  F  ND\nR> Levels: F M ND\nmy_status <- factor(c('Solteiro', 'Solteiro', 'Solteiro'))\nprint(my_status)R> [1] Solteiro Solteiro Solteiro\nR> Levels: Solteiro\nmy_status <- factor(c('Solteiro', 'Solteiro', 'Solteiro'),\n                    levels = c('Solteiro', 'Casado'))\nprint(my_status)R> [1] Solteiro Solteiro Solteiro\nR> Levels: Solteiro Casado"},{"path":"classes-basicas.html","id":"modificando-fatores","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.3.2 Modificando Fatores","text":"Um ponto importante sobre os objetos tipo fator é que seus Levels são imutáveis e não atualizam-se com entrada de novos dados. Em outras palavras, não é possível modificar os valores dos Levels após criação objeto. Toda nova informação que não compatível com os Levels objeto será transformada em NA (available) e uma mensagem de warning irá aparecer na tela. Essa limitação pode parecer estranha primeira vista porém, na prática, ela evita possíveis erros código. Veja o exemplo seguir:Nesse caso, maneira correta de proceder é primeiro transformar o objeto da classe fator para classe caractere e depois realizar conversão:Utilizando essas etapas temos o resultado desejado vetor my_factor, com definição de três Levels: , b e c.O universo tidyverse também possui um pacote próprio para manipular fatores, o forcats. Para o problema atual de modificação de fatores, podemos utilizar função forcats::fct_recode. Veja um exemplo seguir, onde trocamos siglas dos fatores: Observe como o uso da função forcats::fct_recode é intuitivo. Basta indicar o novo nome dos grupos com o operador de igualdade.","code":"\n# set factor\nmy_factor <- factor(c('a', 'b', 'a', 'b'))\n\n# change first element of a factor to 'c'\nmy_factor[1] <- 'c'R> Warning in `[<-.factor`(`*tmp*`, 1, value = \"c\"): invalid\nR> factor level, NA generated\n# print result\nprint(my_factor)R> [1] <NA> b    a    b   \nR> Levels: a b\n# set factor\nmy_factor <- factor(c('a', 'b', 'a', 'b'))\n\n# change factor to character\nmy_char <- as.character(my_factor)\n\n# change first element\nmy_char[1] <- 'c'\n\n# mutate it back to class factor\nmy_factor <- factor(my_char)\n\n# show result\nprint(my_factor)R> [1] c b a b\nR> Levels: a b c\nlibrary(forcats)\n\n# set factor\nmy.fct <- factor(c('A', 'B', 'C', 'A', 'C', 'M', 'N'))\n\n# modify factors\nmy.fct <- fct_recode(my.fct,\n                     'D' = 'A',\n                     'E' = 'B',\n                     'F' = 'C')\n\n# print result\nprint(my.fct)R> [1] D E F D F M N\nR> Levels: D E F M N"},{"path":"classes-basicas.html","id":"convertendo-fatores-para-outras-classes","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.3.3 Convertendo Fatores para Outras Classes","text":"Outro ponto importante uso de fatores é sua conversão para outras classes, especialmente numérica. Quando convertemos um objeto de tipo fator para classe caractere, o resultado é o esperado:Porém, quando fazemos o mesmo procedimento para classe numérica, o que o R retorna é longe esperado:Esse resultado pode ser explicado pelo fato de que, internamente, fatores são armazenados como índices, indo de 1 até o número total de Levels. Essa simplificação minimiza o uso da memória computador. Quando pedimos ao R para transformar esses fatores em números, ele entende que buscamos o número índice e não valor. Para contornar, é fácil: basta transformar o objeto fator em caractere e, depois, em numérico, conforme mostrado seguir:\nTenha muito cuidado ao transformar fatores em números. Lembre-se\nsempre de que o retorno da conversão direta serão os índices dos\nlevels e não os valores em si. Esse é um bug bem\nparticular que pode ser difícil de identificar em um código\ncomplexo.\n","code":"\n# create factor\nmy_char <-factor(c('a', 'b', 'c'))\n\n# convert and print\nprint(as.character(my_char))R> [1] \"a\" \"b\" \"c\"\n# set factor\nmy_values <- factor(5:10)\n\n# convert to numeric (WRONG)\nprint(as.numeric(my_values))R> [1] 1 2 3 4 5 6\n# converting factors to character and then to numeric\nprint(as.numeric(as.character(my_values)))R> [1]  5  6  7  8  9 10"},{"path":"classes-basicas.html","id":"criando-tabelas-de-contingência","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.3.4 Criando Tabelas de Contingência","text":"Após criação de um fator, podemos calcular ocorrência de cada fator com função table. Essa também é chamada de tabela de contingência. Em um caso simples, com apenas um fator, função table conta o número de ocorrências de cada categoria, como seguir:Um caso mais avançado uso de table é utilizar mais de um fator para criação da tabela. Veja o exemplo seguir:tabela criada anteriormente mostra o número de ocorrências para cada combinação de fator. Essa é uma ferramenta descritiva simples, mas bastante informativa para análise de grupos de dados.","code":"\n# create factor\nmy_factor <- factor(sample(c('Pref', 'Ord'),\n                           size = 20,\n                           replace = TRUE))\n\n# print contingency table\nprint(table(my_factor))R> my_factor\nR>  Ord Pref \nR>    9   11\n# set factors\nmy_factor_1 <- factor(sample(c('Pref', 'Ord'),\n                             size = 20,\n                             replace = TRUE))\n\nmy_factor_2 <- factor(sample(paste('Grupo', 1:3),\n                             size = 20,\n                             replace = TRUE))\n\n# print contingency table with two factors\nprint(table(my_factor_1, my_factor_2))R>            my_factor_2\nR> my_factor_1 Grupo 1 Grupo 2 Grupo 3\nR>        Ord        2       4       3\nR>        Pref       3       4       4"},{"path":"classes-basicas.html","id":"outras-funções","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.3.5 Outras Funções","text":"levels - Retorna os Levels de um objeto da classe fator..factor - Transforma um objeto para classe fator.split - Com base em um objeto de fator, cria uma lista com valores de outro objeto. Esse comando é útil para separar dados de grupos diferentes e aplicar alguma função com sapply ou lapply.","code":"\nmy_factor <- factor(c('A', 'A', 'B', 'C', 'B'))\nprint(levels(my_factor))R> [1] \"A\" \"B\" \"C\"\nmy_y <- c('a','b', 'c', 'c', 'a')\nmy_factor <- as.factor(my_y)\nprint(my_factor)R> [1] a b c c a\nR> Levels: a b c\nmy_factor <- factor(c('A','B','C','C','C','B'))\nmy_x <- 1:length(my_factor)\n\nmy_l <- split(x = my_x, f = my_factor)\n\nprint(my_l)R> $A\nR> [1] 1\nR> \nR> $B\nR> [1] 2 6\nR> \nR> $C\nR> [1] 3 4 5"},{"path":"classes-basicas.html","id":"valores-lógicos","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.4 Valores Lógicos","text":"Testes lógicos em dados são centrais uso R. Em uma única linha de código podemos testar condições para uma grande quantidade de casos. Esse cálculo é muito utilizado para encontrar casos extremos nos dados (outliers) e também para separar diferentes amostras de acordo com algum critério.","code":""},{"path":"classes-basicas.html","id":"criando-valores-lógicos","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.4.1 Criando Valores Lógicos","text":"Em uma sequência de 1 até 10, podemos verificar quais são os elementos maiores que 5 com o seguinte código: função exemplo anterior retorna os índices onde condição é verdadeira (TRUE). O uso é recomendado quando se quer saber posição de elementos que satisfazem alguma condição.Para realizar testes de igualdade, basta utilizar o símbolo de igualdade duas vezes (==).Para o teste de inigualdades, utilizamos o símbolo !=:Destaca-se que também é possível testar condições múltiplas, isto é, ocorrência simultânea de eventos. Utilizamos o operador & para esse propósito. Por exemplo: se quiséssemos verificar quais são os valores de uma sequência de 1 10 que são maiores que 4 e menores que 7, escreveríamos:Para testar condições não simultâneas, isto é, ocorrências de um ou outro evento, utilizamos o operador |. Por exemplo: considerando sequência anterior, acharíamos os valores maiores que 7 ou menores que 4 escrevendo:Observe que, em ambos os casos de uso de testes lógicos, utilizamos parênteses para encapsular condições lógicas. Poderíamos ter escrito idx <- ( my_x > 7|my_x < 4 ), porém o uso parênteses deixa o código mais claro ao isolar os testes de condições e sinalizar que o resultado da operação será um vetor lógico. Em alguns casos, porém, o uso parênteses indica hierarquia na ordem das operações e portanto não pode ser ignorado.Outro uso interessante de objetos lógicos é o teste para saber se um item ou mais pertence um vetor ou não. Para isso utilizamos o operador %%. Por exemplo, imagine que tens os tickers de duas ações, c('ABC', 'DEF') e queres saber se é possível encontrar esses tickers na coluna de outra base de dados. Essa é uma operação semelhante ao uso teste de igualdade, porém em notação vetorial. Veja um exemplo seguir:O dataframe mostrado na tela possui dados apenas para ações em my_tickers.","code":"\n# set numerical\nmy_x <- 1:10\n\n# print a logical test\nprint(my_x > 5)R>  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\nR> [10]  TRUE\n# print position of elements from logical test\nprint(which(my_x > 5))R> [1]  6  7  8  9 10\n# create char\nmy_char <- rep(c('abc','bcd'), 5)\n\n# print its contents\nprint(my_char)R>  [1] \"abc\" \"bcd\" \"abc\" \"bcd\" \"abc\" \"bcd\" \"abc\" \"bcd\" \"abc\"\nR> [10] \"bcd\"\n# print logical test\nprint(my_char == 'abc')R>  [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\nR> [10] FALSE\n# print inequality test\nprint(my_char != 'abc')R>  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE\nR> [10]  TRUE\nmy_x <- 1:10\n\n# print logical for values higher than 4 and lower than 7\nprint((my_x > 4)&(my_x < 7) )R>  [1] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE\nR> [10] FALSE\n# print the actual values\nidx <- which( (my_x > 4)&(my_x < 7) )\nprint(my_x[idx])R> [1] 5 6\n# location of elements higher than 7 or lower than 4\nidx <- which( (my_x > 7)|(my_x < 4) )\n\n# print elements from previous condition\nprint(my_x[idx])R> [1]  1  2  3  8  9 10\nlibrary(dplyr)\n# location of elements higher than 7 or lower than 4\nmy_tickers <- c('ABC', 'DEF')\n\n# set df\nn_obs <- 100\ndf_temp <- tibble(tickers = sample(c('ABC', 'DEF', 'GHI', 'JKL'),\n                                   size = n_obs,\n                                   replace = TRUE),\n                  ret = rnorm(n_obs, sd = 0.05) )\n\n# find rows with selected tickers\nidx <- df_temp$tickers %in% my_tickers\n\n# print elements from previous condition\nglimpse(df_temp[idx, ])R> Rows: 43\nR> Columns: 2\nR> $ tickers <chr> \"ABC\", \"ABC\", \"ABC\", \"DEF\", \"DEF\", \"ABC\", …\nR> $ ret     <dbl> 0.042864781, 0.017056405, 0.011198439, 0.0…"},{"path":"classes-basicas.html","id":"datas-e-tempo","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.5 Datas e Tempo","text":"representação e manipulação de datas é um importante aspecto das pesquisas em Finanças e Economia. Manipular datas e horários de forma correta, levando em conta mudanças decorridas de horário de verão, feriados locais, em diferentes zonas de tempo, não é uma tarefa fácil! Felizmente, o R fornece um grande suporte para qualquer tipo de operação com datas e tempo.Nesta seção estudaremos funções e classes nativas que representam e manipulam o tempo em R. Aqui, daremos prioridade funções pacote lubridate (Spinu, Grolemund, Wickham 2022). Existem, entanto, muitos pacotes que podem ajudar o usuário processar objetos tipo data e tempo de forma mais avançada. Caso alguma operação com data e tempo não encontrada aqui, sugiro o estudo dos pacotes chron (James Hornik 2022), timeDate (Wuertz, Setz, Chalabi 2022) e bizdays (Freitas 2022). Antes de começarmos, vale relembrar que toda data R segue o formato ISO 8601 (YYYY-MM-DD), onde YYYY é o ano em quatro números, MM é o mês e DD é o dia. Por exemplo, uma data em ISO 8601 é 2022-11-23. Deves familiarizar-se com esse formato pois toda importação de dados com formato de datas diferente desta notação exigirá conversão. Felizmente, essa operação é bastante simples de executar com o lubridate.","code":""},{"path":"classes-basicas.html","id":"criando-datas-simples","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.5.1 Criando Datas Simples","text":"R, existem diversas classes que podem representar datas. escolha entre uma classe de datas e outra baseia-se na necessidade da pesquisa. Em muitas situações não é necessário saber o horário, enquanto que em outras isso é extremamente pertinente pois os dados são coletados ao longo de um dia.classe mais básica de datas é Date. Essa indica dia, mês e ano, apenas. lubridate, criamos datas verificando o formato da data de entrada e funções ymd (year-month-date), dmy (day-month-year) e mdy (month-day-year). Veja seguir: Note que funções retornam exatamente o mesmo objeto. diferença uso é somente pela forma que data de entrada está estruturada com posição dia, mês e ano.Um benefício uso das funções pacote lubridate é que mesmas são inteligentes ao lidar com formatos diferentes. Observe caso anterior que definimos os elementos das datas com o uso traço (-) como separador e valores numéricos. Outros formatos também são automaticamente reconhecidos:Isso é bastante útil pois o formato de datas Brasil é dia/mês/ano (DD/MM/YYYY). Ao usar dmy para uma data brasileira, conversão é correta:Já pacote base, função correspondente é .Date. O formato da data, porém, deve ser explicitamente definido com argumento format, conforme mostrado seguir:Os símbolos utilizados na entrada format, tal como %d e %Y, são indicadores de formato, os quais definem forma em que data ser convertida está estruturada. Nesse caso, os símbolos %Y, %m e %d definem ano, mês e dia, respectivamente. Existem diversos outros símbolos que podem ser utilizados para processar datas em formatos específicos. Um panorama das principais codificações é apresentado seguir:Os símbolos anteriores permitem criação de datas partir de variados formatos. Observe como utilização das funções lubridate, em relação base, são mais simples e fáceis de utilizar, justificando nossa escolha.","code":"\nlibrary(lubridate)\n\n# set Date object\nprint(ymd('2021-06-24'))R> [1] \"2021-06-24\"\n# set Date object\nprint(dmy('24-06-2021'))R> [1] \"2021-06-24\"\n# set Date object\nprint(mdy('06-24-2021'))R> [1] \"2021-06-24\"\n# set Date object\nprint(ymd('2021/06/24'))R> [1] \"2021-06-24\"\n# set Date object\nprint(ymd('2021&06&24'))R> [1] \"2021-06-24\"\n# set Date object\nprint(ymd('2021 june 24'))R> [1] \"2021-06-24\"\n# set Date object\nprint(dmy('24 of june 2021'))R> [1] \"2021-06-24\"\n# set Date from dd/mm/yyyy\nmy_date <- dmy('24/06/2021')\n\n# print result\nprint(my_date)R> [1] \"2021-06-24\"\n# set Date from dd/mm/yyyy with the definition of format\nmy_date <- as.Date('24/06/2021', format = '%d/%m/%Y')\n\n# print result\nprint(my_date)R> [1] \"2021-06-24\""},{"path":"classes-basicas.html","id":"criando-sequências-de-datas","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.5.2 Criando Sequências de Datas","text":"Um aspecto interessante uso de objetos tipo Date é que eles interagem com operações de adição de valores numéricos e com testes lógicos de comparação de datas. Por exemplo: caso quiséssemos adicionar um dia à data my_date criada anteriormente, bastaria somar o valor 1 ao objeto:propriedade também funciona com vetores, o que deixa criação de sequências de datas muito fácil. Nesse caso, o próprio R encarrega-se de verificar o número de dias em cada mês.Uma maneira mais customizável de criar sequências de datas é utilizar função seq. Com ela, é possível definir intervalos diferentes de tempo e até mesmo o tamanho vetor de saída. Caso quiséssemos uma sequência de datas de dois em dois dias, poderíamos utilizar o seguinte código: Caso quiséssemos de duas em duas semanas, escreveríamos:Outra forma de utilizar seq é definir o tamanho desejado objeto de saída. Por exemplo, caso quiséssemos um vetor de datas com 10 elementos, usaríamos:O intervalo entre datas em my_date_vec é definido automaticamente pelo R.","code":"\n# create date\nmy_date <- ymd('2021-06-24')\n\n# find next day\nmy_date_2 <- my_date + 1\n\n# print result\nprint(my_date_2)R> [1] \"2021-06-25\"\n# create a sequence of Dates\nmy_date_vec <- my_date + 0:15\n\n# print it\nprint(my_date_vec)R>  [1] \"2021-06-24\" \"2021-06-25\" \"2021-06-26\" \"2021-06-27\"\nR>  [5] \"2021-06-28\" \"2021-06-29\" \"2021-06-30\" \"2021-07-01\"\nR>  [9] \"2021-07-02\" \"2021-07-03\" \"2021-07-04\" \"2021-07-05\"\nR> [13] \"2021-07-06\" \"2021-07-07\" \"2021-07-08\" \"2021-07-09\"\n# set first and last Date\nmy_date_1 <- ymd('2021-03-07')\nmy_date_2 <- ymd('2021-03-20')\n\n# set sequence\nmy_date_date <- seq(from = my_date_1,\n                    to = my_date_2,\n                    by = '2 days')\n\n# print result\nprint(my_date_date)R> [1] \"2021-03-07\" \"2021-03-09\" \"2021-03-11\" \"2021-03-13\"\nR> [5] \"2021-03-15\" \"2021-03-17\" \"2021-03-19\"\n# set first and last Date\nmy_date_1 <- ymd('2021-03-07')\nmy_date_2 <- ymd('2021-04-20')\n\n# set sequence\nmy_date_date <- seq(from = my_date_1,\n                    to = my_date_2,\n                    by = '2 weeks')\n\n# print result\nprint(my_date_date)R> [1] \"2021-03-07\" \"2021-03-21\" \"2021-04-04\" \"2021-04-18\"\n# set first and last Date\nmy_date_1 <- ymd('2021-03-07')\nmy_date_2 <- ymd('2021-10-20')\n\n# set sequence\nmy_date_vec <- seq(from = my_date_1,\n                    to = my_date_2,\n                    length.out = 10)\n\n# print result\nprint(my_date_vec)R>  [1] \"2021-03-07\" \"2021-04-01\" \"2021-04-26\" \"2021-05-21\"\nR>  [5] \"2021-06-15\" \"2021-07-11\" \"2021-08-05\" \"2021-08-30\"\nR>  [9] \"2021-09-24\" \"2021-10-20\""},{"path":"classes-basicas.html","id":"operações-com-datas","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.5.3 Operações com Datas","text":"É possível descobrir diferença de dias entre datas simplesmente diminuindo uma data da outra:saída da operação de subtração é um objeto da classe diffdate, o qual possui classe de lista como sua estrutura básica. Destaca-se que notação de acesso aos elementos da classe diffdate é mesma utilizada para listas. O valor numérico número de dias está contido primeiro elemento de diff_date:Podemos testar se uma data é maior que outra com o uso das operações de comparação:operação anterior é bastante útil quando se está buscando filtrar um determinado período de tempo nos dados. Nesse caso, basta buscar nas datas o período específico em que estamos interessados e utilizar o objeto lógico da comparação para selecionar os elementos. Veja o exemplo seguir:Nesse caso, o vetor final de preços da coluna prices contém apenas informações para o período entre first_date e last_date.","code":"\n# set dates\nmy_date_1 <- ymd('2015-06-24')\nmy_date_2 <- ymd('2016-06-24')\n\n# calculate difference\ndiff_date <- my_date_2 - my_date_1\n\n# print result\nprint(diff_date)R> Time difference of 366 days\n# print difference of days as numerical value\nprint(diff_date[[1]])R> [1] 366\n# set date and vector\nmy_date_1 <- ymd('2016-06-20')\nmy_date_vec <- ymd('2016-06-20') + seq(-5,5)\n\n# test which elements of my_date_vec are older than my_date_1\nmy_test <- (my_date_vec > my_date_1)\n\n# print result\nprint(my_test)R>  [1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\nR> [10]  TRUE  TRUE\nlibrary(dplyr)\nlibrary(lubridate)\n\n# set first and last dates\nfirst_date <- ymd('2016-06-01')\nlast_date <- ymd('2016-06-15')\n\n# create `dataframe` and glimpse it\nmy_temp_df <- tibble(date_vec = ymd('2016-05-25') + seq(0,30),\n                     prices=seq(1,10,\n                                length.out = length(date_vec)))\n\nglimpse(my_temp_df)R> Rows: 31\nR> Columns: 2\nR> $ date_vec <date> 2016-05-25, 2016-05-26, 2016-05-27, 2016…\nR> $ prices   <dbl> 1.0, 1.3, 1.6, 1.9, 2.2, 2.5, 2.8, 3.1, 3…\n# find dates that are between the first and last date\nmy_idx <- (my_temp_df$date_vec >= first_date) &\n  (my_temp_df$date_vec <= last_date)\n\n# use index to filter `dataframe`\nmy_temp_df_filtered <- my_temp_df %>%\n  filter(my_idx) %>%\n  glimpse()R> Rows: 15\nR> Columns: 2\nR> $ date_vec <date> 2016-06-01, 2016-06-02, 2016-06-03, 2016…\nR> $ prices   <dbl> 3.1, 3.4, 3.7, 4.0, 4.3, 4.6, 4.9, 5.2, 5…"},{"path":"classes-basicas.html","id":"lidando-com-data-e-tempo","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.5.4 Lidando com Data e Tempo","text":"O uso da classe Date é suficiente quando se está lidando apenas com datas. Em casos em que é necessário levar em consideração o horário, temos que utilizar um objeto tipo datetime.pacote base, uma das classes utilizadas para esse fim é POSIXlt, qual armazena o conteúdo de uma data na forma de uma lista. Outra classe que também é possível utilizar é POSIXct, que armazena datas como segundos contados partir de 1970-01-01. Devido ao seu formato de armazenamento, classe POSIXct ocupa menos memória computador. Junto ao lubridate, classe utilizada para representar data-tempo é POSIXct e portanto daremos prioridade essa. Vale destacar que todos os exemplos apresentados aqui também podem ser replicados para objetos tipo POSIXlt.O formato tempo/data também segue norma ISO 8601, sendo representado como ano-mês-dia horas:minutos:segundos zonadetempo (YYYY-MM-DD HH:mm:SS TMZ). Veja o exemplo seguir:O pacote lubridate também oferece funções inteligentes para criação de objetos tipo data-tempo. Essas seguem mesma linha de raciocínio que funções de criar datas. Veja seguir:Destaca-se que essa classe adiciona automaticamente o fuso horário. Caso seja necessário representar um fuso diferente, é possível fazê-lo com o argumento tz:É importante ressaltar que, para o caso de objetos tipo POSIXlt e POSIXct, operações de soma e diminuição referem-se segundos e não dias, como caso objeto da classe Date.Assim como para classe Date, existem símbolos específicos para lidar com componentes de um objeto tipo data/tempo. Isso permite formatação customizada de datas. seguir, apresentamos um quadro com os principais símbolos e os seus respectivos significados.seguir veremos como utilizar essa tabela para customizar datas.","code":"\n# creating a POSIXct object\nmy_timedate <- as.POSIXct('2021-01-01 16:00:00')\n\n# print result\nprint(my_timedate)R> [1] \"2021-01-01 16:00:00 -03\"\nlibrary(lubridate)\n\n# creating a POSIXlt object\nmy_timedate <- ymd_hms('2021-01-01 16:00:00')\n\n# print it\nprint(my_timedate)R> [1] \"2021-01-01 16:00:00 UTC\"\n# creating a POSIXlt object with custom timezone\nmy_timedate_tz <- ymd_hms('2021-01-01 16:00:00',\n                          tz = 'GMT')\n\n# print it\nprint(my_timedate_tz)R> [1] \"2021-01-01 16:00:00 GMT\"\n# Adding values (seconds) to a POSIXlt object and printing it\nprint(my_timedate_tz + 30)R> [1] \"2021-01-01 16:00:30 GMT\""},{"path":"classes-basicas.html","id":"personalizando-o-formato-de-datas","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.5.5 Personalizando o Formato de Datas","text":"notação básica para representar datas e data/tempo R pode não ser ideal em algumas situações. Brasil, por exemplo, indicar datas formato YYYY-MM-DD pode gerar bastante confusão em um relatório formal. É recomendado, portanto, modificar representação das datas para o formato esperado, isto é, DD/MM/YYYY.Para formatar uma data, utilizamos função format. Seu uso baseia-se nos símbolos de data e de horário apresentados anteriormente. partir desses, pode-se criar qualquer customização. Veja o exemplo seguir, onde apresenta-se modificação de um vetor de datas para o formato brasileiro:O mesmo procedimento pode ser realizado para objetos tipo data/tempo (POSIXct):Pode-se também customizar para formatos bem específicos. Veja seguir:","code":"\n# create vector of dates\nmy_dates <- seq(from = ymd('2021-01-01'),\n                to = ymd('2021-01-15'),\n                by = '1 day')\n\n# change format\nmy_dates_br <- format(my_dates, '%d/%m/%Y')\n\n# print result\nprint(my_dates_br)R>  [1] \"01/01/2021\" \"02/01/2021\" \"03/01/2021\" \"04/01/2021\"\nR>  [5] \"05/01/2021\" \"06/01/2021\" \"07/01/2021\" \"08/01/2021\"\nR>  [9] \"09/01/2021\" \"10/01/2021\" \"11/01/2021\" \"12/01/2021\"\nR> [13] \"13/01/2021\" \"14/01/2021\" \"15/01/2021\"\n# create vector of date-time\nmy_datetime <- ymd_hms('2021-01-01 12:00:00') + seq(0,560,60)\n\n# change to Brazilian format\nmy_dates_br <- format(my_datetime, '%d/%m/%Y %H:%M:%S')\n\n# print result\nprint(my_dates_br)R>  [1] \"01/01/2021 12:00:00\" \"01/01/2021 12:01:00\"\nR>  [3] \"01/01/2021 12:02:00\" \"01/01/2021 12:03:00\"\nR>  [5] \"01/01/2021 12:04:00\" \"01/01/2021 12:05:00\"\nR>  [7] \"01/01/2021 12:06:00\" \"01/01/2021 12:07:00\"\nR>  [9] \"01/01/2021 12:08:00\" \"01/01/2021 12:09:00\"\n# set custom format\nmy_dates_custom <- format(my_dates,\n                          'Year=%Y | Month=%m | Day=%d')\n\n# print result\nprint(my_dates_custom)R>  [1] \"Year=2021 | Month=01 | Day=01\"\nR>  [2] \"Year=2021 | Month=01 | Day=02\"\nR>  [3] \"Year=2021 | Month=01 | Day=03\"\nR>  [4] \"Year=2021 | Month=01 | Day=04\"\nR>  [5] \"Year=2021 | Month=01 | Day=05\"\nR>  [6] \"Year=2021 | Month=01 | Day=06\"\nR>  [7] \"Year=2021 | Month=01 | Day=07\"\nR>  [8] \"Year=2021 | Month=01 | Day=08\"\nR>  [9] \"Year=2021 | Month=01 | Day=09\"\nR> [10] \"Year=2021 | Month=01 | Day=10\"\nR> [11] \"Year=2021 | Month=01 | Day=11\"\nR> [12] \"Year=2021 | Month=01 | Day=12\"\nR> [13] \"Year=2021 | Month=01 | Day=13\"\nR> [14] \"Year=2021 | Month=01 | Day=14\"\nR> [15] \"Year=2021 | Month=01 | Day=15\""},{"path":"classes-basicas.html","id":"extraindo-elementos-de-uma-data","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.5.6 Extraindo Elementos de uma Data","text":"Para extrair elementos de datas tal como o ano, mês, dia, hora, minuto e segundo, uma alternativa é utilizar função format. Observe o próximo exemplo, onde recuperamos apenas horas de um objeto POSIXct: Da mesma forma, poderíamos utilizar os símbolos %M e %S para recuperar facilmente minutos e segundos de um vetor de objetos POSIXct.Outra forma é utilizar funções lubridate, tal como hour e minute: Outras funções também estão disponíveis para os demais elementos de um objeto data-hora.","code":"\nlibrary(lubridate)\n\n# create vector of date-time\nmy_datetime <- seq(from = ymd_hms('2021-01-01 12:00:00'),\n                   to = ymd_hms('2021-01-01 18:00:00'),\n                   by = '1 hour')\n\n# get hours from POSIXlt\nmy_hours <- as.numeric(format(my_datetime, '%H'))\n\n# print result\nprint(my_hours)R> [1] 12 13 14 15 16 17 18\n# create vector of date-time\nmy_datetime <- seq(from = ymd_hms('2021-01-01 12:00:00'),\n                   to = ymd_hms('2021-01-01 18:00:00'),\n                   by = '15 min')\n\n# get minutes from POSIXlt\nmy_minutes <- as.numeric(format(my_datetime, '%M'))\n\n# print result\nprint(my_minutes)R>  [1]  0 15 30 45  0 15 30 45  0 15 30 45  0 15 30 45  0 15\nR> [19] 30 45  0 15 30 45  0\n# get hours with lubridate\nprint(hour(my_datetime))R>  [1] 12 12 12 12 13 13 13 13 14 14 14 14 15 15 15 15 16 16\nR> [19] 16 16 17 17 17 17 18\n# get minutes with lubridate\nprint(minute(my_datetime))R>  [1]  0 15 30 45  0 15 30 45  0 15 30 45  0 15 30 45  0 15\nR> [19] 30 45  0 15 30 45  0"},{"path":"classes-basicas.html","id":"conhecendo-o-horário-e-a-data-atual","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.5.7 Conhecendo o Horário e a Data Atual","text":"O R inclui várias funções que permitem o usuário utilizar seu código o horário e data atual sistema. Isso é bastante útil quando se está criando registros e é importante que data e horário de execução código seja conhecida futuramente.Para conhecer o dia atual, basta utilizarmos função base::Sys.Date ou lubridate::today: Para descobrir data e horário, utilizamos função base::Sys.time ou lubridate::now: Com base nessas, podemos escrever:","code":"\nlibrary(lubridate)\n\n# get today\nprint(Sys.Date())R> [1] \"2022-11-23\"\n# print it\nprint(today())R> [1] \"2022-11-23\"\n# get time!\nprint(Sys.time())R> [1] \"2022-11-23 10:53:23 -03\"\n# get time!\nprint(now())R> [1] \"2022-11-23 10:53:23 -03\"\nlibrary(stringr)\n\n# example of log message\nmy_str <- str_c('This code was executed in ', now())\n\n# print it\nprint(my_str)R> [1] \"This code was executed in 2022-11-23 10:53:23\""},{"path":"classes-basicas.html","id":"outras-funções-úteis-5","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.5.8 Outras Funções Úteis","text":"weekdays - Retorna o dia da semana de uma ou várias datas.months - Retorna o mês de uma ou várias datas.quarters - Retorna localização de uma ou mais datas dentro dos quartis ano.OlsonNames - Retorna um vetor com zonas de tempo disponíveis R. total, são mais de 500 itens. Aqui, apresentamos apenas os primeiros cinco elementos.Sys.timezone - Retorna zona de tempo sistema.cut - Retorna um fator partir da categorização de uma classe de data e tempo.","code":"\n# set date vector\nmy_dates <- seq(from = ymd('2021-01-01'),\n                to = ymd('2021-01-5'),\n                by = '1 day')\n\n# find corresponding weekdays\nmy_weekdays <- weekdays(my_dates)\n\n# print it\nprint(my_weekdays)R> [1] \"Friday\"   \"Saturday\" \"Sunday\"   \"Monday\"   \"Tuesday\"\n# create date vector\nmy_dates <- seq(from = ymd('2021-01-01'),\n                to = ymd('2021-12-31'),\n                by = '1 month')\n\n# find months\nmy_months <- months(my_dates)\n\n# print result\nprint(my_months)R>  [1] \"January\"   \"February\"  \"March\"     \"April\"    \nR>  [5] \"May\"       \"June\"      \"July\"      \"August\"   \nR>  [9] \"September\" \"October\"   \"November\"  \"December\"\n# get quartiles of the year\nmy_quarters <- quarters(my_dates)\nprint(my_quarters)R>  [1] \"Q1\" \"Q1\" \"Q1\" \"Q2\" \"Q2\" \"Q2\" \"Q3\" \"Q3\" \"Q3\" \"Q4\" \"Q4\"\nR> [12] \"Q4\"\n# get possible timezones\npossible_tz <- OlsonNames()\n\n# print it\nprint(possible_tz[1:5])R> [1] \"Africa/Abidjan\"     \"Africa/Accra\"      \nR> [3] \"Africa/Addis_Ababa\" \"Africa/Algiers\"    \nR> [5] \"Africa/Asmara\"\n# get current timezone\nprint(Sys.timezone())R> [1] \"America/Sao_Paulo\"\n# set example date vector\nmy_dates <- seq(from = ymd('2021-01-01'),\n                to = ymd('2021-03-01'),\n                by = '5 days')\n\n# group vector based on monthly breaks\nmy_month_cut <- cut(x = my_dates,\n                    breaks = 'month')\n\n# print result\nprint(my_month_cut)R>  [1] 2021-01-01 2021-01-01 2021-01-01 2021-01-01 2021-01-01\nR>  [6] 2021-01-01 2021-01-01 2021-02-01 2021-02-01 2021-02-01\nR> [11] 2021-02-01 2021-02-01\nR> Levels: 2021-01-01 2021-02-01\n# set example datetime vector\nmy_datetime <- as.POSIXlt('2021-01-01 12:00:00') + seq(0,250,15)\n\n# set groups for each 30 seconds\nmy_cut <- cut(x = my_datetime, breaks = '30 secs')\n\n# print result\nprint(my_cut)R>  [1] 2021-01-01 12:00:00 2021-01-01 12:00:00\nR>  [3] 2021-01-01 12:00:30 2021-01-01 12:00:30\nR>  [5] 2021-01-01 12:01:00 2021-01-01 12:01:00\nR>  [7] 2021-01-01 12:01:30 2021-01-01 12:01:30\nR>  [9] 2021-01-01 12:02:00 2021-01-01 12:02:00\nR> [11] 2021-01-01 12:02:30 2021-01-01 12:02:30\nR> [13] 2021-01-01 12:03:00 2021-01-01 12:03:00\nR> [15] 2021-01-01 12:03:30 2021-01-01 12:03:30\nR> [17] 2021-01-01 12:04:00\nR> 9 Levels: 2021-01-01 12:00:00 ... 2021-01-01 12:04:00"},{"path":"classes-basicas.html","id":"dados-omissos---na-not-available","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.6 Dados Omissos - NA (Not available)","text":"Uma das principais inovações R em relação outras linguagens de programação é representação de dados omissos através de objetos da classe NA (Available). falta de dados pode ter inúmeros motivos, tal como falha na coleta de informações ou simplesmente não existência dos mesmos. Esses casos são tratados por meio da remoção ou da substituição dos dados omissos antes realizar uma análise mais profunda. identificação desses casos, portanto, é de extrema importância.","code":""},{"path":"classes-basicas.html","id":"definindo-valores-na","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.6.1 Definindo Valores NA","text":"Para definirmos os casos omissos nos dados, basta utilizar o símbolo NA:Vale destacar que operação de qualquer valor NA com outro sempre resultará em NA.Isso exige cuidado quando se está utilizando alguma função com cálculo recursivo, tal como cumsum e cumprod. Nesses casos, todo valor consecutivo ao NA será transformado em NA. Veja os exemplos seguir com duas funções:\nToda vez que utilizar funções cumsum e\ncumprod, certifique-se de que não existe algum valor\nNA vetor de entrada. Lembre-se de que todo\nNA é contagiante e o cálculo recursivo irá resultar em um\nvetor repleto de dados faltantes.\n","code":"\n# a vector with NA\nmy_x <- c(1, 2, NA, 4, 5)\n\n# print it\nprint(my_x)R> [1]  1  2 NA  4  5\n# example of NA interacting with other objects\nprint(my_x + 1)R> [1]  2  3 NA  5  6\n# set vector with NA\nmy_x <- c(1:5, NA, 5:10)\n\n# print cumsum (NA after sixth element)\nprint(cumsum(my_x))R>  [1]  1  3  6 10 15 NA NA NA NA NA NA NA\n# print cumprod (NA after sixth element)\nprint(cumprod(my_x))R>  [1]   1   2   6  24 120  NA  NA  NA  NA  NA  NA  NA"},{"path":"classes-basicas.html","id":"encontrando-e-substituindo-valores-na","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.6.2 Encontrando e Substituindo Valores NA","text":"Para encontrar os valores NA em um vetor, basta utilizar função .na: Para substituí-los, use indexação com saída de .na:Outra maneira de limpar o objeto é utilizar função na.omit, que retorna o mesmo objeto mas sem os valores NA. Note, porém, que o tamanho vetor irá mudar e o objeto será da classe omit, o que indica que o vetor resultante não inclui os NA e apresenta, também, posição dos elementos NA encontrados. Apesar de o tipo de objeto ter sido trocado, devido ao uso de na.omit, propriedades básicas vetor inicial se mantêm. Por exemplo: o uso de nchar objeto resultante é possível.Para outros objetos, porém, recomenda-se cautela quando uso da função na.omit.","code":"\n# set vector with NA\nmy_x <- c(1:2, NA, 4:10)\n\n# find location of NA\nidx_na <- is.na(my_x)\nprint(idx_na)R>  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\nR> [10] FALSE\n# set vector\nmy_x <- c(1, NA, 3:4, NA)\n\n# replace NA for 2\nmy_x[is.na(my_x)] <- 2\n\n# print result\nprint(my_x)R> [1] 1 2 3 4 2\n# set vector\nmy_char <- c(letters[1:3], NA, letters[5:8])\n\n# print it\nprint(my_char)R> [1] \"a\" \"b\" \"c\" NA  \"e\" \"f\" \"g\" \"h\"\n# use na.omit to remove NA\nmy_char <- na.omit(my_char)\n\n# print result\nprint(my_char)R> [1] \"a\" \"b\" \"c\" \"e\" \"f\" \"g\" \"h\"\nR> attr(,\"na.action\")\nR> [1] 4\nR> attr(,\"class\")\nR> [1] \"omit\"\n# trying nchar on a na.omit object\nprint(nchar(my_char))R> [1] 1 1 1 1 1 1 1"},{"path":"classes-basicas.html","id":"outras-funções-úteis-6","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.6.3 Outras Funções Úteis","text":"complete.cases - Retorna um vetor lógico que indica se linhas objeto possuem apenas valores não omissos. Essa função é usada exclusivamente para dataframes e matrizes.","code":"\n# create matrix\nmy_mat <- matrix(1:15, nrow = 5)\n\n# set an NA value\nmy_mat[2,2] <- NA\n\n# print index with rows without NA\nprint(complete.cases(my_mat))R> [1]  TRUE FALSE  TRUE  TRUE  TRUE"},{"path":"classes-basicas.html","id":"exerc-classes-basicas","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"7.7 Exercícios","text":"","code":""},{"path":"classes-basicas.html","id":"q.1-5","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.1","text":"Considere os seguintes os vetores x e y:Qual é soma dos elementos de um novo vetor resultante da multiplicação entre os elementos de x e y?\n\nSolução\n\n","code":"set.seed(7)\nx <- sample (1:3, size = 5, replace = T)\ny <- sample (1:3, size = 5, replace = T)set.seed(7)\n\nx <- sample (1:3, size = 5, replace = T)\ny <- sample (1:3, size = 5, replace = T)\n\n# solution\nmy_sol <- sum(x*y)"},{"path":"classes-basicas.html","id":"q.2-5","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.2","text":"Caso realizássemos uma soma cumulativa de uma sequência entre 1 e 100, em qual elemento esta soma iria passar de 50?\n\nSolução\n\n","code":"my_sum <- cumsum(1:100)\n\n# solution\nmy_sol <- (which(my_sum > 50)[1])"},{"path":"classes-basicas.html","id":"q.3-4","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.3","text":"Utilizando o R, crie uma sequência em objeto chamado seq_1 entre -15 e 10, onde o intervalo entre valores é sempre igual 2. Qual o valor da soma dos elementos de seq_1?\n\nSolução\n\n","code":"# solution\nseq_1 <- seq(from = -15, to = 10, by = 2)\n\n# solution\nmy_sol <- sum(seq_1)"},{"path":"classes-basicas.html","id":"q.4-4","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.4","text":"Defina outro objeto chamado seq_2 contendo uma sequência de tamanho 1000, com valores entre 0 e 100. Qual é o desvio padrão (função sd) dessa sequência?\n\nSolução\n\n","code":"seq_2 <- seq(from = 0, \n             to = 100, \n             length.out = 1000)\n\n# solution\nmy_sol <- sd(seq_2)"},{"path":"classes-basicas.html","id":"q.5-4","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.5","text":"Calcule soma entre vetores seq_1 e seq_2 (veja exercício anterior). Esta operação funcionou apesar tamanho diferente dos vetores? Explique sua resposta. Caso funcionar, qual o maior valor vetor resultante?\n\nSolução\n\nSim, funcionou, mas com um aviso de warning: _ “o comprimento objeto mais longo não é um múltiplo comprimento objeto mais curto” _. explicação é que sempre que R encontra operações com vetor de tamanhos diferentes, ele usa regra de reciclagem, onde o vetor mais curto é repetido quantas vezes forem necessárias para coincidir com o tamanho vetor mais longo. livro, veja seção sobre vetores numéricos para maiores detalhes.","code":"seq_1 <- seq(from = -10, to = 10, by = 2)\nseq_2 <- seq(from = 0, \n             to = 100, \n             length.out = 1000)\n\n# solution\nmy_sol <- max(seq_1+seq_2)"},{"path":"classes-basicas.html","id":"q.6-4","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.6","text":"Vamos supor que, em certa data, você comprou 100 ações de uma empresa, price_purchase reais por ação. Depois de algum tempo, você vendeu 30 ações por 18 reais cada e 70 ações restantes foram vendidas por 22 reais em um dia posterior. Usando um script em R, estruture este problema financeiro criando objetos numéricos. Qual é o lucro bruto desta transação mercado de ações?\n\nSolução\n\n","code":"total_shares <- 100\nprice_purchase <- 15\n\ntotal_purchase_value <- total_shares*price_purchase\n\nqtd_sell_1 <- 30\nprice_sell_1 <- 18\ntotal_sell_1 <- qtd_sell_1*18\n\nqtd_sell_2 <- total_shares-qtd_sell_1\nprice_sell_2 <- 22\ntotal_sell_2 <- qtd_sell_2*price_sell_2\n\ntotal_sell_value <- total_sell_1 + total_sell_2\n\n# solution\nmy_sol <- total_sell_value - total_purchase_value"},{"path":"classes-basicas.html","id":"q.7-4","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.7","text":"Crie um vetor x de acordo com fórmula seguir, onde \\(=1...100\\). Qual é o valor da soma dos elementos de x?\\[\nx_i=\\frac{-1^{+1}}{2i-1}\n\\]\n\nSolução\n\n","code":"i <- 1:100\n\nx <- ( (-1)^(i+1) )/(2*i - 1)\n\n# solution\nmy_sol <- sum(x)"},{"path":"classes-basicas.html","id":"q.8-3","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.8","text":"Crie um vetor \\(z_i\\) de acordo com fórmula seguir onde \\(x_i=1...50\\) e \\(y_i=50...1\\). Qual é o valor da soma dos elementos de \\(z_i\\)? Dica: veja o funcionamento da função dplyr::lag.\\[\nz_i=\\frac{y_i - x_{-1}}{y_{-2}}\n\\]\n\nSolução\n\n","code":"x <- 1:50\ny <- 50:1\n\n# solution using `base`\nz <- (y - c(NA, x[1:(length(x)-1)]))/c(NA, NA, y[1:(length(y)-2)])\n\n# solution with tidyverse (much prettier huh!)\nz <- (y - lag(x, n = 1))/lag(y, n = 2)\n\n# solution (be aware of the NA values)\nmy_sol <- sum(z, na.rm = TRUE)"},{"path":"classes-basicas.html","id":"q.9-3","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.9","text":"Usando uma semente de valor 22 em set.seed(), crie um objeto chamado x com valores aleatórios da distribuição Normal com média igual 10 e desvio padrão igual 10. Usando função cut, crie outro objeto que defina dois grupos com base em valores de x maiores que 15 e menores que 15. Qual quantidade de observações primeiro grupo?\n\nSolução\n\n","code":"my_seed <- sample(1:50, 1)\n\nset.seed(my_seed)\nx <- rnorm(n = 1000, mean = 10, sd = 10)\n\nmy_group <- cut(x, \n                breaks = c(-Inf, 15, Inf))\n\n# solution\nmy_sol <- table(my_group)[1]"},{"path":"classes-basicas.html","id":"q.10-2","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.10","text":"Crie o seguinte objeto com o código seguir:Qual quantidade de vezes que letra 'x' é encontrada objeto de texto resultante?\n\nSolução\n\n","code":"set.seed(15)\nmy_char <- paste(sample(letters, 5000, replace = T), \n                 collapse = '')set.seed(15)\nmy_char <- paste(sample(letters, 5000, replace = T), \n                 collapse = '')\n\n# solution\nmy_sol <- str_count(my_char, 'x')"},{"path":"classes-basicas.html","id":"q.11-1","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.11","text":"Baseado objeto my_char criado anteriormente, caso dividíssemos o mesmo em diversos pedaços menores utilizando letra \"b\", qual é o número de caracteres maior pedaço encontrado?\n\nSolução\n\n","code":"set.seed(15)\nmy_char <- paste(sample(letters, 5000, replace = T), \n                 collapse = '')\n\nmy_split <- str_split(my_char, pattern = 'b')[[1]]\n\n# find number of characters in each\nn_chars <- sapply(my_split, nchar)\n\n# solution\nmy_sol <- n_chars[which.max(n_chars)]"},{"path":"classes-basicas.html","id":"q.12","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.12","text":"endereço https://www.gutenberg.org/files/1342/1342-0.txt é possível acessar um arquivo .txt contendo o texto integral livro Pride Prejudice de Jane Austen. Utilize funções download.file e readr::read_lines para importar o livro inteiro como um vetor de caracteres chamado my_book R. Quantas linhas o objeto resultante possui?\n\nSolução\n\n","code":"my_link <- 'https://www.gutenberg.org/ebooks/2264.txt.utf-8'\n\nmy_book <- readr::read_lines(my_link)\n\n# solution\nmy_sol <- length(my_book)"},{"path":"classes-basicas.html","id":"q.13","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.13","text":"Junte o vetor de caracteres em my_book para um único valor (texto) em outro objeto chamado full_text usando função paste0(my_book, collapse = '\\n'). Utilizando este último e pacote stringr, quantas vezes palavra 'King' é repetida na totalidade texto?\n\nSolução\n\n","code":"my_link <- 'https://www.gutenberg.org/ebooks/2264.txt.utf-8'\n\nmy_book <- readr::read_lines(my_link)\n\n# solution\nfull_text <- paste0(my_book, collapse = '\\n')\nmy_sol <- stringr::str_count(full_text, stringr::fixed('King'))"},{"path":"classes-basicas.html","id":"q.14","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.14","text":"Para o objeto full_text criado anteriormente, utilize função stringr::str_split para quebrar o texto inteiro em função de espaços em branco. Com base nesse, crie uma tabela de frequência. Qual palavra mais utilizada texto? Dica: Remova todos os casos de caracteres vazios ('').\n\nSolução\n\n","code":"my_link <- 'https://www.gutenberg.org/ebooks/2264.txt.utf-8'\n\nmy_book <- readr::read_lines(my_link)\n\n# solution\nfull_text <- paste0(my_book, collapse = '\\n')\nmy_split <- stringr::str_split(full_text, \n                               pattern = stringr::fixed(' '))[[1]]\n\n# remove empty\nmy_split <- my_split[my_split != '']\n\nmy_tab <- sort(table(my_split), decreasing = TRUE)\n\n# solution\nmy_sol <- names(my_tab[1])"},{"path":"classes-basicas.html","id":"q.15","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.15","text":"Assumindo que uma pessoa nascida em 2000-05-12 irás viver 100 anos, qual é o número de dias de aniversário que cairão em um final de semana (sábado ou domingo)? Dica: use operador %% para checar uma condição múltipla nos dados.\n\nSolução\n\n","code":"b_day <- as.Date('2000-05-12')\nn_years <- 100\n\nb_day_vec <- seq(b_day, b_day + n_years*365, by = '1 year')\n\nw_days <- weekdays(b_day_vec)\n\nn_weekend <- sum(\n  stringr::str_to_lower(w_days) %in% c('sábado', \"domingo\")\n  )\n\n# solution\nmy_sol <- n_weekend"},{"path":"classes-basicas.html","id":"q.16","chapter":"Capítulo 7 As Classes Básicas de Objetos","heading":"Q.16","text":"Qual data e horário é localizado 10^{4} segundos após 2021-02-02 11:50:02?\n\nSolução\n\n","code":"time_1 <- as.POSIXct('2021-02-02 11:50:02')\nmy_sec <- 10000\n\nmy_sol <- time_1 + my_sec"},{"path":"programacao.html","id":"programacao","chapter":"Capítulo 8 Programando com o R","heading":"Capítulo 8 Programando com o R","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"criando-funções","chapter":"Capítulo 8 Programando com o R","heading":"8.1 Criando Funções","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"loops","chapter":"Capítulo 8 Programando com o R","heading":"8.2 Utilizando Loops (comando for)","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"execuções-condicionais-if-else-switch","chapter":"Capítulo 8 Programando com o R","heading":"8.3 Execuções Condicionais (if, else, switch)","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"utilizando-as-funções-da-família-apply","chapter":"Capítulo 8 Programando com o R","heading":"8.4 Utilizando as Funções da Família apply","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"função-lapply","chapter":"Capítulo 8 Programando com o R","heading":"8.4.1 Função lapply","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"função-sapply","chapter":"Capítulo 8 Programando com o R","heading":"8.4.2 Função sapply","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"função-tapply","chapter":"Capítulo 8 Programando com o R","heading":"8.4.3 Função tapply","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"função-mapply","chapter":"Capítulo 8 Programando com o R","heading":"8.4.4 Função mapply","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"função-apply","chapter":"Capítulo 8 Programando com o R","heading":"8.4.5 Função apply","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"utilizando-pacote-purrr","chapter":"Capítulo 8 Programando com o R","heading":"8.5 Utilizando Pacote purrr","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"função-purrrmap","chapter":"Capítulo 8 Programando com o R","heading":"8.5.1 Função purrr::map","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"função-purrrsafely","chapter":"Capítulo 8 Programando com o R","heading":"8.5.2 Função purrr::safely","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"função-purrrpmap","chapter":"Capítulo 8 Programando com o R","heading":"8.5.3 Função purrr::pmap","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"manipulação-de-dados-com-dplyr","chapter":"Capítulo 8 Programando com o R","heading":"8.6 Manipulação de Dados com dplyr","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"operações-de-grupo-com-dplyr","chapter":"Capítulo 8 Programando com o R","heading":"8.6.1 Operações de Grupo com dplyr","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"operações-de-grupo-complexas-com-dplyr","chapter":"Capítulo 8 Programando com o R","heading":"8.6.2 Operações de Grupo Complexas com dplyr","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"programacao.html","id":"exerc-programacao","chapter":"Capítulo 8 Programando com o R","heading":"8.7 Exercícios","text":"","code":""},{"path":"programacao.html","id":"q.1-6","chapter":"Capítulo 8 Programando com o R","heading":"Q.1","text":"Crie uma função chamada say_my_name que tome como entrada um nome de pessoa e mostre na tela o texto name …. Dentro escopo da função, utilize comentários para descrever o propósito da função, suas entradas e saídas.\n\nSolução\n\n","code":"say_my_name <- function(name_in) {\n  # Print a single name in the prompt\n  #\n  # ARGS: name_in - Name to be printed\n  #\n  # RETURNS: TRUE, if sucessfull\n  \n  my_msg <- paste0('Your name is ', name_in)\n  \n  message(my_msg)\n  \n  # invisible will omit output if function is called without definition of output\n  return(invisible(TRUE))\n}\n\n# testing\nsay_my_name('Marcelo')"},{"path":"programacao.html","id":"q.2-6","chapter":"Capítulo 8 Programando com o R","heading":"Q.2","text":"Implemente um teste para os objetos de entrada, de forma que, quando o nome de entrada não da classe character, um erro é retornado ao usuário. Teste sua nova função e verifique se mesma está funcionando conforme esperado.\n\nSolução\n\n","code":"say_my_name <- function(name_in) {\n  # Prints a single name in the prompt\n  #\n  # ARGS: name_in - Name to be printed\n  # RETURNS: TRUE, if sucessfull\n  \n  # check inputs\n  if (class(name_in) != 'character') {\n    stop('Class of input name_in is ', class(name_in), \n         ' and not character!')\n  }\n  \n  if (length(name_in) > 1) {\n    stop('Input name_in has length ', length(name_in), \n         ' and not 1 (this function only works for one name)!')\n  }\n  \n  \n  \n  my_msg <- paste0('Your name is ', name_in, '.')\n  \n  message(my_msg)\n  \n  # invisible makes sure the fct doesnt return anything if not output is set\n  return(invisible(TRUE))\n}\n\n# testing Ok\nsay_my_name('Marcelo')\n\n# testing vector\nsay_my_name(c('Richard', 'Michael'))\n\n# testing class\nsay_my_name(1)"},{"path":"programacao.html","id":"q.3-5","chapter":"Capítulo 8 Programando com o R","heading":"Q.3","text":"Crie um vetor com cinco nomes quaisquer, chamado my_names. Utilizando um loop, aplique função say_my_name para cada elemento de my_names.\n\nSolução\n\n","code":"say_my_name <- function(name_in) {\n  # Prints a single name in the prompt\n  #\n  # ARGS: name_in - Name to be printed\n  # RETURNS: TRUE, if sucessfull\n  \n  # check inputs\n  if (class(name_in) != 'character') {\n    stop('Class of input name_in is ', class(name_in), \n         ' and not character!')\n  }\n  \n  if (length(name_in) > 1) {\n    stop('Input name_in has length ', length(name_in), \n         ' and not 1 (this function only works for one name)!')\n  }\n  \n  \n  \n  my_msg <- paste0('Your name is ', name_in, '\\n')\n  \n  message(my_msg)\n  \n  # invisible makes sure the fct doesnt return anything if not output is set\n  return(invisible(TRUE))\n}\n\nmy_names <- c('Marcelo', 'Ricardo', 'Tarcizio')\n\nfor (i_names in my_names) {\n  say_my_name(i_names)\n}"},{"path":"programacao.html","id":"q.4-5","chapter":"Capítulo 8 Programando com o R","heading":"Q.4","text":"banco de dados Brasil.IO24 encontrarás uma tabela com nomes e gêneros derivados de uma das pesquisas IBGE. Importe os dados arquivo para R e, usando um loop, aplique função say_my_name 15 nomes aleatórios banco de dados. Dica: neste caso, você pode baixar os dados direto link usando readr::read_csv(LINK).\n\nSolução\n\n","code":"say_my_name <- function(name_in) {\n  # Prints a single name in the prompt\n  #\n  # ARGS: name_in - Name to be printed\n  # RETURNS: TRUE, if sucessfull\n  \n  # check inputs\n  if (class(name_in) != 'character') {\n    stop('Class of input name_in is ', class(name_in), \n         ' and not character!')\n  }\n  \n  if (length(name_in) > 1) {\n    stop('Input name_in has length ', length(name_in), \n         ' and not 1 (this function only works for one name)!')\n  }\n  \n  \n  \n  my_msg <- paste0('Your name is ', name_in, '.')\n  \n  message(my_msg)\n  \n  # invisible makes sure the fct doesnt return anything if not output is set\n  return(invisible(TRUE))\n}\n\nlibrary(tidyverse)\n\n# get CURRENT url from https://data.chhs.ca.gov/dataset/most-popular-baby-names-2005-current\nmy_url <- 'https://data.brasil.io/dataset/genero-nomes/grupos.csv.gz'\n\ndf_names <- read_csv(my_url, col_types = cols())\n\nmy_names <- sample(df_names$name, 15)\n\nfor (i_name in my_names) {\n  \n  say_my_name(i_name)\n}"},{"path":"programacao.html","id":"q.5-5","chapter":"Capítulo 8 Programando com o R","heading":"Q.5","text":"Refaça o exercício anterior utilizando comandos sapply ou purrr::map.\n\nSolução\n\n","code":"say_my_name <- function(name_in) {\n  # Prints a single name in the prompt\n  #\n  # ARGS: name_in - Name to be printed\n  # RETURNS: TRUE, if sucessfull\n  \n  # check inputs\n  if (class(name_in) != 'character') {\n    stop('Class of input name_in is ', class(name_in), \n         ' and not character!')\n  }\n  \n  if (length(name_in) > 1) {\n    stop('Input name_in has length ', length(name_in), \n         ' and not 1 (this function only works for one name)!')\n  }\n    \n  my_msg <- paste0('Your name is ', name_in, '\\n')\n  \n  message(my_msg)\n  \n  # invisible makes sure the fct doesnt return anything if not output is set\n  return(invisible(TRUE))\n}\n\nlibrary(tidyverse)\nlibrary(purrr)\n\n# get CURRENT url from https://data.chhs.ca.gov/dataset/most-popular-baby-names-2005-current\nmy_url <- 'https://data.brasil.io/dataset/genero-nomes/grupos.csv.gz'\n\ndf_names <- read_csv(my_url, col_types = cols())\n\n# using sapply\nvec_out <- sapply(sample(df_names$name, 15),\n                  say_my_name)\nglimpse(vec_out)\n\n# using purrr\nl_out <- map(sample(df_names$name, 15),\n             say_my_name)\nglimpse(vec_out)"},{"path":"programacao.html","id":"q.6-5","chapter":"Capítulo 8 Programando com o R","heading":"Q.6","text":"Use o pacote BatchGetSymbols para baixar dados índice SP500 ('^GSPC'), Ibovespa ('^BVSP'), FTSE ('^FSTE') e Nikkei 225 ('^N225') de '2010-01-01' até data atual. Com os dados importados, use um loop para calcular o retorno médio, máximo e mínimo de cada índice durante o período analisado. Salve todos os resultados em uma tabela única e mostre prompt R.\n\nSolução\n\n","code":"library(BatchGetSymbols)\n\nindexes <- c('^BVSP', '^GSPC', '^FTSE', '^N225')\n\ndf_indices <- BatchGetSymbols(tickers = indexes, \n                              first.date = '2010-01-01',\n                              last.date = Sys.Date())[[2]]\n\ntab <- tibble()\nfor (index in indexes) {\n  \n  temp_df <- df_indices %>%\n    filter(ticker == index)\n  \n  avg_ret <- mean(temp_df$ret.adjusted.prices, \n                  na.rm = TRUE)\n  max_ret <- max(temp_df$ret.adjusted.prices, \n                 na.rm = TRUE)\n  min_ret <- min(temp_df$ret.adjusted.prices, \n                 na.rm = TRUE)\n  \n  # save result\n  tab <- bind_rows(tab, tibble(index = index,\n                               mean_ret = avg_ret, \n                               max_ret = max_ret, \n                               min_ret = min_ret))\n  \n}\n\nprint(tab)"},{"path":"programacao.html","id":"q.7-5","chapter":"Capítulo 8 Programando com o R","heading":"Q.7","text":"Refaça o exercício anterior utilizando funções group_by e summarise, ambas pacote dplyr.\n\nSolução\n\n","code":"library(BatchGetSymbols)\n\nindexes <- c('^BVSP', '^GSPC', '^FTSE', '^N225')\n\ndf_indices <- BatchGetSymbols(tickers = indexes, \n                              first.date = '2010-01-01',\n                              last.date = Sys.Date())[[2]]\n\ntab_tidy <- df_indices %>%\n  group_by(ticker) %>%\n  summarise(mean_ret = mean(ret.adjusted.prices, na.rm = TRUE),\n            max_ret = max(ret.adjusted.prices, na.rm = TRUE),\n            min_ret = min(ret.adjusted.prices, na.rm = TRUE))\n\nprint(tab_tidy)"},{"path":"programacao.html","id":"q.8-4","chapter":"Capítulo 8 Programando com o R","heading":"Q.8","text":"site Rstudio CRAN logs25 você encontrará dados sobre estatísticas de download para distribuição de base de R na seção Daily R downloads. Usando suas habilidades de programação, importe todos os dados disponíveis entre 2020-01-01 e 2020-01-15 e agregue-os em uma única tabela. Qual país apresenta maior contagem de downloads R?\n\nSolução\n\n","code":"# set function that will download the files\nread_cranlogs_files <- function(date_in) {\n  # Reads log files from http://cran-logs.rstudio.com/\n  #\n  # ARGS: date_in - date of log data\n  require(tidyverse)\n  require(lubridate)\n  \n  url_dl <- paste0('http://cran-logs.rstudio.com/', year(date_in), '/',\n                   date_in, '-r.csv.gz')\n  \n  cat('\\nReading ', url_dl)\n  \n  df <- read_csv(url_dl, col_types = cols())\n  \n  return(df)\n}\n\n# find out the availabe dates in url\nlibrary(rvest)\nlibrary(lubridate)\n\navailable_links <- read_html('http://cran-logs.rstudio.com/') %>%\n  html_nodes(css = 'a') %>%\n  html_attr('href')\n\n# only keep links for R download (those with -r.csv.gz pattern)\nidx <- str_detect(available_links, '-r.csv.gz')\nr_links <- available_links[idx]\n\n# find out dates \ndates_dls <- ymd(basename(r_links))\nmax_date <- max(dates_dls)\n\nfirst_date <- as.Date('2020-01-01')\nlast_date <- as.Date('2020-01-15')\n\nmy_dates <- seq(first_date, \n                last_date, \n                by = '1 day')\n\nlibrary(purrr) \nlibrary(tidyverse)\n\nl_out <- map(my_dates, \n             safely(read_cranlogs_files, \n                    otherwise = tibble())) # return empty tibble in case of error\n\ndf_cranlogs <- bind_rows(map(l_out, 'result'))\n\n# solution \nmy_sol <- names(sort(table(df_cranlogs$country), \n               decreasing = TRUE)[1])"},{"path":"limpando-estruturando.html","id":"limpando-estruturando","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"Capítulo 9 Estruturando e Limpando Dados","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"limpando-estruturando.html","id":"o-formato-do-dataframe","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"9.1 O Formato do dataframe","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"limpando-estruturando.html","id":"conversão-entre-long-e-wide","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"9.1.1 Conversão entre long e wide","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"limpando-estruturando.html","id":"convertendo-listas-em-dataframes","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"9.2 Convertendo Listas em dataframes","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"limpando-estruturando.html","id":"fct-replace","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"9.3 Eliminando Outliers","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"limpando-estruturando.html","id":"desinflacionando-dados-de-preços","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"9.4 Desinflacionando Dados de Preços","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"limpando-estruturando.html","id":"modificando-a-frequência-temporal-dos-dados","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"9.5 Modificando a Frequência Temporal dos Dados","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"limpando-estruturando.html","id":"exerc-limpando-estruturando","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"9.6 Exercícios","text":"","code":""},{"path":"limpando-estruturando.html","id":"q.1-7","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"Q.1","text":"Considere o dataframe criado com o código seguir:O formato dataframe é longo ou largo? Explique sua resposta.\n\nSolução\n\nO formato é longo: temos dados empilhados para duas ações diferentes. Note que, com adição de novas tickers, tabela cresce com novas linhas. Novas variáveis podem ser facilmente adicionadas com novas colunas.","code":"library(tidyverse)\n\nmy_N <- 100\n\ndf <- bind_rows(tibble(ticker = rep('STOCK 1', my_N),\n                       ref_date = Sys.Date() + 1:my_N,\n                       price = 100 + cumsum(rnorm(my_N))),\n                tibble(ticker = rep('STOCK 2', my_N),\n                       ref_date = Sys.Date() + 1:my_N,\n                       price = 100 + cumsum(rnorm(my_N))) )\n\nprint(df)"},{"path":"limpando-estruturando.html","id":"q.2-7","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"Q.2","text":"Modifique o formato dataframe anterior, de longo para largo ou vice-versa.\n\nSolução\n\n","code":"library(tidyverse)\n\nmy_N <- 100\n\ndf <- bind_rows(tibble(ticker = rep('STOCK 1', my_N),\n                       ref_date = Sys.Date() + 1:my_N,\n                       price = 100 + cumsum(rnorm(my_N))),\n                tibble(ticker = rep('STOCK 2', my_N),\n                       ref_date = Sys.Date() + 1:my_N,\n                       price = 100 + cumsum(rnorm(my_N))) )\n\nprint(df)library(tidyverse)\n\nmy_N <- 100\n\ndf <- bind_rows(tibble(ticker = rep('STOCK 1', my_N),\n                       ref_date = Sys.Date() + 1:my_N,\n                       price = 100 + cumsum(rnorm(my_N))),\n                tibble(ticker = rep('STOCK 2', my_N),\n                       ref_date = Sys.Date() + 1:my_N,\n                       price = 100 + cumsum(rnorm(my_N))) )\n\nprint(df)\n\n# convert from long to wide\ndf_wide <- spread(data = df, \n                  key = 'ticker',\n                  value = 'price')\n\n# print result\nprint(df_wide)"},{"path":"limpando-estruturando.html","id":"q.3-6","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"Q.3","text":"Considere seguinte lista:Agrege todos dataframes em my_l para um objeto único usando funções .call ou dplyr::bind_rows. O que aconteceu com os dados de df1 onde colunas v e z não existem?\n\nSolução\n\nQuando bind_rows não encontra mesma coluna na junção de tabelas diferentes, os dados faltantes são definidos como NAs. Veja seguir:","code":"library(tidyverse)\n\nmy_l <- list(df1 = tibble(x = 1:100, y = runif(100)),\n             df2 = tibble(x = 1:100, y = runif(100), v = runif(100)),\n             df3 = tibble(x = 1:100, y = runif(100), z = runif(100)) )library(tidyverse)\n\nmy_l <- list(df1 = tibble(x = 1:100, y = runif(100)),\n             df2 = tibble(x = 1:100, y = runif(100), v = runif(100)),\n             df3 = tibble(x = 1:100, y = runif(100), z = runif(100)) )\n\n# solution with bind_rows\nbind_df1 <- bind_rows(my_l)\n\n# solution with do.cal\nbind_df2 <- do.call(bind_rows, my_l)\n\n# check solutions match\nidentical(bind_df1, bind_df2)\n\nprint(bind_df1)\n# the missing data points were set as NA values"},{"path":"limpando-estruturando.html","id":"q.4-6","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"Q.4","text":"Utilize pacote BatchGetSymbols para baixar os dados índice SP500 ('^GSPC') desde 1950-01-01 até 2021-01-01. Quais é soma dos 5 maiores retornos positivos índice?\n\nSolução\n\n","code":"library(BatchGetSymbols)\n\nticker <- '^GSPC'\nfirst_date <- '1950-01-01'\nlast_date <- '2021-01-01'\ndf_SP500 <- BatchGetSymbols(tickers = '^GSPC', \n                            first.date = first_date,\n                            last.date = last_date)[[2]]\n\nselect_n <- 5\ntab <- dplyr::tibble(position = 1:select_n,\n              top5_positive = sort(df_SP500$ret.adjusted.prices, \n                                   decreasing = TRUE)[1:select_n],\n              top5_negative = sort(df_SP500$ret.adjusted.prices, \n                                   decreasing = FALSE)[1:select_n])\n\nprint(tab)\n\nmy_sol <- sum(tab$top5_positive)"},{"path":"limpando-estruturando.html","id":"q.5-6","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"Q.5","text":"Use função replace_outliers (veja seção 9.3), criada neste capítulo, para remover outliers de todas colunas numéricas dos dados SP500 importados anteriormente com my_prob = 0.025. Quantas linhas foram perdidas neste processo de limpeza?\n\nSolução\n\n","code":"library(BatchGetSymbols)\nlibrary(purrr)\n\nticker <- '^GSPC'\nfirst_date <- '1950-01-01'\nlast_date <- '2021-01-01'\ndf_SP500 <- BatchGetSymbols(tickers = '^GSPC', \n                            first.date = first_date,\n                            last.date = last_date)[[2]]\n\nreplace_outliers <- function(col_in, my_prob = 0.05) {\n  # Replaces outliers from a vector\n  #\n  # INPUTS: col_in The vector\n  #         my_prob Probability of quantiles (p and 1-p)\n  #\n  # OUTPUT: A vector\n  \n  # return if class is other than numeric\n  if (!(class(col_in) %in% c('numeric', 'integer'))) return(col_in)\n  \n  my_outliers <- stats::quantile(x = col_in,\n                                 probs = c(my_prob, 1-my_prob),\n                                 na.rm = TRUE)\n  \n  idx <- (col_in <= my_outliers[1])|(col_in >= my_outliers[2])\n  col_in[idx] <- NA\n  \n  return(col_in)\n  \n}\n\n# remove outlivers from vectors\nl_out <- map(df_SP500, replace_outliers, my_prob = 0.025)\n\ndf_SP500_nooutlier <- na.omit(as_tibble(l_out))\n\nnrow_1 <- nrow(df_SP500)\nnrow_2 <- nrow(df_SP500_nooutlier)\n\nmy_sol <- nrow_1 - nrow_2"},{"path":"limpando-estruturando.html","id":"q.6-6","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"Q.6","text":"Use função BatchGetSymbols::BatchGetSymbols para baixar os preços índice FTSE ('^FTSE') de 2010-01-01 até 2021-01-01. Em seguida, reconstrua os dados na frequência anual, definindo cada valor ano como sendo última observação período. Dica: veja função dplyr::summary_all para uma forma funcional de agregar todas colunas de um dataframe.\n\nSolução\n\n","code":"library(BatchGetSymbols)\n\nticker <- '^FTSE'\n\nfirst_date <- '2010-01-01'\nlast_date <- '2021-01-01'\n\ndf_FTSE_daily <- BatchGetSymbols(tickers = ticker, \n                            first.date = first_date,\n                            last.date = last_date)[[2]]\n\n# change from daily to annual\ndf_FTSE_yearly <- df_FTSE_daily %>%\n  mutate(ref_year = lubridate::year(ref.date)) %>%\n  group_by(ref_year) %>%\n  summarise_all(.funs = last)\n\nprint(df_FTSE_yearly)"},{"path":"limpando-estruturando.html","id":"q.7-6","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"Q.7","text":"Use os mesmos dados diários FTSE e reconstrua os dados na frequência mensal, novamente utilizando última observação período.\n\nSolução\n\n","code":"library(BatchGetSymbols)\n\nticker <- '^FTSE'\n\nfirst_date <- '2010-01-01'\nlast_date <- '2021-01-01'\n\ndf_FTSE_daily <- BatchGetSymbols(tickers = ticker, \n                            first.date = first_date,\n                            last.date = last_date)[[2]]\n\n# change from daily to monthly\ndf_FTSE_monthly <- df_FTSE_daily %>%\n  mutate(ref_month = format(ref.date, '%Y-%m-01')) %>%\n  group_by(ref_month) %>%\n  summarise_all(last)\n\nprint(df_FTSE_monthly)"},{"path":"limpando-estruturando.html","id":"q.8-5","chapter":"Capítulo 9 Estruturando e Limpando Dados","heading":"Q.8","text":"Para os mesmos dados diários FTSE, verifique datas e preços das 20 maiores quedas de preços. Se, para cada um desses casos, um investidor comprasse o índice preço das maiores quedas e o mantivesse por 30 dias, qual seria seu retorno nominal médio por transação?\n\nSolução\n\n","code":"library(tidyverse)\nlibrary(BatchGetSymbols)\n\nticker <- '^FTSE'\n\nfirst_date <- '2010-01-01'\nlast_date <- '2021-01-01'\n\ndf_FTSE_daily <- BatchGetSymbols(tickers = ticker, \n                            first.date = first_date,\n                            last.date = last_date)[[2]]\n\n# buy at t, sell at t+30\ntrade_window <- 30 \n\n# find largest drops\nlargest_drops <- df_FTSE_daily %>%\n  arrange(ret.adjusted.prices) %>%\n  slice(1:20)\n\n# There are many ways to solve the exercise. \n# Here we will use a loop which is the simplest way to looking at the problem.\n# You could also solve it with the functional approach of package purrrr,\n# that is, writing a function.\n\ntab <- tibble()\nfor (i_date in seq_along(largest_drops$ref.date)) {\n  \n  my_date <- largest_drops$ref.date[i_date]\n  # filter data to keep only datapoints in each horizon\n  temp_df <- df_FTSE_daily %>%\n    filter(ref.date >= my_date,\n           ref.date <= my_date + trade_window)\n  \n  \n  buy_price <- first(temp_df$price.adjusted)\n  sell_price <- last(temp_df$price.adjusted)\n  return <- sell_price/buy_price - 1\n  \n  tab <- bind_rows(tab, \n                   tibble(date = my_date, \n                          buy_price = buy_price, \n                          sell_price = sell_price, \n                          return = return))\n}\n\nprint(tab)\n\n# solution\nmy_sol <- mean(tab$return)"},{"path":"figuras.html","id":"figuras","chapter":"Capítulo 10 Visualizando Dados","heading":"Capítulo 10 Visualizando Dados","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"figuras.html","id":"criando-janelas-de-gráficos-com-x11","chapter":"Capítulo 10 Visualizando Dados","heading":"10.1 Criando Janelas de Gráficos com x11","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"figuras.html","id":"criando-figuras-com-qplot","chapter":"Capítulo 10 Visualizando Dados","heading":"10.2 Criando Figuras com qplot","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"figuras.html","id":"criando-figuras-com-ggplot","chapter":"Capítulo 10 Visualizando Dados","heading":"10.3 Criando Figuras com ggplot","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"figuras.html","id":"a-curva-de-juros-brasileira","chapter":"Capítulo 10 Visualizando Dados","heading":"10.3.1 A Curva de Juros Brasileira","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"figuras.html","id":"usando-temas","chapter":"Capítulo 10 Visualizando Dados","heading":"10.3.2 Usando Temas","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"figuras.html","id":"facets","chapter":"Capítulo 10 Visualizando Dados","heading":"10.3.3 Criando Painéis com facet_wrap","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"figuras.html","id":"uso-do-operador-pipeline","chapter":"Capítulo 10 Visualizando Dados","heading":"10.4 Uso do Operador pipeline","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"figuras.html","id":"criando-figuras-estatísticas","chapter":"Capítulo 10 Visualizando Dados","heading":"10.5 Criando Figuras Estatísticas","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"figuras.html","id":"criando-histogramas","chapter":"Capítulo 10 Visualizando Dados","heading":"10.5.1 Criando Histogramas","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"figuras.html","id":"criando-figuras-boxplot","chapter":"Capítulo 10 Visualizando Dados","heading":"10.5.2 Criando Figuras Boxplot","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"figuras.html","id":"criando-figuras-qq","chapter":"Capítulo 10 Visualizando Dados","heading":"10.5.3 Criando Figuras QQ","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"figuras.html","id":"salvando-figuras-para-arquivos","chapter":"Capítulo 10 Visualizando Dados","heading":"10.6 Salvando Figuras para Arquivos","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"figuras.html","id":"exerc-figuras","chapter":"Capítulo 10 Visualizando Dados","heading":"10.7 Exercícios","text":"","code":""},{"path":"figuras.html","id":"q.1-8","chapter":"Capítulo 10 Visualizando Dados","heading":"Q.1","text":"Baixe dados da ação CIEL3 com o pacote BatchGetSymbols para os últimos 500 dias. Apresente o gŕafico de linha preço ajustado ao longo tempo utilizando função ggplot2::ggplot. Tenha certeza que:Eixos x e y estão corretamente nomeadosO gráfico tem um título (“Preços para CIEL3”), subtítulo (“Dados de YYYY-MM-DD até YYYY-MM-DD”) e um caption (“Solução para exercício 01, cap 10 - adfeR”).\n\nSolução\n\n","code":"library(BatchGetSymbols)\nlibrary(tidyverse)\n\ntickers <- 'FB'\n\ndf_FB <- BatchGetSymbols(tickers = tickers, \n                         first.date = Sys.Date() - 500,\n                         last.date = Sys.Date())[[2]]\n\np <- ggplot(df_FB, aes(x = ref.date, y = price.adjusted)) + \n  geom_line() + \n  labs(title = paste0('Preços para ', tickers) ,\n       subtitle = paste0('Dados de ', min(df_FB$ref.date), ' até ', \n                         max(df_FB$ref.date)),\n       caption = \"Solução para exercício 01, cap 10 - adfeR\")\n\nprint(p)"},{"path":"figuras.html","id":"q.2-8","chapter":"Capítulo 10 Visualizando Dados","heading":"Q.2","text":"Baixe dados das ações PETR3 (PETR3.SA), VALE3 (VALE3.SA), GGBR4 (GGBR4.SA) com BatchGetSymbols para os últimos 1500 dias. Apresente, mesmo gráfico, os preços das ações com diferentes cores de linhas. Mantenha todos demais aspectos gráfico anterior.\n\nSolução\n\n","code":"library(BatchGetSymbols)\n\ntickers <- c('PETR4.SA', \n             'VALE3.SA',\n             'GGBR4.SA') \n\ndf_stocks <- BatchGetSymbols(tickers = tickers, \n                             first.date = Sys.Date() - 500,\n                             last.date = Sys.Date())[[2]]\n\np <- ggplot(df_stocks, aes(x = ref.date, \n                           y = price.adjusted,\n                           color = ticker)) + \n  geom_line() + \n  labs(title = paste0('Preços para ', paste0(tickers, collapse = ', ')) ,\n       subtitle = paste0('Dados de ', min(df_FB$ref.date), ' até ', \n                         max(df_FB$ref.date)),\n       caption = \"Solução para exercício 01, cap 10 - adfeR\")\n\nprint(p)"},{"path":"figuras.html","id":"q.3-7","chapter":"Capítulo 10 Visualizando Dados","heading":"Q.3","text":"Para o gráfico anterior, adicione pontos nas linhas.\n\nSolução\n\n","code":"library(BatchGetSymbols)\n\ntickers <- c('PETR4.SA', \n             'VALE3.SA',\n             'GGBR4.SA') \n\ndf_stocks <- BatchGetSymbols(tickers = tickers, \n                             first.date = Sys.Date() - 500,\n                             last.date = Sys.Date())[[2]]\n\np <- ggplot(df_stocks, aes(x = ref.date, \n                           y = price.adjusted,\n                           color = ticker)) + \n  geom_line() + \n  labs(title = paste0('Preços para ', paste0(tickers, collapse = ', ')) ,\n       subtitle = paste0('Dados de ', min(df_FB$ref.date), ' até ', \n                         max(df_FB$ref.date)),\n       caption = \"Solução para exercício 01, cap 10 - adfeR\")\n\n# add points\np <- p + geom_point()\n\nprint(p)"},{"path":"figuras.html","id":"q.4-7","chapter":"Capítulo 10 Visualizando Dados","heading":"Q.4","text":"Para o mesmo gráfico, separe os preços das ações em painéis diferentes com função ggplot::facet_wrap. Use argumento scales = 'free' para “soltar” os eixos de cada figura.\n\nSolução\n\n","code":"library(BatchGetSymbols)\n\ntickers <- c('PETR4.SA', \n             'VALE3.SA',\n             'GGBR4.SA') \n\ndf_stocks <- BatchGetSymbols(tickers = tickers, \n                             first.date = Sys.Date() - 500,\n                             last.date = Sys.Date())[[2]]\n\np <- ggplot(df_stocks, aes(x = ref.date, \n                           y = price.adjusted,\n                           color = ticker)) + \n  geom_line() + \n  labs(title = paste0('Preços para ', paste0(tickers, collapse = ', ')) ,\n       subtitle = paste0('Dados de ', min(df_FB$ref.date), ' até ', \n                         max(df_FB$ref.date)),\n       caption = \"Solução para exercício 01, cap 10 - adfeR\")\n\n# add points and fact wrap\np <- p + \n  geom_point() + \n  facet_wrap(~ticker, scales = 'free')\n\nprint(p)"},{"path":"figuras.html","id":"q.5-7","chapter":"Capítulo 10 Visualizando Dados","heading":"Q.5","text":"Modifique o tema gráfico anterior para uma escala em preto e branco, tanto para área gráfico quanto para cores das linhas.\n\nSolução\n\n","code":"library(BatchGetSymbols)\n\ntickers <- c('PETR4.SA', \n             'VALE3.SA',\n             'GGBR4.SA') \n\ndf_stocks <- BatchGetSymbols(tickers = tickers, \n                             first.date = Sys.Date() - 500,\n                             last.date = Sys.Date())[[2]]\n\np <- ggplot(df_stocks, aes(x = ref.date, \n                           y = price.adjusted,\n                           color = ticker)) + \n  geom_line() + \n  labs(title = paste0('Preços para ', paste0(tickers, collapse = ', ')) ,\n       subtitle = paste0('Dados de ', min(df_FB$ref.date), ' até ', \n                         max(df_FB$ref.date)),\n       caption = \"Solução para exercício 01, cap 10 - adfeR\")\n\n# add points and facet_wrap\np <- p + geom_point() + \n  facet_wrap(~ticker, scales = 'free') + \n  theme_bw() + \n  scale_color_grey()\n\n# \nprint(p)"},{"path":"figuras.html","id":"q.6-7","chapter":"Capítulo 10 Visualizando Dados","heading":"Q.6","text":"Para os dados anteriores, apresente o histograma dos retornos das diferentes ações em painéis diferentes e salve o resultado em um arquivo chamado 'histograms.png'.\n\nSolução\n\n","code":"library(BatchGetSymbols)\n\ntickers <- c('PETR4.SA', \n             'VALE3.SA',\n             'GGBR4.SA') \n\ndf_stocks <- BatchGetSymbols(tickers = tickers, \n                             first.date = Sys.Date() - 500,\n                             last.date = Sys.Date())[[2]]\n\np <- ggplot(df_stocks, aes(x = ret.adjusted.prices)) + \n  geom_histogram() + \n  facet_wrap(~ticker)\n\nprint(p)\n\n# save in temp folder\nmy_file <- file.path(tempdir(), 'histograms.png')\nggsave(filename = my_file, plot = p)"},{"path":"figuras.html","id":"q.7-7","chapter":"Capítulo 10 Visualizando Dados","heading":"Q.7","text":"Use função BatchGetSymbols::GetIbovStocks para descobrir todos os tickers pertencentes ao índice Ibovespa atualmente. Usando BatchGetSymbols, baixe os dados de retorno anual para todas ações índice de 2015 até o dia atual. Depois disso, crie o mapa de média/variância plotando o retorno anual médio em relação ao seu desvio padrão. Dica: Use opção paralela em BatchGetSymbols para acelerar execução. Você encontrará muitos retornos discrepantes nos dados brutos. Certifique-se de que o gráfico esteja visível limitando os eixos x e y (consulte funções ggplot2::xlim eggplot2::ylim).\n\nSolução\n\n","code":"library(BatchGetSymbols)\nlibrary(tidyverse)\n\ndf_ibov <- GetIbovStocks()\n\nmy_tickers <- paste0(df_ibov$tickers, '.SA')\n\nfuture::plan(future::multisession, \n             workers = floor(parallel::detectCores()/2))\n\ndf_prices <- BatchGetSymbols(tickers = my_tickers, \n                             first.date = '2015-01-01', \n                             last.date = Sys.Date(),\n                             freq.data = 'yearly', \n                             do.parallel = TRUE)[[2]]\n\ntab <- df_prices %>%\n  na.omit() %>%\n  group_by(ticker) %>%\n  summarise(mean = mean(ret.adjusted.prices),\n            sd = sd(ret.adjusted.prices))\n\np <- ggplot(tab, aes(x = sd, y = mean)) + \n  geom_point() + \n  xlim(0, 0.5) + ylim(-0.5, 0.5)\n\nprint(p)"},{"path":"modelos.html","id":"modelos","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"Capítulo 11 Econometria Financeira com o R","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"modelos-lineares-ols","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.1 Modelos Lineares (OLS)","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"simulando-um-modelo-linear","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.1.1 Simulando um Modelo Linear","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"estimating-ols","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.1.2 Estimando um Modelo Linear","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"testing-ols","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.1.3 Inferência Estatística em Modelos Lineares","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"modelos-lineares-generalizados-glm","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.2 Modelos Lineares Generalizados (GLM)","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"simulando-um-modelo-glm","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.2.1 Simulando um Modelo GLM","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"estimando-um-modelo-glm","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.2.2 Estimando um Modelo GLM","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"modelos-para-dados-em-painel","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.3 Modelos para Dados em Painel","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"simulando-dados-em-painel","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.3.1 Simulando Dados em Painel","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"estimando-modelos-de-dados-em-painel","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.3.2 Estimando Modelos de Dados em Painel","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"modelos-arima","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.4 Modelos ARIMA","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"simulando-modelos-arima","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.4.1 Simulando Modelos ARIMA","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"arima-estimating","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.4.2 Estimando Modelos ARIMA","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"prevendo-modelos-arima","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.4.3 Prevendo Modelos ARIMA","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"modelos-garch","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.5 Modelos GARCH","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"simulando-modelos-garch","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.5.1 Simulando Modelos GARCH","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"estimating-garch","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.5.2 Estimando Modelos GARCH","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"prevendo-modelos-garch","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.5.3 Prevendo Modelos GARCH","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"mudanca-regime","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.6 Modelos de Mudança de Regime","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"simulando-modelos-de-mudança-de-regime","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.6.1 Simulando Modelos de Mudança de Regime","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"estimando-modelos-de-mudança-de-regime","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.6.2 Estimando Modelos de Mudança de Regime","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"prevendo-modelos-de-mudança-de-regime","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.6.3 Prevendo Modelos de Mudança de Regime","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"trabalhando-com-diversos-modelos","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.7 Trabalhando com Diversos Modelos","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"modelos.html","id":"exerc-modelos","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"11.8 Exercícios","text":"","code":""},{"path":"modelos.html","id":"q.1-9","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"Q.1","text":"Simule o seguinte processo linear R:partir de x e y, estime um modelo linear onde x é variável explicativa e y é variável explicada. Use função summary objeto de retorno da estimação para obter mais detalhes sobre o modelo. Qual é o valor beta estimado dos dados simulados?\n\nSolução\n\n","code":"set.seed(5)\n\n# number of obs\nn_row <- 100\n\n# set x as Normal (0, 1)\nx <- rnorm(n_row)\n\n# set coefficients\nmy_alpha <- 1.5\nmy_beta <- 0.5\n\n# build y\ny <- my_alpha + my_beta*x + rnorm(n_row)set.seed(5)\n\n# number of obs\nn_row <- 100\n\n# set x as Normal (0, 1)\nx <- rnorm(n_row)\n\n# set coefficients\nmy_alpha <- 1.5\nmy_beta <- 0.5\n\n# build y\ny <- my_alpha + my_beta*x + rnorm(n_row)\n\nlibrary(tidyverse)\n\nmy_lm <- lm(formula = y ~ x, data = tibble(x, y))\n\nsummary(my_lm)\n\nmy_sol <- coef(my_lm)[2]"},{"path":"modelos.html","id":"q.2-9","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"Q.2","text":"Utilizando pacote car, teste hipótese conjunta de que o valor de alpha é igual 1.5 e beta igual 0.5. Qual o valor teste F resultante?\n\nSolução\n\n","code":"set.seed(5)\n\n# number of obs\nn_row <- 100\n\n# set x as Normal (0, 1)\nx <- rnorm(n_row)\n\n# set coefficients\nmy_alpha <- 1.5\nmy_beta <- 0.5\n\n# build y\ny <- my_alpha + my_beta*x + rnorm(n_row)\n\nlibrary(tidyverse)\n\nmy_lm <- lm(formula = y ~ x, data = tibble(x, y))\n\nsummary(my_lm)\n\nlibrary(car)\n\n# set test matrix\ntest_matrix <- matrix(c(my_alpha,  # alpha test value\n                        my_beta))  # beta test value\n\n# hypothesis matrix \nhyp_mat <- matrix(c(1.5, 0,\n                    0  , 0.5),\n                  nrow = 2)\n\n# do test\nmy_waldtest <- linearHypothesis(my_lm, \n                                hypothesis.matrix = hyp_mat, \n                                rhs = test_matrix)\n\n# print result\nmy_sol <- my_waldtest$F[2]"},{"path":"modelos.html","id":"q.3-8","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"Q.3","text":"Utilize pacote gvlma para testar premissas OLS para o modelo estimado anteriormente. O modelo passa em todos os testes? Em caso negativo, aumente o valor de n_row para 1000 e tente novamente. O aumento número de observações modelo impactou teste das premissas? De que forma?\n\nSolução\n\nO modelo estimado não passou todos os testes. De fato, nem o aumento número de observações na simulação resultou em aprovação modelo em todos os quesitos.","code":"set.seed(5)\n\n# number of obs\nn_row <- 1000\n\n# set x as Normal (0, 1)\nx <- rnorm(n_row)\n\n# set coefficients\nmy_alpha <- 1.5\nmy_beta <- 0.5\n\n# build y\ny <- my_alpha + my_beta*x + rnorm(n_row)\n\nlibrary(tidyverse)\n\nmy_lm <- lm(formula = y ~ x, data = tibble(x, y))\n\nsummary(my_lm)\n\nlibrary(gvlma)\n\n# global validation of model\ngvmodel <- gvlma(my_lm) \n\n# print result\nsummary(gvmodel)"},{"path":"modelos.html","id":"q.4-8","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"Q.4","text":"Utilize função BatchGetSymbols::GetSP500Stocks para baixar dados de todas ações pertencentes ao atual índice SP500 para os últimos três anos. Usando o SP500 como o índice de mercado, calcule o beta para cada uma das ações. Apresente o histograma dos betas estimados. Note que os retornos SP500 ('^GSPC') não estão disponíveis na base de dados original e devem ser baixados e agregados base de dados original.\n\nSolução\n\n","code":"library(BatchGetSymbols)\nlibrary(tidyverse)\n\ntickers <- GetSP500Stocks()$Tickers\nfirst_date <- Sys.Date() - 3*365\nlast_date  <- Sys.Date()\n\ndf_stocks <- BatchGetSymbols(tickers = tickers, \n                             first.date = first_date, \n                             last.date = last_date)[[2]]\n\ndf_sp500 <- BatchGetSymbols(tickers =  '^GSPC', \n                            first.date = first_date, \n                            last.date = last_date)[[2]]\n\nidx <- match(df_stocks$ref.date, df_sp500$ref.date)\ndf_stocks$ret_mkt <- df_sp500$ret.closing.prices[idx]\n\n# calculate beta for each stock\nestimate_beta <- function(df) {\n  # Function to estimate beta from dataframe of stocks returns\n  #\n  # Args:\n  #   df - Dataframe with columns ret and ret.sp500\n  #\n  # Returns:\n  #   The value of beta\n  \n  my_model <- lm(data = df, \n                 formula = ret.adjusted.prices ~ ret_mkt)\n  \n  return(coef(my_model)[2])\n}\n\nmy_betas <- by(data = df_stocks, \n               INDICES = df_stocks$ticker, \n               FUN = estimate_beta)\n\nglimpse(my_betas)\n\n# solution\np <- ggplot(tibble(betas = my_betas), aes(x = betas)) + \n  geom_histogram()\n\nprint(p)"},{"path":"modelos.html","id":"q.5-8","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"Q.5","text":"Para os dados importados anteriormente, estime uma versão em dados de painel para o modelo de mercado (beta). Nesta versão, cada ação possui um intercepto diferente, porém compartilham o mesmo beta. O beta estimado é significativo 5%?\n\nSolução\n\n","code":"library(BatchGetSymbols)\nlibrary(tidyverse)\n\ntickers <- GetSP500Stocks()$Tickers\nfirst_date <- Sys.Date() - 3*365\nlast_date  <- Sys.Date()\n\ndf_stocks <- BatchGetSymbols(tickers = tickers, \n                             first.date = first_date, \n                             last.date = last_date)[[2]]\n\ndf_sp500 <- BatchGetSymbols(tickers =  '^GSPC', \n                            first.date = first_date, \n                            last.date = last_date)[[2]]\n\nidx <- match(df_stocks$ref.date, df_sp500$ref.date)\ndf_stocks$ret_mkt <- df_sp500$ret.closing.prices[idx]\n\n# calculate PLM beta\nlibrary(plm)\n\n# estimate panel data model with fixed effects\nmy_pdm <- plm(data = df_stocks, \n              formula = ret.adjusted.prices ~ ret_mkt, \n              model = 'within',\n              index = c('ticker'))\n\n# print result\nprint(summary(my_pdm))"},{"path":"modelos.html","id":"q.6-8","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"Q.6","text":"Utilizando funções tidyverse, dplyr::group_by e dplyr::, estime um modelo ARIMA para os retornos de cada ação dos dados importados exercício SP500. mesmo dataframe de saída, crie uma nova coluna com previsão em t+1 de cada modelo. Qual ação possui maior expectativa de retorno para t+1?\n\nSolução\n\n","code":"library(BatchGetSymbols)\nlibrary(tidyverse)\n\ntickers <- GetSP500Stocks()$Tickers\nfirst_date <- Sys.Date() - 3*365\nlast_date  <- Sys.Date()\n\ndf_stocks <- BatchGetSymbols(tickers = tickers, \n                             first.date = first_date, \n                             last.date = last_date)[[2]]\n\ndf_sp500 <- BatchGetSymbols(tickers =  '^GSPC', \n                            first.date = first_date, \n                            last.date = last_date)[[2]]\n\nlibrary(dplyr)\n\nmy_tab <- df_stocks %>%\n  group_by(ticker) %>%\n  do(my_arima = arima(x = .$ret.adjusted.prices, \n                      order = c(1,0,0))) %>%\n  mutate(arima_forecast = predict(my_arima, n.ahead = 1 )$pred[1])\n\nglimpse(my_tab)\n\n# solution\nidx <- which.max(my_tab$arima_forecast )\nprint(my_tab$ticker[idx])"},{"path":"modelos.html","id":"q.7-8","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"Q.7","text":"mesmo código utilizado na questão anterior, adicione uma nova coluna-lista com estimação de um modelo ARMA(1,0)-GARCH(1,1) para os retornos de cada ação. Adicione outra coluna com previsão de volatilidade (desvio padrão) em t+1. Ao dividir o retorno esperado calculado item anterior pelo risco previsto, temos um índice de direção mercado, onde aquelas ações com maior valor de índice apresentam maior retorno esperado por menor risco. Qual ação é mais atrativa e possui maior valor deste índice?\n\nSolução\n\n","code":"library(BatchGetSymbols)\nlibrary(tidyverse)\n\ntickers <- GetSP500Stocks()$Tickers\nfirst_date <- Sys.Date() - 3*365\nlast_date  <- Sys.Date()\n\ndf_stocks <- BatchGetSymbols(tickers = tickers, \n                             first.date = first_date, \n                             last.date = last_date)[[2]]\n\nlibrary(dplyr)\nlibrary(fGarch)\n\ntab_models <- df_stocks %>%\n  na.omit() %>%\n  group_by(ticker) %>%\n  do(my_garch = garchFit(formula = ~ arma(1,0) + garch(1,1), \n                         data = .$ret.adjusted.prices, \n                         trace = FALSE) ) \n\ntab_models <- tab_models %>%\n  mutate(forecast_mean = predict(my_garch, \n                                 n.ahead = 1)$meanForecast[1],\n         forecast_sd = predict(my_garch, \n                               n.ahead = 1)$standardDeviation[1],\n         sharpe_index = forecast_mean/forecast_sd)\n\nglimpse(tab_models)\n\n# solution\nidx <- which.max(tab_models$sharpe_index)\nprint(tab_models$ticker[idx])"},{"path":"modelos.html","id":"q.8-6","chapter":"Capítulo 11 Econometria Financeira com o R","heading":"Q.8","text":"Para mesma base de dados SP500, selecione 4 ações aleatoriamente e estime um modelo de mudança de regime markoviano equivalente ao apresentado item 11.6 para cada ação. Utilize função plot para apresentar o gráfico das probabilidades suavizadas e salve cada figura em uma pasta chamada 'fig'.\n\nSolução\n\n","code":"library(BatchGetSymbols)\nlibrary(tidyverse)\n\ntickers <- GetSP500Stocks()$Tickers\nfirst_date <- Sys.Date() - 3*365\nlast_date  <- Sys.Date()\n\ndf_stocks <- BatchGetSymbols(tickers = tickers, \n                             first.date = first_date, \n                             last.date = last_date)[[2]]\n\nlibrary(tidyverse)\nlibrary(fMarkovSwitching)\n\nset.seed(10)\n\nrandom_stocks <- sample(unique(df_stocks$ticker), 4)\n\ntemp_df <- df_stocks %>%\n  dplyr::filter(ticker %in% random_stocks)\n\n  tab_switching_model <- temp_df %>%\n  na.omit() %>%\n  group_by(ticker) %>%\n  do(ms_model = MS_Regress_Fit(dep = .$ret.adjusted.prices,\n                               indep = rep(1, nrow(.)),\n                               S = c(1), \n                               k = 2))  # fitting the model)\n\n\n# using temp folder for solution\n\nplot_and_save <- function(model_in, ticker_in) {\n  \n  if (!dir.exists('figs')) dir.create('figs')\n  \n  out_file <- file.path('figs', paste0('plot_', ticker_in, '.jpg'))\n  \n  jpeg(out_file)\n  plot(model_in)\n  dev.off()\n  \n  return(TRUE)\n  \n  \n}\n\nlibrary(purrr)\n\nl_out <- pmap(.l = list(model_in = tab_switching_model$ms_model,\n                        ticker_in = tab_switching_model$ticker), \n              .f =  plot_and_save)"},{"path":"reportando-resultados.html","id":"reportando-resultados","chapter":"Capítulo 12 Reportando Resultados e Criando Relatórios","heading":"Capítulo 12 Reportando Resultados e Criando Relatórios","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"reportando-resultados.html","id":"reportando-tabelas","chapter":"Capítulo 12 Reportando Resultados e Criando Relatórios","heading":"12.1 Reportando Tabelas","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"reportando-resultados.html","id":"reporting-models","chapter":"Capítulo 12 Reportando Resultados e Criando Relatórios","heading":"12.2 Reportando Modelos","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"reportando-resultados.html","id":"criando-relatórios-com-o-rmarkdown","chapter":"Capítulo 12 Reportando Resultados e Criando Relatórios","heading":"12.3 Criando Relatórios com o RMarkdown","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"reportando-resultados.html","id":"exerc-reportando-resultados","chapter":"Capítulo 12 Reportando Resultados e Criando Relatórios","heading":"12.4 Exercícios","text":"","code":""},{"path":"reportando-resultados.html","id":"q.1-10","chapter":"Capítulo 12 Reportando Resultados e Criando Relatórios","heading":"Q.1","text":"Observe os dados disponíveis arquivo grunfeld.csv. Importe os dados R e monte uma tabela descritiva das variáveis. Essa tabela deve oferecer informações suficientes para o leitor entender os dados. Utilize pacote xtable para reportar mesma formato LaTeX ou Word/Writer.\n\nSolução\n\n","code":"library(tidyverse)\n\nmy_url <- 'https://eeecon.uibk.ac.at/~zeileis/grunfeld/Grunfeld.csv'\n\ndf_grunfeld <- read_csv(my_url, col_types = cols())\n\nmy_tab <- tibble(nrows = nrow(df_grunfeld),\n                 ncol = ncol(df_grunfeld),\n                 n_companies = length(unique(df_grunfeld$firm)),\n                 n_years = length(unique(df_grunfeld$year)))\n\nmy_tab\n\nlibrary(xtable)\n\n# Save to lates\n# save to temp file\nmy_tex_file <- tempfile(pattern = 'table', fileext = '.tex')\nprint(xtable(my_tab), file = my_tex_file)\n\nreadr::read_lines(my_tex_file)"},{"path":"reportando-resultados.html","id":"q.2-10","chapter":"Capítulo 12 Reportando Resultados e Criando Relatórios","heading":"Q.2","text":"Utilizando função BatchGetSymbols::GetSP500Stocks, selecione 4 ações aleatoriamente e baixe os dados de preços ajustados para os últimos três anos. Estime um modelo ARIMA(1, 0, 1) para cada ação e reporte o resultado na tela R com função texreg::screenreg.\n\nSolução\n\n","code":"library(BatchGetSymbols)\nlibrary(tidyverse)\n\ntickers <- sample(GetSP500Stocks()$Tickers, 4)\nfirst_date <- Sys.Date() - 3*365\nlast_date  <- Sys.Date()\n\ndf_stocks <- BatchGetSymbols(tickers = tickers, \n                             first.date = first_date, \n                             last.date = last_date)[[2]]\n\n\nmy_tab <- df_stocks %>%\n  na.omit() %>%\n  group_by(ticker) %>%\n  do(my_arima = arima(x = .$ret.adjusted.prices, \n                      order = c(1, 0, 1))) \n\nglimpse(my_tab)\n\n# solution\nlibrary(texreg)\n\nscreenreg(my_tab$my_arima)"},{"path":"reportando-resultados.html","id":"q.3-9","chapter":"Capítulo 12 Reportando Resultados e Criando Relatórios","heading":"Q.3","text":"Crie um novo relatório em Rmarkdown contemplando os dois exercícios anteriores. Compile o relatório em html e abra o mesmo seu browser.\n\nSolução\n\n","code":""},{"path":"otimizacao.html","id":"otimizacao","chapter":"Capítulo 13 Otimização de Código","heading":"Capítulo 13 Otimização de Código","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"otimizacao.html","id":"otimizando-código-em-r","chapter":"Capítulo 13 Otimização de Código","heading":"13.1 Otimizando Código em R","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"otimizacao.html","id":"otimizando-a-velocidade-de-execução","chapter":"Capítulo 13 Otimização de Código","heading":"13.2 Otimizando a Velocidade de Execução","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"otimizacao.html","id":"perfil-do-código-r-profiling","chapter":"Capítulo 13 Otimização de Código","heading":"13.2.1 Perfil do Código R (profiling)","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"otimizacao.html","id":"estratégias-para-melhorar-a-velocidade-de-execução","chapter":"Capítulo 13 Otimização de Código","heading":"13.2.2 Estratégias para Melhorar a Velocidade de Execução","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"otimizacao.html","id":"use-operações-vetoriais","chapter":"Capítulo 13 Otimização de Código","heading":"13.2.2.1 Use Operações Vetoriais","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"otimizacao.html","id":"junção-repetitiva-de-dataframes","chapter":"Capítulo 13 Otimização de Código","heading":"13.2.2.2 Junção Repetitiva de dataframes","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"otimizacao.html","id":"usando-código-c-pacote-rcpp","chapter":"Capítulo 13 Otimização de Código","heading":"13.2.3 Usando Código C ++ (pacote Rcpp)","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"otimizacao.html","id":"usando-cacheamento-local-pacote-memoise","chapter":"Capítulo 13 Otimização de Código","heading":"13.2.4 Usando Cacheamento Local (pacote memoise)","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"otimizacao.html","id":"usando-processamento-paralelo-pacote-furrr","chapter":"Capítulo 13 Otimização de Código","heading":"13.2.4.1 Usando Processamento Paralelo (pacote furrr)","text":"\nVocê chegou ao fim da versão online livro Análise de Dados\nFinanceiros e Econômicos com o R, terceira edição. O conteúdo\nintegral da obra pode ser adquirido na loja da Amazon como ebook ou livro impresso. compra\nlivro é uma ótima maneira de suportar este e outros projetos \nautor.\n","code":""},{"path":"otimizacao.html","id":"exercícios-1","chapter":"Capítulo 13 Otimização de Código","heading":"13.3 Exercícios","text":"","code":""},{"path":"otimizacao.html","id":"q.1-11","chapter":"Capítulo 13 Otimização de Código","heading":"Q.1","text":"Considere o seguinte código:Use funcões Rprof e profvis para identificar o gargalo código. Qual número da linha que está tomando maior tempo de execução?\n\nSolução\n\n","code":"library(tidyverse)\nlibrary(forecast)\nlibrary(BatchGetSymbols)\n\nticker <- '^GSPC'\ndf_prices <- BatchGetSymbols(tickers = ticker, \n                             first.date = '2010-01-01')[[2]]\n\nmy_arima <- auto.arima(df_prices$ret.adjusted.prices)\nsummary(my_arima)library(tidyverse)\nlibrary(BatchGetSymbols)\nlibrary(fGarch)\nlibrary(profvis)\n\n# set temporary file for results\nprofiling_file <-  tempfile(pattern = 'profiling_exercise', \n                            fileext = '.out')\n\n# initialize profiling\nRprof(filename = profiling_file)\n\n# run code\nprofiling <- profvis(expr = {\n  ticker <- '^GSPC'\n  df_prices <- BatchGetSymbols(tickers = ticker, \n                               first.date = '2000-01-01', do.cache = FALSE)[[2]]\n  \n  my_garch <- garchFit(formula = ret.adjusted.prices ~ arma(1,1) + garch(1,1), \n                       data =  na.omit(df_prices) )\n})\n\n# create visualization\ntemp_html <- tempfile(pattern = 'profile',\n                      fileext = '.html')\n\nhtmlwidgets::saveWidget(profiling, temp_html)\n\n# open in browser from R\nbrowseURL(temp_html)"},{"path":"otimizacao.html","id":"q.2-11","chapter":"Capítulo 13 Otimização de Código","heading":"Q.2","text":"Use o pacote Rcpp para escrever e usar uma função em linguagem C++ que irá adicionar elementos dos vetores x e y, elemento por elemento. saída deve ser outro vetor de mesmo tamanho e com elementos iguais operação x + y. Use função identical para testar se todos os elementos de ambos os vetores são iguais.\n\nSolução\n\n","code":"library(Rcpp)\n\ncppFunction('Rcpp::NumericVector sum_vectors_C(NumericVector x, NumericVector y) {\n  int n = x.size();\n  \n  Rcpp::NumericVector total(x.size());\n  \n  for(int i = 0; i < n; ++i) {\n    total[i] = x[i] + y[i];\n  }\n  return total;\n}')\n\nx <- runif(100)\ny <- runif(100)\n\nsol_C <- sum_vectors_C(x, y)\nsol_R <- x + y\n\nidentical(sol_C, sol_R)"},{"path":"otimizacao.html","id":"q.3-10","chapter":"Capítulo 13 Otimização de Código","heading":"Q.3","text":"Use o pacote tictoc para comparar o desempenho da função anterior com o operador nativo +, e uma versão baseada em loops com pré-alocação. Qual alternativa apresenta menor tempo de execução e por quê? versão Rcpp vence versão em loop?\n\nSolução\n\nmelhor alternativa é o operador nativo +. Este já é otimizado e executa o cálculo rapidamente.","code":"library(Rcpp)\n\ncppFunction('Rcpp::NumericVector sum_vectors_C(NumericVector x, NumericVector y) {\n  int n = x.size();\n  \n  Rcpp::NumericVector total(x.size());\n  \n  for(int i = 0; i < n; ++i) {\n    total[i] = x[i] + y[i];\n  }\n  return total;\n}')\n\nx <- runif(100)\ny <- runif(100)\n\nsol_C <- sum_vectors_C(x, y)\nsol_R <- x + y\n\nidentical(sol_C, sol_R)\n\nlibrary(tictoc)\n\ntic('Using Rcpp')\nsol_C <- sum_vectors_C(x, y)\ntoc()\n\ntic('Using base R')\nsol_R <- x + y\ntoc()\n\ntic('Using a loop and prealocation')\nsol_loop <- numeric(length = length(x))\nfor (i in 1:length(x)) {\n  sol_loop[i] <- x[i] + y[i]\n}\ntoc()"},{"path":"otimizacao.html","id":"q.4-9","chapter":"Capítulo 13 Otimização de Código","heading":"Q.4","text":"Use o pacote memoise para criar uma versão memorizada de Quandl::Quandl. Use nova função para importar dados para o Índice de Preços ao Consumidor dos Estados Unidos (código 'FRED/DDOE01USA086NWDB'). Quanto de ganho de velocidade em porcentagem você obtém da segunda chamada para versão memorizada?\n\nSolução\n\n","code":"library(Quandl)\nlibrary(memoise)\nlibrary(tictoc)\n\nmem_quandl <- memoise(f = Quandl, cache = cache_memory())\n\nid <- 'FRED/DDOE01USA086NWDB'\n\ntic('Using original Quandl')\ndf <- Quandl(code = id)\ntoc()\n\ntic('Using memoise version (first call)')\ndf <- mem_quandl(code = id)\ntoc()\n\ntic('Using memoise version (second call)')\ndf <- mem_quandl(code = id)\ntoc()"},{"path":"referências.html","id":"referências","chapter":"Referências","heading":"Referências","text":"","code":""}]
