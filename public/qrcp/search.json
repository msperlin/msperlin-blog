[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Questões de R em Concursos Públicos",
    "section": "",
    "text": "Prefácio\nO R é uma plataforma aberta, estável e acessível para a análise de dados e produção de relatórios estruturados. Hoje em dia, o R é sinônimo de programação voltada a dados, sendo usado em notáveis empresas de tecnologia, incluindo Microsoft, Google e Meta (Facebook). Assim sendo, é inevitável que o conhecimento em R seja cobrado nas seleções de cargos públicos. Seja no trabalho de estatístico do IBGE ou analista da receita federal, o conhecimento de R se torna uma ferramenta indispensável.\nEste livro busca melhor preparar candidatos para as mais variadas provas de concursos, apresentando um conteúdo curado de soluções e comentários de questões passadas sobre o uso do R. Cada exercício possui explicações completas e demonstrações de código que permitem ao leitor entender a solução, ao mesmo tempo em que aprende novos conceitos. Ao terminar de ler esse livro, espero que o leitor aumente o seu conhecimento, e as suas chances de ser aprovado no concurso desejado.\nEste livro, assim como os demais livro que escrevi, é um projeto especial, buscando levar conhecimento do R para o maior número de pessoas possível. Pretendo atualizar este livro a cada dois anos, contemplando, assim, novas questões que apareçam.\nEste livro não seria possível sem a devida autonomia do meu cargo de professor. Assim, deixo aqui o meu agradecimento a UFRGS (Universidade Federal do Rio Grande do Sul), por possibilitar e incentivar este empreendimento no mercado literário. Agradeço também todos os meu colegas professores que apoiaram a criação deste conteúdo.\nAdicionalmente, não posso também deixar de agradecer a toda a comunidade do R. Em especial, agradeço os autores do pacote {quarto} (Allaire 2022), sem o qual não seria possível compilar este livro de uma forma tão fácil. Adicionalmente, abaixo destaco os respectivos pacotes disponíveis no CRAN utilizados e suas devidas referências. A lista foi gerada automaticamente e está em ordem alfabética.\n{base} (R Core Team 2023a), {dplyr} (Wickham, François, et al. 2023), {forcats} (Wickham 2023a), {fs} (Hester, Wickham, and Csárdi 2023), {ggplot2} (Wickham, Chang, et al. 2023), {glue} (Hester and Bryan 2022), {gt} (Iannone et al. 2023), {knitr} (Xie 2023), {purrr} (Wickham and Henry 2023), {quarto} (Allaire 2022), {readr} (Wickham, Hester, and Bryan 2023), {renv} (Ushey 2023), {reticulate} (Ushey, Allaire, and Tang 2023), {rmarkdown} (Allaire et al. 2023), {stats} (R Core Team 2023b), {tibble} (Müller and Wickham 2023), {tidyr} (Wickham, Vaughan, and Girlich 2023), {tidyverse} (Wickham 2023b)"
  },
  {
    "objectID": "index.html#como-ler-esse-livro",
    "href": "index.html#como-ler-esse-livro",
    "title": "Questões de R em Concursos Públicos",
    "section": "Como ler esse livro?",
    "text": "Como ler esse livro?\nTodos exercícios possuem uma estrutura comum, com seções separadas entre enunciado, alternativas e gabarito. Tentei, ao máximo, copiar o conteúdo igual ao da prova, emulando, assim, o exercício nas condições reais. As explicações também assumem a inexistência de uma sessão R para testar código. Esta restrição foi desafiadora, pois o entendimento do código tem que ser completo, sem margem para erros. Busquei sempre apresentar o conhecimento mínimo necessário para solucionar a questão. Para não repetir conceitos, usei quadros como o apresentado abaixo, para conectar as questões.\n\n\n\n\n\n\nConceitos Prévios\n\n\n\n\nFunções customizadas no R\n\nVeja conceito na Section 1.7\n\nFunções recursivas\n\nVeja conceito na Section 1.11\n\n\n\n\nTambém utilizei caixas de texto para indicar soluções equivocadas de gabaritos oficiais e outros pontos que merecem atenção.\n\n\n\n\n\n\nCuidado\n\n\n\nEsta questão apresenta um enunciado complicado, e …\n\n\nToda vez que encontrar tais caixas de diálogo, leia com atenção o seu conteúdo, pois a mensagem é certamente importante e pode se mostrar como o diferencial para uma aprovação em concurso.\nO código comentado apresentado nas soluções possui uma estrutura semelhante a apresentada abaixo:\n\n# esse é um comentário\n1my_seq &lt;- 1:10\n\n# apresenta um texto na tela\n2print(my_seq)\n\n\n1\n\nO código my_seq &lt;- 1:10 cria uma sequência entre 1 e 10.\n\n2\n\nO código print(my_seq) mostra o objeto my_seq no prompt do R.\n\n\n\n\nR&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\n\nNote que:\n\ntodas linhas do código são enumeradas no lado esquerdo do código, neste caso com cinco linhas de código.\ncomentários em código (ou anotações do usuário) são definidos com o símbolo #, e não são executados.\nIndicações de anotações aparecem no lado direito do quadro de código, sendo posteriormente explicadas em texto corrido (veja texto logo abaixo do código).\n\nSaiba que toda saída de código é realmente executada pelo interpretador do R na versão 4.3.0 (codenome “Already Tomorrow”). Adicionalmente, no texto encontrarás uma formatação específica para nomes de funções e pacotes. Por exemplo, pacote dplyr é mencionado como {dplyr}, enquanto a função filter do {dplyr} é indicada como filter() . O uso de duplos dois pontos não é acidental, é código R válido e, no texto, permite a diferenciação das funções entre os variados módulos do R.\nAo longo do livro verás o uso de diversas abreviações de órgãos de concurso. Abaixo apresento o quadro de abreviações.\n\n\n\n\n\n\n  \n    \n      Abreviações utilizadas para órgãos de concursos\n    \n    \n    \n      Órgão do concurso\n      Abreviatura\n    \n  \n  \n    Ag. Est. de Regulação dos Serv. Púb. Delegados do RS\nAGERGS\n    Agência Nacional do Petróleo, Gás Natural e Biocombustíveis\nANP\n    Banco do Brasil\nBB\n    Banco do Estado de Sergipe SA\nBANESE\n    Departamento de Polícia Federal\nDPF\n    Fundação Universidade de Brasília\nFUB\n    Instituto Brasileiro de Geografia e Estatística\nIBGE\n    Ministério Público de Santa Catarina\nMPSC\n    Ministério da Justiça e Segurança Pública\nMJSP\n    Receita Federal do Brasil\nRFB\n    Tribunal de Contas da União\nTCU"
  },
  {
    "objectID": "index.html#sobre-o-autor",
    "href": "index.html#sobre-o-autor",
    "title": "Questões de R em Concursos Públicos",
    "section": "Sobre o autor",
    "text": "Sobre o autor\nSou professor universitário, com mais de 15 anos de experiência em programação voltada a análise de dados financeiros e econômicos. Em 2015 conheci o R e me apaixonei. Desde então, ensino o R na pós-graduação (mestrado e doutorado), e uso a ferramenta diariamente, seja para escrever artigos científicos, livros ou automatizar as mais variadas tarefas cotidianos do mundo acadêmico.\nEm 2018 escrevi a primeira edição do livro “Análise de Dados Econômicos e Financeiros com o R” (veja abaixo seção “Livros do Autor”), o qual teve um grance sucesso na área. Também tenho me envolvido em projetos open source, com o desenvolvimento e manutenção de diversos módulos do R no CRAN, e avaliação de pacotes para o ropensci. Mais detalhes sobre meu trabalho acadêmico, incluindo publicações e código, está disponível no meu site https://msperlin.com/."
  },
  {
    "objectID": "index.html#livros-do-autor",
    "href": "index.html#livros-do-autor",
    "title": "Questões de R em Concursos Públicos",
    "section": "Livros do Autor",
    "text": "Livros do Autor\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnálise de Dados Financeiros e Econômicos com o R: Uma introdução ao uso do R e RStudio para a área específica de finanças. O livro texto contém 13 capítulos que explicam todo o processo de pesquisa com o R, desde aquisição dos dados até o reporte de resultados em planilhas e figuras. Versão online disponível em https://www.msperlin.com/adfeR/.\nAnalyzing Financial and Economic Data with R: Versão internacional do livro “Análise de Dados Financeiros com o R”. Versão web disponível em https://www.msperlin.com/afedR/.\nVisualização de dados com o R: Este livro é uma extensão da minha outra obra, Análise de Dados Financeiros e Econômicos com o R. Aqui escrevo sobre tudo aquilo que aprendi sobre visualização de dados em mais de doze anos de carreira como professor, pesquisador e consultor da área de finanças e economia. O conteúdo do livro percorre sobre os seguintes pontos: princípios e prática de visualização de dados com o {ggplot2} , construção de gráficos estatísticos e mapas, e automatização e programação com o {ggplot2} . Versão web disponível em https://www.msperlin.com/vdr/\nPoupando e Investindo em Renda Fixa: Este livro trabalho o tópico de educação financeira, apresentando uma forma de investir com foco no longo prazo, resiliência e na qualidade de vida do investidor. O grande diferencial da obra é o uso frequente de dados financeiros reais para entender melhor como o mercado de renda fixa funciona, os efeitos dos tributos e custos operacionais, e quais são as melhores opções para o investidor pessoa física. Cada capítulo do livro apresenta e analisa os principais produtos disponíveis na renda fixa: produtos bancários (CDBs, LCA, entre outros), Tesouro Direto (Prefixado, IPCA+, SELIC), fundos de renda fixa e debêntures."
  },
  {
    "objectID": "02-sobre-as-questoes.html",
    "href": "02-sobre-as-questoes.html",
    "title": "Sobre as questões",
    "section": "",
    "text": "Esta edição do livro contém 35 questões de concursos, de 13 diferentes cargos e 11 diferentes órgãos públicos. Todas questões foram obtidas em repositórios públicos de arquivos de concursos passados. A Figure 1 mostra a distribuições de questões por ano e também por órgão do concurso.\n\n\n\n\n\n\n\n(a) Número de questões e ano\n\n\n\n\n\n\n\n(b) Número de questões e órgão\n\n\n\n\nFigure 1: Número de questões por ano e órgao\n\n\nComo podemos ver, o número de questões aumenta substancialmente em 2022. Prevejo que, assim como o que aconteceu com a linguagem Python, esse padrão se confirme nos próximos anos. Em relação aos órgãos, os principais são FUB (Fundação Universidade de Brasília) com 12 questões sobre R no concurso para o cargo de Estatístico, e MJSP (Ministério da Justiça e Segurança Pública) com 4 questões no cargo de Cientista Social.\nO livro está dividido em quatro seções, com a organização das questões de acordo com os seguintes tópicos:\n\nOperações básicas\n\nconstitui o uso de funções básicas do R, incluindo criação de objetos, operação com vetores e outras.\n\nOperações com tabelas (dataframes)\n\ninclui operações de manipulação de tabelas, incluindo também o uso dos pacotes do {tidyverse} .\n\nRepetição estruturada de código (loops)\n\nrefere-se a programação com o R, incluindo o uso de loops dos tipos while, repeat e for.\n\nGráficos\n\ninclui o uso de funções de criação de gráfico, seja com funções do módulo básico ({base} ou pacote {ggplot2} .\n\nOutros temas\n\ninclui temas diversos, não contemplados nas demais seções."
  },
  {
    "objectID": "03-operacoes-basicas.html#sec-funcao-c-assign-print",
    "href": "03-operacoes-basicas.html#sec-funcao-c-assign-print",
    "title": "1  Operações Básicas",
    "section": "1.1 Questão 01 [DPF 2018]",
    "text": "1.1 Questão 01 [DPF 2018]\n\n\n\nInformações\n\n\n\n\n\nAno\n2018\n\n\nÓrgão\nDepartamento de Polícia Federal\n\n\nCargo\nAgente de Polícia Federal\n\n\nNúmero na prova\n93\n\n\nTipo de questão\nDuas alternativas, uma resposta (C, E)\n\n\nResposta correta\nE\n\n\n\nConsidere o programa a seguir, escrito em R.\n\nx &lt;- c(3, 5, 7)\ny &lt;- c(1, 9, 11)\nprint(x + y)\n\nApós a execução do programa, será obtido o seguinte resultado.\n[1] 36\n\nAlternativas:\nC - Correto\nE - Errado\n\nSolução\n\n\n\n\n\n\nOperadores &lt;- e -&gt;\n\n\n\nTambém chamado de função assign, os operadores &lt;- e -&gt; definem um objeto no lado esquerdo ou direito da chamada em código. Exemplos:\n\n# uso tradicional do operador assign \nx &lt;- 1\n\n# uso inverso do operador assign (não recomendado)\n5 -&gt; y\n\nSaiba que, apesar de não ser recomendado, o símbolo = tem o mesmo uso que &lt;- e -&gt;. Assim, o código anterior é equivalente a:\n\n# uso do operador =\nx = 1\ny = 5\n\n\n\n\n\n\n\n\n\nFunção c()\n\n\n\nUma dos operadores mais usados no R. O termo c significa concatenate (concatenar, agrupar) e serve para combinar valores em um vetor atômico onde todos elementos são da mesma classe. A função c() serve tanto para combinar elementos individuais, quanto para combinar vetores já existentes (veja terceira linha do código).Exemplos:\n\n# definição de vetores com c()\nx &lt;- c(1, 5)\ny &lt;- c(5, 2, 11)\nz &lt;- c(x, y, 9)\n\nUma propriedade de c() é que a função força todos os elementos da saída a serem da mesma classe. Se, por acaso, misturarmos classes, diferentes, o R busca converter os elementos individuais para a classe mais complexa. Veja o exemplo abaixo, onde misturamos um texto com números:\n\n# exemplo de conversão de elementos com c()\nx &lt;- c(1, \"abc\")\nprint(x)\n\nR&gt; [1] \"1\"   \"abc\"\n\n\nAqui, a classe de caractere é mais complexa, forçando a conversão. Veja que a saída é um vetor do tipo caractere. O primeiro elemento, o qual era originalmente um valor numérico, torna-se um texto.\n\n\n\n\n\n\n\n\nOperadores de soma +\n\n\n\nUm dos operadores matemáticos mais utilizados no R, o operador de soma serve para somar elementos de objetos diferentes.\n\n# uso o operador de soma +\nx &lt;- 1:5\ny &lt;- 6:10\n\nprint(x + y)\n\nR&gt; [1]  7  9 11 13 15\n\n\nNa adição de vetores, é importante saber que as operações são sempre efetuadas elemento por elemento. Veja o exemplo acima, onde o primeiro elemento do vetor de saída é a soma dos primeiros elementos de x e y.\nOutra propriedade importante no uso do operador de soma é a regra de reciclagem, a qual define como vetores de tamanhos diferentes são somados. Veja ?sec-regra-reciclagem para mais detalhes.\n\n\n\n\n\n\n\n\nFunção print()\n\n\n\nO comando print() mostra algum resultado no prompt do R. Comumente, utiliza-se o print() para averiguar se o código executado está correto. A função print() é adaptável, e pode ter diferentes comportamentos de acordo com a classe do objeto que está sendo apresentada no prompt. Veja alguns exemplos abaixo:\n\n# exemplos de print()\nprint(1)\n\nR&gt; [1] 1\n\nprint(\"abc\")\n\nR&gt; [1] \"abc\"\n\nprint(1:10)\n\nR&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\nprint(data.frame(x = 1:3, y = 2:4))\n\nR&gt;   x y\nR&gt; 1 1 2\nR&gt; 2 2 3\nR&gt; 3 3 4\n\n\nOutro ponto importante aqui é que o comando print() é automaticamente utilizado quando o nome do objeto é executado no prompt. Assim, o comando print(x) é equivalente a simplesmente x:\n\nx &lt;- 10\n\n# `x` é equivalente a `print(x)`\nx\n\nR&gt; [1] 10\n\n\nPortanto, em uma questão de concurso, ao ver um objeto sozinho em sua própria linhas, saiba que o comando print() é executado automaticamente, mostrando uma representação do objeto no prompt.\n\n\n\nO enunciado da questão está errado. Caso executarmos o código, veremos que a saída não é o valor 36, mas sim um vetor com a soma dos elementos individuais de x e y. Para explicar, considere o código comentado abaixo.\n\n1x &lt;- c(3, 5, 7)\ny &lt;- c(1, 9, 11)\n2print(x + y)\n\n\n1\n\nO comando &lt;- define um objeto no lado esquerdo do código. A função c() combina valores para definir um vetor atômico, onde todos elementos possuem a mesma classe. Neste caso, o objeto com nome x toma o valor de c(3, 5, 7), enquanto y toma o valor de c(1, 9, 11).\n\n2\n\no resultado da soma é apresentado com o comando print() , o qual mostra um resultado no prompt do R. No R, uma soma de vetores é realizada elemento por elemento. Por exemplo, ao somarmos c(1, 2) com c(3, 4), o resultado é c(1+3, 2+4), isto é, 4, 6. Portanto, voltando ao problema, ao somarmos x com y, o resultado é c(4, 14, 18).\n\n\n\n\nExecutando o código, temos o seguinte resultado:\n\nprint(x + y)    \n\nR&gt; [1]  4 14 18\n\n\nComo podemos ver a, a saída do código é [1] 4 14 18, e não 36."
  },
  {
    "objectID": "03-operacoes-basicas.html#questão-02-dpf-2018",
    "href": "03-operacoes-basicas.html#questão-02-dpf-2018",
    "title": "1  Operações Básicas",
    "section": "1.2 Questão 02 [DPF 2018]",
    "text": "1.2 Questão 02 [DPF 2018]\n\n\n\nInformações\n\n\n\n\n\nAno\n2018\n\n\nÓrgão\nDepartamento de Polícia Federal\n\n\nCargo\nAgente de Polícia Federal\n\n\nNúmero na prova\n94\n\n\nTipo de questão\nDuas alternativas, uma resposta (C, E)\n\n\nResposta correta\nE\n\n\n\nConsidere o programa a seguir, escrito em R.\n\nx &lt;- TRUE\ny &lt;- FALSE\nprint (xy)\n\nApós a execução do programa, será obtido o seguinte resultado.\n[1] FALSE\n\nAlternativas:\nC - Correto\nE - Errado\n\nSolução\n\n\n\n\n\n\nConceitos Prévios\n\n\n\n\nUso de &lt;-\n\nveja conceito na Section 1.1\n\nFunção print() \n\nveja conceito na Section 1.1\n\n\n\n\n\n\n\n\n\n\nObjetos do tipo lógico (TRUE | FALSE)\n\n\n\nObjetos do tipo logical servem para indicar eventos verdadeiros (TRUE) ou falsos (FALSE). Veja que, na linguagem R, o nome TRUE e FALSE são reservados e válidos para a definição de objetos e vetores. Geralmente, estes são saídas de testes de condições sobre objetos. Por exemplo, se testarmos no prompt do R que 1 &gt; 2, o resultado é FALSE. O mesmo teste pode ser realizado para vetores, elemento por elemento. Neste caso, a saída é um vetor lógico (e não valor único). Veja exemplos abaixo:\n\n# exemplo de teste lógico\nprint(1 &gt; 2)\n\nR&gt; [1] FALSE\n\n# exemplo em vetores\nx &lt;- 1:5\nprint(x &lt; 3)\n\nR&gt; [1]  TRUE  TRUE FALSE FALSE FALSE\n\n\n\n\n\nO enunciado da questão está errado. Um olho treinado facilmente percebe que, no comando print (xy), não existe operador entre as variáveis x e y. O código apresentado terminaria a sua execução com um erro. Ao executar o código, o interpretador do R entende que xy é um objeto por si só. Obviamente o mesmo não existe e, portanto, a execução do código resultaria em uma mensagem de erro: “Error: object ‘xy’ not found”. A maneira correta de executar o código seria definir algum operador entre x e y, tal como print(x+y) ou print(x*y), os quais, respectivamente, iriam somar ou multiplicar os elementos de x e y.\n\n\n\n\n\n\nDica do Perlin\n\n\n\nAqui um ponto importante. Note que o comando print (xy) não tem espaço entre o print e (xy). Isto não é usual em programação do R, porém o compilador executa sem problemas. É impossível saber se isso foi “pegadinha” do autor da questão, ou simplesmente um erro de edição. De qualquer maneira, lembre que, neste caso específico de chamar uma função, é válido, mas não comum, adicionar um espaço entre o nome da função e o primeiro parêntese."
  },
  {
    "objectID": "03-operacoes-basicas.html#sec-caracteres",
    "href": "03-operacoes-basicas.html#sec-caracteres",
    "title": "1  Operações Básicas",
    "section": "1.3 Questão 03 [DPF 2018]",
    "text": "1.3 Questão 03 [DPF 2018]\n\n\n\nInformações\n\n\n\n\n\nAno\n2018\n\n\nÓrgão\nDepartamento de Polícia Federal\n\n\nCargo\nNível Superior\n\n\nNúmero na prova\n43\n\n\nTipo de questão\nDuas alternativas, uma resposta (C, E)\n\n\nResposta correta\nC\n\n\n\nCom relação à programação R, julgue os itens que se seguem.\n\nhelloStr &lt;- \"Hello world!\" \nprint(helloStr) \n\nNesse caso, após a execução dos comandos, será obtido o resultado a seguir.\n[1] “Hello world!”\n\nAlternativas:\nC - Correto\nE - Errado\n\nSolução\n\n\n\n\n\n\nConceitos Prévios\n\n\n\n\nUso de &lt;-\n\nveja conceito na Section 1.1\n\nFunção print() \n\nveja conceito na Section 1.1\n\n\n\n\n\n\n\n\n\n\nObjetos do tipo caractere (texto)\n\n\n\nObjetos do tipo character servem para representar textos no R. A criação dos mesmos se dá pelo uso de aspas duplas ou simples:\n\n# exemplo de criação de objetos do tipo texto\nx &lt;- \"abc\"\ny &lt;- 'cba'\nz &lt;- c(\"a\", \"b\", \"c\")\n\nO R oferece uma ampla gama de operações com objetos de texto. É possível procurar por letras e padrões específicos de texto, quebrar texto com base em um símbolo, e várias outras operações. Veja capítulo 7 de Perlin (2021) para mais detalhes sobre as principais operações disponíveis para objetos do tipo texto.\n\n\n\nO enunciado da questão está correto.\n\n1helloStr &lt;- \"Hello world!\"\n2print(helloStr)\n\n\n1\n\na primeira etapa é a definição de variáveis no R: helloStr &lt;- \"Hello world!\". Veja que, para o R, sempre que texto é envolvido por aspas duplas (ou simples), o objeto criado é do tipo character (ou caractere/texto).\n\n2\n\nAo usarmos o comando print() para um objeto do tipo texto, a saída é o texto em si. Portanto, ao rodarmos o código do enunciado, o resultado é exatamente [1] “Hello world!”:\n\n\n\n\nR&gt; [1] \"Hello world!\""
  },
  {
    "objectID": "03-operacoes-basicas.html#sec-funcao-matrix-array",
    "href": "03-operacoes-basicas.html#sec-funcao-matrix-array",
    "title": "1  Operações Básicas",
    "section": "1.4 Questão 04 [MJSP 2020]",
    "text": "1.4 Questão 04 [MJSP 2020]\n\n\n\n\n\n\n\nInformações\n\n\n\n\n\nAno\n2020\n\n\nÓrgão\nMinistério da Justiça e Segurança Pública\n\n\nCargo\nAnalista (Superior)\n\n\nNúmero na prova\n36\n\n\nTipo de questão\nCinco alternativas, uma resposta (a, b, c, d, e)\n\n\nResposta correta\nd\n\n\n\nUm analista do MJSP necessita criar a seguinte matriz em linguagem R:\n\n\n\nmatriz a ser criada\n\n\nSabendo disso, assinale a alternativa que apresenta corretamente o código que o analista deverá escrever em linguagem R.\n\nAlternativas:\na ) array(data=c(45,75,51,0.17),nrow=2,ncol=2).\nb ) array(c=(45,75,51,0.17),row=2,col=2).\nc ) data=c(45,75,51,0.17),nrow=2,ncol=2.\nd ) matrix(data=c(45,75,51,0.17),nrow=2,ncol=2).\ne ) matrix(c=(45,75,51,0.17),row=2,col=2).\n\nSolução\n\n\n\n\n\n\nFunção matrix()\n\n\n\nEsta serve para criar matrizes no R. Uma matriz nada mais é do que um conjunto de valores numéricos organizados em um objeto de duas dimensões, uma tabela, com linhas e colunas. Estas são geralmente utilizadas para simplificar operações matemáticas.\nPara criar uma matriz com matrix() , basta indicar os valores a serem preenchidos, e o tamanho da matriz desejada:\n\n# cria matriz com 4 linhas e 3 colunas\nmatrix(data = 1:12, nrow = 4, ncol=3)\n\nR&gt;      [,1] [,2] [,3]\nR&gt; [1,]    1    5    9\nR&gt; [2,]    2    6   10\nR&gt; [3,]    3    7   11\nR&gt; [4,]    4    8   12\n\n# cria matriz com 3 linhas e 4 colunas\nmatrix(data = 1:12, nrow = 3, ncol=4)\n\nR&gt;      [,1] [,2] [,3] [,4]\nR&gt; [1,]    1    4    7   10\nR&gt; [2,]    2    5    8   11\nR&gt; [3,]    3    6    9   12\n\n\nNote que a ordem de preenchimento da matriz segue a ordem das dimensões: primeiro as linhas, e depois as colunas. Isso é importante pois define os elementos da matriz criada, e pode ser conhecimento necessário para a resolução de questões de concurso.\n\n\n\n\n\n\n\n\nFunção array()\n\n\n\nEste comando é semelhante a matrix() , porém sem a restrição no número de dimensões. A função array() pode criar objetos com qualquer número de dimensões, enquanto matrix() é restrita a duas.\n\n# cria objeto com 2 dimensões\narray(data = 1:12, dim = c(4, 3, 1))\n\nR&gt; , , 1\nR&gt; \nR&gt;      [,1] [,2] [,3]\nR&gt; [1,]    1    5    9\nR&gt; [2,]    2    6   10\nR&gt; [3,]    3    7   11\nR&gt; [4,]    4    8   12\n\n# cria objeto com 3 dimensões\narray(data = 1:16, dim = c(2, 2, 2, 2))\n\nR&gt; , , 1, 1\nR&gt; \nR&gt;      [,1] [,2]\nR&gt; [1,]    1    3\nR&gt; [2,]    2    4\nR&gt; \nR&gt; , , 2, 1\nR&gt; \nR&gt;      [,1] [,2]\nR&gt; [1,]    5    7\nR&gt; [2,]    6    8\nR&gt; \nR&gt; , , 1, 2\nR&gt; \nR&gt;      [,1] [,2]\nR&gt; [1,]    9   11\nR&gt; [2,]   10   12\nR&gt; \nR&gt; , , 2, 2\nR&gt; \nR&gt;      [,1] [,2]\nR&gt; [1,]   13   15\nR&gt; [2,]   14   16\n\n\nVeja que o argumento dim indica a quantidade e o tamanho de cada dimensão na forma de um vetor. Assim como para a função matrix() , os elementos individuais também são preenchidos seguindo a ordem das dimensões.\n\n\n\nA resposta correta é a alternativa d) matrix(data=c(45,75,51,0.17), nrow=2, ncol=2).\nA forma mais usual de criação de matrizes no R se dá pelo uso da função matrix() . Porém, função array() também possibilita a criação de matrizes. A diferença é que matrix() é restrita a objetos com duas dimensões (matrizes e vetores), enquanto array() permite a criação de objects com qualquer número de dimensões, incluindo matrizes (2 dimensões), ou arrays com número k de dimensões.\nAssim, o nome da função, isoladamente, não permite resolver o problema, mas já indica o caminho. Sabendo que apenas funções matrix() e array() podem criar matrizes, já podemos excluir com segurança a alternativa c).\nO próximo passo é analisar as entradas utilizadas para as funções em cada alternativa. Saiba que ambas as funções compartilham o argumento data, porém apenas matrix() se utiliza das entradas nrow e ncol. Explicando com exemplos, podemos criar uma matriz com a função array() com o código abaixo:\n\n# criação de array com 2 dimensões\narray(data=c(45,75,51,0.17), dim = c(2, 2))\n\nR&gt;      [,1]  [,2]\nR&gt; [1,]   45 51.00\nR&gt; [2,]   75  0.17\n\n\no qual resulta em objeto equivalente a solução do problema:\n\n# criação de matriz com 2 dimensões\nmatrix(data=c(45, 75, 51, 0.17), nrow = 2, ncol = 2)\n\nR&gt;      [,1]  [,2]\nR&gt; [1,]   45 51.00\nR&gt; [2,]   75  0.17\n\n\n\n\n\n\n\n\nDica do Perlin\n\n\n\nNota-se um certo gosto dos avaliadores em questões relativas a criação de matrizes. Assim, memorize os argumentos das funções matrix() e array() , e lembre também que, na criação de uma matriz, a ordem dos elementos do objeto de saída segue a ordem das dimensões: primeiro preenche-se as linhas da primeira coluna, depois as linhas da segunda coluna e assim por diante.\nOutro ponto importante é que, para ambas as funções, pode ocorrer a reciclagem de elementos (veja ?sec-regra-reciclagem) caso o número de valores na entrada em data não sejam suficientes para preencher o objeto desejado. Em resumo, o R repete o vetor de entrada quantas vezes for necessário para preencher a matriz inteira. Veja o exemplo abaixo, onde argumento data é igual a c(1, 2), com nrow=2 e ncol=2. Claramente, o vetor de entrada não tem elementos suficientes para preencher os quatro elementos de uma matrix com duas linhas e duas colunas. Assim, seguindo a regra de reciclagem, o vetor c(1, 2) é repetido uma vez para preencher a matriz. Veja o resultado abaixo.\n\n# exemplo de reciclagem de valores em matrizes\nmatrix(c(1, 2), nrow = 2, ncol = 2)\n\nR&gt;      [,1] [,2]\nR&gt; [1,]    1    1\nR&gt; [2,]    2    2"
  },
  {
    "objectID": "03-operacoes-basicas.html#questão-05-mjsp-2020",
    "href": "03-operacoes-basicas.html#questão-05-mjsp-2020",
    "title": "1  Operações Básicas",
    "section": "1.5 Questão 05 [MJSP 2020]",
    "text": "1.5 Questão 05 [MJSP 2020]\n\n\n\n\n\n\n\nInformações\n\n\n\n\n\nAno\n2020\n\n\nÓrgão\nMinistério da Justiça e Segurança Pública\n\n\nCargo\nCientista Social\n\n\nNúmero na prova\n59\n\n\nTipo de questão\nCinco alternativas, uma resposta (a, b, c, d, e)\n\n\nResposta correta\nb\n\n\n\nA linguagem R é uma poderosa linguagem para se trabalhar com dados. Assinale a alternativa que apresenta somente funções da Linguagem R.\n\nAlternativas:\na ) input(), output(), floor(), avg().\nb ) mean(), summary(), quantile(), var().\nc ) sum(), avarage(), clean(), goto().\nd ) class(), vetor(), sum(), min().\ne ) for(), loop(), data(), math().\n\nSolução\nA resposta correta é alternativa b) mean(), summary(), quantile(), var().\nEsta é uma questão que exige certa memorização. O R possui um conjunto imenso de funções em seus módulos e, certamente, até mesmo usuários avançados teriam dificuldade em memorizar todos os nomes das funções disponíveis. Porém, com alguns atalhos, é possível chegar na resposta correta sem necessitar um esforço de memorização.\nPara começar, vamos olhar quais alternativas e funções realmente existem no R. Aquelas que não existem são sobrescritas abaixo:\n\ninput(), output(), floor(), avg().\nmean(), summary(), quantile(), var().\nsum(), avarage(), clean(), goto().\nclass(), vetor(), sum(), min().\nfor(), loop(), data(), math().\n\nPrimeiro, lembre que a função de calcular média no R é mean() . Esta tende a ser parte da primeira lição aprendida no R, e um conhecimento bastante acessível. Assim, os nomes avg() da alternativa (a) e avarage() (sim, tem erro de digitação) da alternativa (c) já poderiam ser excluídos.\nNa alternativa (c), veja que existe o nome vetor, o qual é a tradução de vector para o português. Como as funções do R estão todas escritas em inglês, claramente esta também não pode ser a resposta correta. Note, porém, que todos os demais nomes da alternativa (c): class(), sum(), min() são nomes válidos de funções no R.\nNa alternativa (e), note que o nome for() não é uma função, mas sim um nome reservado para iniciar um loop. E outra, loop é um conceito, e não função. Esta alternativa também pode ser excluída.\nAssim, com um pouco de lógica, podemos chegar na resposta ou, no mínimo, excluir algumas alternativas, sem a necessidade de decorar todas as funções do R.\n\n\n\n\n\n\nDica do Perlin\n\n\n\nInfelizmente, questões de memorização de nomes de funções no R são comuns em concursos públicos. Como professor, deixo aqui minha crítica a este tipo de questão “decoreba”, pois esta não medem o conhecimento de R de um candidato.\nPorém um atalho pode ajudar. Suspeito fortemente que funções exigidas em concursos devem se limitar aos pacotes básicos do R, aqueles que são inicializados com o software. Por exemplo, pacote {base} é carregado no início da sessão do R, permitindo o uso direto de suas funções, tal como mean().\nAssim, saiba que os pacotes automaticamente inicializados com o R são: {stats}, {graphics}, {grDevices}, {utils}, {datasets} e {base}. No mínimo, recomendo que o leitor se familiarize com as as principais funções do pacote {base} e {stats}."
  },
  {
    "objectID": "03-operacoes-basicas.html#questão-06-mjsp-2020",
    "href": "03-operacoes-basicas.html#questão-06-mjsp-2020",
    "title": "1  Operações Básicas",
    "section": "1.6 Questão 06 [MJSP 2020]",
    "text": "1.6 Questão 06 [MJSP 2020]\n\n\n\n\n\n\n\nInformações\n\n\n\n\n\nAno\n2020\n\n\nÓrgão\nMinistério da Justiça e Segurança Pública\n\n\nCargo\nCientista Social\n\n\nNúmero na prova\n60\n\n\nTipo de questão\nCinco alternativas, uma resposta (a, b, c, d, e)\n\n\nResposta correta\nd\n\n\n\nAssinale a alternativa que apresenta o comando que informa à Linguagem R em qual pasta ela deve ler os arquivos de dados.\n\nAlternativas:\na ) filter().\nb ) select().\nc ) read_fwf().\nd ) setwd().\ne ) library().\n\nSolução\n\n\n\n\n\n\nFunção setwd()\n\n\n\nEsta função modifica o diretório de trabalho em uma sessão do R. O seu nome é uma abreviatura da frase set working directory. A sua entrada é o diretório para onde a sessão do R deve se dirigir. Isto permite que arquivos de dados sejam importados com referência relativa. Por exemplo, imagine que existe um arquivo chamado dados.csv no diretório C:/Trabalho-R/. Para mudar o diretório e importar os dados na sua sessão, basta usar o código abaixo:\n\nsetwd(\"C:/Trabalho-R/\")\ndf &lt;- read.csv(\"dados.csv\")\n\n\n\n\nA resposta correta é alternativa d) setwd(), a qual muda o diretório de trabalho em uma sessão do R. Para esclarecer e explicar a negativa das demais funções, segue abaixo uma descrição simplificada de cada:\n\nfilter() \n\nOriginária do pacote {stats}, esta função aplica um filtro linear a uma (ou mais) séries temporais. Este é um método estatístico de modelagem de dados. A função também é encontrada no pacote {dplyr} e, neste caso, serve para filtrar as linhas de um dataframe (veja ?sec-pipeline).\n\nselect()\n\nEsta função não existe nos pacotes básicos do R, porém pode ser encontrada no {dplyr} . Neste caso, a função serve para selecionar colunas de um dataframe (tabela). O retorno da função é um outro dataframe com apenas as colunas selecionadas.\n\nread_fwf()\n\nEsta função também não existe nos pacotes básicos do R, porém pode ser encontrada no pacote {readr} . A mesma serve para importar dados de texto para sua sessão do R. O termo fwf significa fixed width file, arquivo de texto onde uma quantidade de espaços define a separação de colunas.\n\nlibrary() \n\nFunção para carregar pacotes em uma sessão do R. Por exemplo, para carregar todas as funções do pacote {readr} , basta executar o comando library(readr)."
  },
  {
    "objectID": "03-operacoes-basicas.html#sec-funcoes-e-escopo",
    "href": "03-operacoes-basicas.html#sec-funcoes-e-escopo",
    "title": "1  Operações Básicas",
    "section": "1.7 Questão 07 [DPF 2021]",
    "text": "1.7 Questão 07 [DPF 2021]\n\n\n\nInformações\n\n\n\n\n\nAno\n2021\n\n\nÓrgão\nDepartamento de Polícia Federal\n\n\nCargo\nAgente de Polícia Federal\n\n\nNúmero na prova\n85\n\n\nTipo de questão\nDuas alternativas, uma resposta (C, E)\n\n\nResposta correta\nE\n\n\n\nCom relação a conceitos de programação Python e R, julgue os itens que se seguem.\nO resultado do código R seguinte será “12”.\n\nf&lt;- function(x) {\n  g &lt;- function(y) {\n    y + z\n  }\n  z &lt;- 4\n  x + g(x)\n}\nz &lt;- 10\nf(4)\n\n\nAlternativas:\nC - Correto\nE - Errado\n\nSolução\n\n\n\n\n\n\nCuidado\n\n\n\nEsta questão apresenta um enunciado complicado, e pode ser entendida de diferentes formas. O problema é que, ao rodar o código R, a solução é o valor numérico 12, e não o texto “12”. Relembre que, no R, ao colocar aspas duplas ou simples em um objeto, o valor é do tipo caractere (veja Section 1.3), e não numérico. Assim, se levarmos a risca o enunciado, o gabarito está errado, pois o tipo de objeto de saída não bate com o valor encontrado pelo código. Porém, se ignorarmos o uso de aspas duplas, o gabarito está correto, pois a saída do código apresentado é exatamente o valor 12.\nPara manter a integridade e coerência do material do livro, o gabarito desta e de outras questões irá sempre levar a notação do R a risca. Assim, aceita-se a solução de que o enunciado está errado.\n\n\n\n\n\n\n\n\nFunções customizadas no R\n\n\n\nTodo usuário do R pode escrever suas próprias funções. Isto facilita a construção e manutenção de códigos. Conforme Perlin (2021), capítulo 8, abaixo seguem os principais pontos sobre a construção de funções customizadas no R:\n\nToda função possui três partes conexas: as entradas, o processamento e a saída. As entradas são os argumentos definidos na instanciação da função. Por exemplo, para a função fct &lt;- function(arg1, arg2), os nomes arg1 e arg2 são as entradas. O processamento ocorre no miolo da função, com o uso de chaves ({ }). Já a saída é definida com o comando return(). Este define o fim da execução da função, e o retorno de um objeto para o usuário.\n\n\n# exemplo de função customizada no R\nfct &lt;- function(arg1, arg2 = 5) { # entradas\n\n  # miolo da função (processamento)\n  print(arg1)\n  print(arg2)\n\n  out &lt;- arg1 + arg2\n\n  # saída da função e retorno para usuário\n  return(out)\n}\n\n\nO usuário pode definir as entradas de uma função tanto por posição quanto por nome. Veja que, na função anterior, a primeira entrada de fct() é arg1 e a segunda arg2. Assim, o comando fct(1, 2) é equivalente a fct(arg2=2, arg1=1).\nO uso de igualdade nas definições de entrada, tal qual f &lt;- function(x = 1), registra o valor padrão (ou default) para o argumento em questão. Quando o usuário não usa o argumento, ele toma o valor padrão. Assim, o comando fct(1) é equivalente a fct(1, 5), uma vez que o valor padrão de arg2 é 5.\nPara rodar uma função customizada no R, primeiro é necessário registrá-la na sessão, isto é, rodar o código de definição da função. Caso a função não for registrada, o R retornará um erro indicando que a função não foi encontrada.\n\n\n\n\n\n\n\n\n\nEscopo de objetos\n\n\n\nO escopo de objetos define a forma como a plataforma R procura objetos na execução de códigos. Este é um tema que pode ser complexo, mas vou simplificar aqui. Primeiro, saiba que todo código R é executado em determinado ambiente de trabalho, chamado de namespace. Este ambiente muda ao executarmos código dentro de funções e carregarmos pacotes. Quando definimos um objeto em código, o R procura o valor da variável seguindo uma ordem própria sobre as áreas de trabalho (namespace), funções e pacotes:\n\nPrimeiro, o R procura pela variável no ambiente da função em que o nome é requisitado, incluindo entre as entradas da função.\nCaso não encontrada, o objeto é buscado em quaisquer outras funções acima da função de requisição, seguindo a ordem de chamada do código.\nSe não encontrada, o R procura pela variável no ambiente global, sua área de trabalho original. O ambiente global nada mais é do que a sessão do R que você iniciou.\nPor fim, o R procura pelo objeto no ambiente (namespace) dos pacotes carregados na sua sessão.\n\nÉ usando as regras anteriores que o R encontra os nomes de objetos e funções. Isso é importante pois define quais objetos são utilizados em cálculos. Note que é devido a esta propriedade que uma função de determinado pacote se torna disponível após carregarmos o módulo com a função library() . Primeiro o R procura pelo nome da função em todos os ambientes de trabalho, e depois encontra no ambiente do pacote.\nA dinâmica do escopo de variáveis muda quando temos funções próprias no código. Saiba que cada função possui seu próprio ambiente de execução e, como foi destacado anteriormente, quando um objeto não é encontrado no ambiente de execução da função, o R procura sequencialmente nos demais ambientes, até chegar no ambiente global. Um exemplo vai elucidar. Considere o código a seguir:\n\n1x &lt;- \"esse é x do ambiente global\"\n\n2fct_1 &lt;- function() {\n  x &lt;- \"esse é x do ambiente da função\"   \n  print(x)\n}\n\n3fct_2 &lt;- function() {\n  print(x)\n}\n\nfct_1()\nfct_2()\n\n\n1\n\nVariável x é definida no ambiente global (fora da função)\n\n2\n\nFunção fct_1 define uma variável de mesmo nome, x, no ambiente da função, e mostra a mesma no prompt com função print() ;\n\n3\n\nFunção fct_2 não define uma variável x no ambiente da função, mas mostra o valor de x no prompt.\n\n\n\n\nR&gt; [1] \"esse é x do ambiente da função\"\nR&gt; [1] \"esse é x do ambiente global\"\n\n\nVeja que, na chamada para fct_1(), o resultado é o valor de x no ambiente da função. Quando chamamos fct_2(), a qual não define x em nenhum momento, o retorno é o valor de x no ambiente global.\nPara entender um pouco mais, veja o exemplo a seguir onde temos uma função definida dentro de outra função.\n\nx &lt;- \"esse é x do ambiente global\"\n\nfct_3 &lt;- function() {\n  x &lt;- \"esse é x do ambiente da função fct_3()\"\n\n  fct_2 &lt;- function() {\n    print(x)\n  }\n\n  fct_2()\n}\n\nfct_3()\n\nR&gt; [1] \"esse é x do ambiente da função fct_3()\"\n\n\nNeste caso, como fct_2() foi definida dentro de fct_3(), a procura pela variável passa antes pelo ambiente de execução da função fct_3(), antes de chegar no ambiente de execução global. Assim, o valor de x é aquele definido em fct_3().\n\n\n\nO enunciado está errado. O retorno do código é o valor numérico 12, e não o texto “12”. Esta questão envolve dois conceitos avançados no R: criação de funções customizadas e escopo de variáveis (veja definições acima).\nVoltando a questão, explica-se a resolução com o comentário em código:\n\nf&lt;- function(x) {\n  g &lt;- function(y) {      # \n    y + z                 \n  }\n2  z &lt;- 4\n3  x + g(x)\n}\nz &lt;- 10\n1f(4)\n\n\n1\n\nApós a chamada de f(4), a função g() é definida na linha 2.\n\n2\n\nDefine o valor de z &lt;- 4, o qual, seguindo a lógica do escopo de variáveis, é o valor de z criado no miolo da função f() e utilizado na função g(). Portanto, o resultado de g(x) é igual a 8.\n\n3\n\nConsequentemente, a soma x + g(x) da linha (4) é equivalente a 4 + 8, resultando no valor 12.\n\n\n\n\n\n\n\n\n\n\nDica do Perlin\n\n\n\nO tema de escopo de variáveis é muito propício de cair em concursos futuros. Me colocando no papel de autor de questões, veja que o enunciado da pergunta pode ser feito de forma enxuta, com complexidade flexível, e com gabarito inquestionável (é um simples código que pode ser rodado, dando sempre a mesma solução). Ao mesmo tempo, o assunto é complexo e pode filtrar candidatos bem preparados dos demais. Assim, aqui fica a recomendação de que entendas bem o conceito de escopo de variáveis no R, facilitando a resolução de potenciais futuras questões."
  },
  {
    "objectID": "03-operacoes-basicas.html#questão-08-agergs-2022",
    "href": "03-operacoes-basicas.html#questão-08-agergs-2022",
    "title": "1  Operações Básicas",
    "section": "1.8 Questão 08 [AGERGS 2022]",
    "text": "1.8 Questão 08 [AGERGS 2022]\n\n\n\n\n\n\n\nInformações\n\n\n\n\n\nAno\n2022\n\n\nÓrgão\nAg. Est. de Regulação dos Serv. Púb. Delegados do RS\n\n\nCargo\nEngenheiro de Processamento Digital\n\n\nNúmero na prova\n27\n\n\nTipo de questão\nCinco alternativas, uma resposta (a, b, c, d, e)\n\n\nResposta correta\nc\n\n\n\nEstamos interessados em ajustar um modelo de regressão linear simples no pacote estatístico R. O comando a ser utilizado para esse fim é:\n\nAlternativas:\na ) ts\nb ) glm\nc ) lm\nd ) cor\ne ) road\n\nSolução\n\n\n\n\n\n\nFunção lm()\n\n\n\nEsta estima uma regressão linear com base em dados, tendo como saída os coeficientes estimados, assim como também alguns testes estatístico. A regressão linear é um dos modelos estatísticos mais simples, assumindo uma relação linear entre as variáveis do modelo. Veja o exemplo abaixo, onde criamos uma tabela com dados artificiais, e estimamos um simples modelo.\n\n# cria um dataframe\ndados &lt;- data.frame(\n    x = c(1, 2, 5, 9, 5),\n    y = c(2, 6, 8, 3, 8)\n)\n\n# estima um modelo de regressão linear\nmy_lm &lt;- lm(formula = y ~x, data = dados)\n\n# mostra resultado\nprint(my_lm)\n\nR&gt; \nR&gt; Call:\nR&gt; lm(formula = y ~ x, data = dados)\nR&gt; \nR&gt; Coefficients:\nR&gt; (Intercept)            x  \nR&gt;     5.15306      0.05612\n\n\nPara obter mais informações sobre o modelo estimado, usamos a função summary() .\n\nsummary(my_lm)\n\nR&gt; \nR&gt; Call:\nR&gt; lm(formula = y ~ x, data = dados)\nR&gt; \nR&gt; Residuals:\nR&gt;       1       2       3       4       5 \nR&gt; -3.2092  0.7347  2.5663 -2.6582  2.5663 \nR&gt; \nR&gt; Coefficients:\nR&gt;             Estimate Std. Error t value Pr(&gt;|t|)\nR&gt; (Intercept)  5.15306    2.68100   1.922     0.15\nR&gt; x            0.05612    0.51406   0.109     0.92\nR&gt; \nR&gt; Residual standard error: 3.219 on 3 degrees of freedom\nR&gt; Multiple R-squared:  0.003957,   Adjusted R-squared:  -0.3281 \nR&gt; F-statistic: 0.01192 on 1 and 3 DF,  p-value: 0.92\n\n\n\n\n\nA solução é a alternativa c) lm, a qual estima uma regressão linear com base em dados (veja quadro acima). Para explicar a negativa das demais opções, abaixo apresenta-se uma explicação simplificada de cada um:\n\nts() \n\nserve para criar objetos representam séries temporais.\n\nglm() \n\nfunção utilizada para a estimação de modelos generalizados (Generalized Linear Models).\n\ncor() \n\nfunção utilizada para o cálculo de correlação entre duas séries numéricas.\n\nroad()\n\nesta função não existe nos pacotes tradicionais do R. A única menção encontrada é para a importação de dados de mortes relacionadas ao trânsito de estradas dos Estados Unidos (veja pacote {MASS} )."
  },
  {
    "objectID": "03-operacoes-basicas.html#questão-09-agergs-2022",
    "href": "03-operacoes-basicas.html#questão-09-agergs-2022",
    "title": "1  Operações Básicas",
    "section": "1.9 Questão 09 [AGERGS 2022]",
    "text": "1.9 Questão 09 [AGERGS 2022]\n\n\n\n\n\n\n\nInformações\n\n\n\n\n\nAno\n2022\n\n\nÓrgão\nAg. Est. de Regulação dos Serv. Púb. Delegados do RS\n\n\nCargo\nEngenheiro de Processamento Digital\n\n\nNúmero na prova\n28\n\n\nTipo de questão\nCinco alternativas, uma resposta (a, b, c, d, e)\n\n\nResposta correta\ne\n\n\n\nQuando usamos o símbolo “=” ou “&lt;” seguido de “-” estamos criando objetos com um nome que aparece à esquerda e que contém alguns elementos (o que vem à direita do símbolo). Quando criamos um objeto, ele fica guardado na memória do R até que se feche o programa. Porém, os objetos criados ficam ocultos. Para ver a lista de arquivos ocultos, basta dar o seguinte comando:\n\nAlternativas:\na ) tuple()\nb ) console()\nc ) rain()\nd ) table_rain()\ne ) ls()\n\nSolução\n\n\n\n\n\n\nFunção ls()\n\n\n\nEste comando, o qual é uma abreviatura da frase list objects, quando chamado sem argumentos, retorna um vetor com todos os objetos e funções disponíveis no ambiente de trabalho do R.\n\n# lista todos objetos da area de trabalho\nls()\n\n\n\n\nA solução é alternativa e) ls(). Para as demais funções, segue abaixo as explicações simplificadas.\n\ntuple()\n\nesta função não existe no R, porém é encontrada na linguagem de programação Python.\n\nconsole()\n\nesta função não existe nos módulos básicos do R.\n\nrain()\n\nesta função não existe nos módulos básicos do R.\n\ntable_rain()\n\nesta função não existe nos módulos básicos do R.\n\n\n\n\n\n\n\n\nDica do Perlin\n\n\n\nUm ponto importante, existe no R o conceito de objetos ocultos (hidden). O nome destes inicia com ., tal qual .Random.seed ou .x, e servem para guardar alguma informação que não é relevante para o usuário saber. Na prática, podemos definir uma variável iniciando o nome com um ponto, tal como em .x &lt;- 1. Este objeto será oculto, não aparecendo na chamada de ls() . Veja que estes detalhes formam um conhecimento específico muito interessante para ser requisitado em prova."
  },
  {
    "objectID": "03-operacoes-basicas.html#questão-10-agergs-2022",
    "href": "03-operacoes-basicas.html#questão-10-agergs-2022",
    "title": "1  Operações Básicas",
    "section": "1.10 Questão 10 [AGERGS 2022]",
    "text": "1.10 Questão 10 [AGERGS 2022]\n\n\n\n\n\n\n\nInformações\n\n\n\n\n\nAno\n2022\n\n\nÓrgão\nAg. Est. de Regulação dos Serv. Púb. Delegados do RS\n\n\nCargo\nEngenheiro de Processamento Digital\n\n\nNúmero na prova\n30\n\n\nTipo de questão\nCinco alternativas, uma resposta (a, b, c, d, e)\n\n\nResposta correta\nd\n\n\n\nSobre os comandos R, analise as assertivas abaixo e assinale a alternativa correta.\nI - license - detalha as condições de distribuição do R.\nII - contributors - lista a equipe do time-cerne de desenvolvimento.\nIII - Citation - ensina como citar o R em trabalhos acadêmicos.\nIV - Demo -inicia uma sessão interativa de demonstração do R.\n\nAlternativas:\na ) Todas estão corretas.\nb ) Todas estão incorretas.\nc ) Apenas I está correta.\nd ) Apenas I e II estão corretas.\ne ) Apenas III e IV estão corretas.\n\nSolução\n\n\n\n\n\n\nCuidado\n\n\n\nEsta questão possui uma solução inconsistente com a linguagem do R. O gabarito oficial marca a alternativa (a) – todas estão corretas – como solução. Porém, levando a letra o nome das funções do R, o correto seria alternativa (d) – somente I e II estão corretas. Nas afirmativas III e IV, as funções Citation() e Demo() deveriam ser citation() e demo(), sem a caixa alta na primeira letra.\nEsta é outra questão que deveria ter o gabarito modificado. Para não criar confusão, a solução do problema vai levar a letra da linguagem R, indicando um novo gabarito.\n\n\nAnalisando cada uma das afirmativas:\nI - Correta. A função license() existe e serve para mostrar na tela os detalhes da licença de distribuição do R.\nII - Correta. A função contributors() mostra na tela todos as pessoas que contribuíram para o desenvolvimento da plataforma.\nIV - Errada. A função citation() existe e mostra a forma de citação do R, porém sem a caixa alta da primeira letra.\nIII - Errada. A função demo() existe e inicia um processo de demonstração do R, porém sem a caixa alta da primeira letra."
  },
  {
    "objectID": "03-operacoes-basicas.html#sec-funcoes-recursivas",
    "href": "03-operacoes-basicas.html#sec-funcoes-recursivas",
    "title": "1  Operações Básicas",
    "section": "1.11 Questão 11 [ANP 2022]",
    "text": "1.11 Questão 11 [ANP 2022]\n\n\n\n\n\n\n\nInformações\n\n\n\n\n\nAno\n2022\n\n\nÓrgão\nAgência Nacional do Petróleo, Gás Natural e Biocombustíveis\n\n\nCargo\nNível Superior Especialista- Projetos Análise Econômica\n\n\nNúmero na prova\n104\n\n\nTipo de questão\nDuas alternativas, uma resposta (C, E)\n\n\nResposta correta\nC\n\n\n\nJulgue os itens a seguir, relativos a conceitos de R.\nA execução do seguinte código R retorna 10100 como resultado.\n\nfuncaoXX &lt;- function(n) {\n    if(n &gt; 1) {\n    funcaoXX(as.integer(n/2))\n    }\n\n    cat(n %% 2)\n}\nfuncaoXX(20)\n\n\nAlternativas:\nC - Correto\nE - Errado\n\nSolução\n\n\n\n\n\n\nConceitos Prévios\n\n\n\n\nFunções customizadas no R\n\nveja conceito na Section 1.7\n\n\n\n\n\n\n\n\n\n\nFunção cat()\n\n\n\nEsta é semelhante a print() e direciona um texto para o prompt ou arquivo.\n\n# define objeto de texto\nmy_text &lt;- \"abcd\"\n\n# mostra no prompt\ncat(my_text)\n\nR&gt; abcd\n\n# escreve em arquivo temporário\nmy_f &lt;- tempfile(fileext = 'txt')\ncat(my_text, file = my_f)\n\nSaiba que, diferente de print() , cat() também aceita operadores de quebra de linha (n) e tab (t)\n\n# quebra linha no meio\nmy_text &lt;- \"abncd\"\ncat(my_text)\n\nR&gt; abncd\n\n# usa espaço tab\nmy_text &lt;- \"abtcd\"\ncat(my_text)\n\nR&gt; abtcd\n\n\n\n\n\n\n\n\n\n\nOperador %%\n\n\n\nEste retorna o resto de uma divisão de integrais. Por exemplo, 10%%2 = 0, pois 10 dividido por 2 equivale a 5, sem resto de divisão. Já 10 %% 3 = 1, uma vez que o o fator de 3 mais próximo de 10 é 9, restando assim 1 para fechar a divisão.\n\n# exemplos de cálculo de resto\n10 %% 2\n\nR&gt; [1] 0\n\n10 %% 3\n\nR&gt; [1] 1\n\n\n\n\n\n\n\n\n\n\nFunções recursivas\n\n\n\nTalvez um dos temas mais difíceis em programação, e ótimo candidato para questões de concurso, as funções recursivas são aquelas em que a própria função chama a si mesmo em sua execução. No exercício em questão, veja na linha 3 que a função chama a si mesmo com o comando funcaoXX(as.integer(n/2)). Isso cria um efeito unusual e complexo, necessitando de certa atenção para entender a execução do código.\nUma das propriedades de toda função recursiva é a existência de uma condição de saída, isto é, a regra que faz com que a recursividade termine. Caso essa regra não exista, então a função executa a si mesmo para sempre, sem retorno para o usuário. Note que, no código da questão, a linha 3 somente é executada quando n &gt; 1. Portanto, a condição de saída da recursividade é n &lt;= 1, isto é, o lado oposto de n &gt; 1.\nNote também que as repetidas chamadas a funcaoXX() diminuem o valor da entrada com a fórmula as.integer(n/2). Isto é, a cada iteração, o valor da entrada é diminuído, até chegar na condição de saída. Assim, sequencialmente, as chamadas a função serão:\n\nfuncaoXX(20) –&gt; funcaoXX(10) –&gt; funcaoXX(5) –&gt; funcaoXX(2) –&gt; funcaoXX(1).\n\nA ordem de saída, porém, será inversa, começando com funcaoXX(1). Veja que funcaoXX(1) é a primeira execução a atingir a condição de término (n&lt;=1), assim a primeira a atingir o código de saída cat(n %% 2). Assim, a sua saída é o valor “1”.\nO segundo código a atingir saída é funcaoXX(2), resultando no valor “0” pois cat(2 %% 2) = 0. Sucessivamente, começando em funcaoXX(1) e terminando em funcaoXX(20), as funções apresentam suas saídas.\n\n\nA afirmativa do exercício está correta, com uma saída de código equivalente a 10100.\n\nfuncaoXX &lt;- function(n) {\n    if(n &gt; 1) {\n1    funcaoXX(as.integer(n/2))\n    }\n\n2    cat(n %% 2)\n}\nfuncaoXX(20)\n\n\n1\n\nesta é uma chamada recursiva da própria função, explicada em quadro acima.\n\n2\n\nfunção cat() é semelhante a print() e apresenta um texto no prompt. Operador %% retorna o resto de uma divisão de integrais (veja quadro acima)\n\n\n\n\nPara comprovar, abaixo executa-se o código mostrando a saída:\n\nfuncaoXX &lt;- function(n) {\n    if(n &gt; 1) {\n    funcaoXX(as.integer(n/2))   \n    }\n\n    cat(n %% 2)              \n}\nfuncaoXX(20)\n\nR&gt; 10100"
  },
  {
    "objectID": "03-operacoes-basicas.html#sec-funcao-sum-rep-seq",
    "href": "03-operacoes-basicas.html#sec-funcao-sum-rep-seq",
    "title": "1  Operações Básicas",
    "section": "1.12 Questão 12 [ANP 2022]",
    "text": "1.12 Questão 12 [ANP 2022]\n\n\n\n\n\n\n\nInformações\n\n\n\n\n\nAno\n2022\n\n\nÓrgão\nAgência Nacional do Petróleo, Gás Natural e Biocombustíveis\n\n\nCargo\nNível Superior Especialista- Projetos Análise Econômica\n\n\nNúmero na prova\n105\n\n\nTipo de questão\nDuas alternativas, uma resposta (C, E)\n\n\nResposta correta\nC\n\n\n\nJulgue os itens a seguir, relativos a conceitos de R.\nA execução do seguinte código R resulta em 1000.\n\nsum(rep(5,20))+sum(seq(0,200,25))\n\n\nAlternativas:\nC - Correto\nE - Errado\n\nSolução\n\n\n\n\n\n\nFunção rep()\n\n\n\nEsta repete um objeto determinado número de vezes. O primeiro argumento é o objeto em si, e o segundo é o número de vezes que desejamos repeti-lo. Ao executarmos o código rep(5,20), o resultado é um vetor com o número 5 repetido 20 vezes:\n\n# exemplo de rep()\nrep(5, 20)\n\nR&gt;  [1] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5\n\n\n\n\n\n\n\n\n\n\nFunção seq()\n\n\n\nCria uma sequência entre um valor inicial (primeiro argumento), valor final (segundo argumento) e o intervalo entre cada (terceiro argumento). Ao executarmos seq(0, 200, 25), o resultado é um vetor com início em 0, final em 200, com 25 de intervalo entre cada elemento.\n\n# exemplo de seq()\nseq(0,200,25)\n\nR&gt; [1]   0  25  50  75 100 125 150 175 200\n\n\n\n\n\n\n\n\n\n\nFunção sum()\n\n\n\nSoma todos os elementos de um vetor. Assim, ao chamarmos sum(1:5), estamos simplesmente somando todos os valores da sequência. O resultado é um valor único.\n\n# exemplo de sum()\nsum(1:5)\n\nR&gt; [1] 15\n\n\n\n\n\nA afirmativa da questão está correta.\nA solução do exercício envolve a definição de diversas funções. Para facilitar, vamos quebrar o problema em variáveis e comentar as etapas. Note que o código abaixo é equivalente ao do enunciado, porém com a criação das variáveis x e y.\n\n1x &lt;- rep(5,20)\n2y &lt;- seq(0,200,25)\n\n3sum(x)+sum(y)\n\n\n1\n\nFunção rep() repete um objeto determinado número de vezes.\n\n2\n\nFunção seq() cria uma sequência entre 0 e 200, com 25 de intervalo entre cada elemento.\n\n3\n\na função sum() soma todos os elementos de um vetor. Assim, ao chamarmos sum(x), estamos simplesmente somando o valor 5, vinte vezes, resultando em 100. Para sum(y), estamos somando a sequência [0, 25, 50, 75, 100, 125, 150, 175, 200], resultando no valor 900.\n\n\n\n\nR&gt; [1] 1000\n\n\nFinalizando, ao somarmos 100 com 900, o resultado é 1000 e, portanto, o enunciado está correto."
  },
  {
    "objectID": "03-operacoes-basicas.html#questão-13-anp-2022",
    "href": "03-operacoes-basicas.html#questão-13-anp-2022",
    "title": "1  Operações Básicas",
    "section": "1.13 Questão 13 [ANP 2022]",
    "text": "1.13 Questão 13 [ANP 2022]\n\n\n\n\n\n\n\nInformações\n\n\n\n\n\nAno\n2022\n\n\nÓrgão\nAgência Nacional do Petróleo, Gás Natural e Biocombustíveis\n\n\nCargo\nNível Superior Especialista- Projetos Análise Econômica\n\n\nNúmero na prova\n106\n\n\nTipo de questão\nDuas alternativas, uma resposta (C, E)\n\n\nResposta correta\nC\n\n\n\nConsidere-se o script R que se segue.\n\nX &lt;- c(0, 19, 205, 34, 506)\nY &lt;- X\nX[2] &lt;- 91\nY[6] &lt;- 71\nprint(X)\nprint(Y)\n\nO resultado da execução desse script é o apresentado a seguir.\n0 91 205 34 506\n0 19 205 34 506 71\n\nAlternativas:\nC - Correto\nE - Errado\n\nSolução\n\n\n\n\n\n\nConceitos Prévios\n\n\n\n\nUso de &lt;-, c() e print()\n\nveja conceitos na Section 1.1\n\n\n\n\n\nO enunciado do exercício está correto.\n\n# definição de vetores\n1X &lt;- c(0, 19, 205, 34, 506)\nY &lt;- X\n\n# mudança de elementos\n2X[2] &lt;- 91\nY[6] &lt;- 71\n\n# apresentação na tela\n3print(X)\nprint(Y)\n\n\n1\n\nFunção c() combina valores em um vetor chamado X. Veja que objeto Y é uma simples cópia do objeto X.\n\n2\n\nO operador de colchetes ([ ]) modifica os elementos dos vetores por posição. Neste caso, o código X[2] &lt;- 91 está modificando o segundo elemento de X para o valor 91. Já o código Y[6] &lt;- 71 substitui o sexto elemento de Y pelo valor de 71.\n\n3\n\nA última etapa é mostrar os vetores resultantes com a função print() .\n\n\n\n\nExecutando o código inteiro, vemos que a saída é como indicada no enunciado.\n\nX &lt;- c(0, 19, 205, 34, 506) \nY &lt;- X                      \n\nX[2] &lt;- 91                  \nY[6] &lt;- 71                  \n\nprint(X)                    \nprint(Y)"
  },
  {
    "objectID": "03-operacoes-basicas.html#questão-14-mpsc-2022",
    "href": "03-operacoes-basicas.html#questão-14-mpsc-2022",
    "title": "1  Operações Básicas",
    "section": "1.14 Questão 14 [MPSC 2022]",
    "text": "1.14 Questão 14 [MPSC 2022]\n\n\n\n\n\n\n\nInformações\n\n\n\n\n\nAno\n2022\n\n\nÓrgão\nMinistério Público de Santa Catarina\n\n\nCargo\nAnalista de banco de dados\n\n\nNúmero na prova\n73\n\n\nTipo de questão\nCinco alternativas, uma resposta (a, b, c, d, e)\n\n\nResposta correta\nb\n\n\n\nAnalise o código da linguagem de programação R a seguir.\n\nxpto &lt;- array(c(1:24), dim = c(4, 3, 2))\nprint (xpto[3, 2, 1])\n\nNa execução desse código, o print produz o valor:\n\nAlternativas:\na ) 5\nb ) 7\nc ) 10\nd ) 18\ne ) 19\n\nSolução\n\n\n\n\n\n\nConceitos Prévios\n\n\n\n\nFunção array() \n\nveja conceito na Section 1.4\n\nUso de &lt;-, c() e print()\n\nveja conceitos na Section 1.1\n\n\n\n\n\nA resposta correta é alternativa b) 7.\n\n1xpto &lt;- array(c(1:24), dim = c(4, 3, 2))\n2print (xpto[3, 2, 1])\n\n\n1\n\nObjeto xpto é definido com comando array() , tendo como entradas c(1:24) e dim = c(4, 3, 2). O operador : constrói uma sequência, entre um valor mínimo e outro máximo. A primeira entrada é o conteúdo do objeto, neste caso uma sequência entre 1 e 24. A segunda entrada indica as dimensões desejadas para o objeto de saída. No caso, o usuário está pedindo um objeto com 3 dimensões, onde a primeira dimensão tem tamanho 4, a segunda 3 e a terceira 2.\n\n2\n\nComando array() busca o elemento localizado em [3, 2, 1]. Neste caso, será a linha 3 da coluna 2, dimensão 1.\n\n\n\n\nPara explicar melhor o uso da função array() , veja o exemplo abaixo onde, primeiro, construímos um objeto mais simples, com 2 dimensões:\n\nprint(array(c(1:6), dim = c(3, 2)))\n\nR&gt;      [,1] [,2]\nR&gt; [1,]    1    4\nR&gt; [2,]    2    5\nR&gt; [3,]    3    6\n\n\nNote que a ordem de alocação dos vetores começa pelas linhas, e depois as colunas. Os primeiros três elementos de c(1:6) foram alocados para a primeira coluna, enquanto o quarto ao sexto elemento foram para a segunda coluna. Esta regra de alocação é importante pois define quais são os valores dos elementos do objeto resultante. Em outras palavras, a função array() vai preenchendo de acordo com as dimensões: primeiro as linhas, e depois as colunas. Esta regra segue também para as demais dimensões. Veja abaixo o resultado quando criamos um array de três dimensões:\n\nprint(array(c(1:12), dim = c(3, 2, 2)))\n\nR&gt; , , 1\nR&gt; \nR&gt;      [,1] [,2]\nR&gt; [1,]    1    4\nR&gt; [2,]    2    5\nR&gt; [3,]    3    6\nR&gt; \nR&gt; , , 2\nR&gt; \nR&gt;      [,1] [,2]\nR&gt; [1,]    7   10\nR&gt; [2,]    8   11\nR&gt; [3,]    9   12\n\n\nNote que, após preencher os seis elementos da primeira matriz, o código segue preenchendo os valores da segunda matriz.\nVoltando ao exercício, para descobrir qual o elemento da posição [3, 2, 1], basta ir preenchendo as linhas e colunas seguindo a ordem definida anteriormente. Primeiro preenchemos a primeira coluna da primeira dimensão de xpto com 1:4, e a segunda coluna com 5:8. Chegamos, assim, na solução: o valor na linha 3, coluna 2 da primeira matriz é 7. Abaixo executa-se o código para demonstrar os objetos criados e a solução.\n\nxpto &lt;- array(c(1:24), dim = c(4, 3, 2))\n\nprint(xpto)\n\nR&gt; , , 1\nR&gt; \nR&gt;      [,1] [,2] [,3]\nR&gt; [1,]    1    5    9\nR&gt; [2,]    2    6   10\nR&gt; [3,]    3    7   11\nR&gt; [4,]    4    8   12\nR&gt; \nR&gt; , , 2\nR&gt; \nR&gt;      [,1] [,2] [,3]\nR&gt; [1,]   13   17   21\nR&gt; [2,]   14   18   22\nR&gt; [3,]   15   19   23\nR&gt; [4,]   16   20   24\n\nprint(xpto[3, 2, 1])\n\nR&gt; [1] 7"
  },
  {
    "objectID": "03-operacoes-basicas.html#questão-15-mpsc-2022",
    "href": "03-operacoes-basicas.html#questão-15-mpsc-2022",
    "title": "1  Operações Básicas",
    "section": "1.15 Questão 15 [MPSC 2022]",
    "text": "1.15 Questão 15 [MPSC 2022]\n\n\n\n\n\n\n\nInformações\n\n\n\n\n\nAno\n2022\n\n\nÓrgão\nMinistério Público de Santa Catarina\n\n\nCargo\nAnalista de banco de dados\n\n\nNúmero na prova\n74\n\n\nTipo de questão\nCinco alternativas, uma resposta (a, b, c, d, e)\n\n\nResposta correta\nb\n\n\n\nNo contexto da linguagem de programação R, analise as afirmativas a seguir.\nI - Vetores (vectors) são listas de itens que devem ter o mesmo tipo.\nII - R trabalha com vários tipos de dados (data types), numéricos, lógicos e textuais, mas as variáveis podem mudar de tipo mesmo depois da instanciação.\nIII - Os itens de uma lista (list) não podem ser substituídos. São permitidas apenas a inserção e a remoção de itens.\nEstá correto somente o que se afirma em:\n\nAlternativas:\na ) I;\nb ) II;\nc ) III;\nd ) I e II;\ne ) II e III.\n\nSolução\n\n\n\n\n\n\nCuidado\n\n\n\nEsta questão possui uma solução incoerente com a linguagem R. O problema está na afirmativa I, a qual afirma que “Vetores (vectors) são listas de itens que devem ter o mesmo tipo”. No R, objetos do tipo vetor (vector) são diferentes de objetos do tipo lista (list). Assim, não é possível afirmar decisivamente que vetores são listas.\nPara evitar confusão, aqui iremos indicar um gabarito que segue a risca a linguagem R.\n\n\n\nA solução é alternativa b) II, apesar do gabarito oficial indicar alternativa d) I e II.\nExplicando melhor, a afirmativa I diz: “Vetores (vectors) são listas de itens que devem ter o mesmo tipo”. Errado. Veja bem, na linguagem R, vetores são diferentes de listas, com propriedades e usos diferentes. Por exemplo, em um vetor, todos elementos devem ser da mesma classe, enquanto uma lista é flexível quando ao tipo de objetos que a mesma comporta. O uso do termo “lista” é dúbio no enunciado, pois não fica claro se a referência é para listas do R, ou listas em geral.\nA afirmativa II diz: “R trabalha com vários tipos de dados (data types), numéricos, lógicos e textuais, mas as variáveis podem mudar de tipo mesmo depois da instanciação”. Correto. Sim, R tem uma grande flexibilidade ao lidar com diferentes tipos de dados. E sim, no R, é possível mudar o tipo de classe de uma variável após a sua criação/instanciação.\nAfirmativa III diz: “Os itens de uma lista (list) não podem ser substituídos. São permitidas apenas a inserção e a remoção de itens”. Errado. No R, os elementos de uma lista podem ser facilmente substituídos por outros."
  },
  {
    "objectID": "03-operacoes-basicas.html#questão-16-rfb-2022",
    "href": "03-operacoes-basicas.html#questão-16-rfb-2022",
    "title": "1  Operações Básicas",
    "section": "1.16 Questão 16 [RFB 2022]",
    "text": "1.16 Questão 16 [RFB 2022]\n\n\n\n\n\n\n\nInformações\n\n\n\n\n\nAno\n2022\n\n\nÓrgão\nReceita Federal do Brasil\n\n\nCargo\nAnalista Tributário da Receita Federal\n\n\nNúmero na prova\n64\n\n\nTipo de questão\nCinco alternativas, uma resposta (a, b, c, d, e)\n\n\nResposta correta\nd\n\n\n\nAnalise o código R a seguir.\n\nlista &lt;- function (param) {\n    if (param &gt; -3) {\n        temp &lt;- param + lista(param - 3)\n        print(temp)\n    } else {\n        return(0)\n    }\n}\nlista(15)\n\nAssinale os valores exibidos pela execução desse código, na ordem.\n\nAlternativas:\na ) 45, 30, 18, 9, 3, 0\nb ) 63, 45, 30, 18, 9, 3\nc ) 0, 0, 0, 0, 0, 0\nd ) 0, 3, 9, 18, 30, 45\ne ) 3, 9, 18, 30, 45, 63\n\nSolução\n\n\n\n\n\n\nConceitos Prévios\n\n\n\n\nUso de &lt;- e print()\n\nveja conceitos na Section 1.1\n\nFunções customizadas no R\n\nveja conceito na Section 1.7\n\nFunções recursivas\n\nveja conceito na Section 1.11\n\n\n\n\n\nA alternativa correta é d) 0, 3, 9, 18, 30, 45.\n\nlista &lt;- function (param) {\n1    if (param &gt; -3) {\n2        temp &lt;- param + lista(param - 3)\n        print(temp)\n    } else {\n        return(0)\n    }\n}\nlista(15)\n\n\n1\n\na primeira linha de código, execução da função lista(), define a condição de saída da função recursiva. Se param é maior do que 3, as linhas 3 e 4 são executadas, caso contrário o retorno é zero (linha 6).\n\n2\n\nChamada recursiva da própria função.\n\n\n\n\nConforme colocado em Section 1.11, o primeiro ponto a analisar em uma função recursiva é a condição de saída. Neste caso, a recursividade acaba quando param &lt;= -3, o contrário de param &gt;-3 (veja linha 2). Note também que, na chamada recursiva, a entrada é diminuída de 3 a cada execução. Assim, temos a seguinte ordem de chamada da função:\n\nlista(15) –&gt; lista(12) –&gt; … –&gt; lista(0) –&gt; lista(-3).\n\nA ordem de saída no prompt será inversa, começando com lista(-3) e terminando com lista(15). Assim, o resultado de lista(-3) é o valor 0, uma vez que a entrada param= -3 aciona a saída da função (veja linha 2 do código). Assim, quando o código chama lista(0), temos que a saída é temp &lt;- param + lista(param - 3), onde, substituindo os valores, encontramos temp &lt;- 0 + 0. O resultado da primeira chamada é 0. Isso já permitiria excluir todas alternativas senão c) e d).\nA segunda saída será a chamada quando param = 3, e a linha temp &lt;- param + lista(param - 3) é executada. Relembre agora que lista(0) = 0, portanto, com param=3, temos temp &lt;- 3 + 0, resultando no valor 3.\nPoderíamos continuar os cálculos, porém a resposta correta já está clara, alternativa d). Para comprovar, abaixo executamos o código do enunciado.\n\nlista &lt;- function (param) {\n    if (param &gt; -3) {\n        temp &lt;- param + lista(param - 3)\n        print(temp)\n    } else {\n        return(0)\n    }\n}\nlista(15)\n\nR&gt; [1] 0\nR&gt; [1] 3\nR&gt; [1] 9\nR&gt; [1] 18\nR&gt; [1] 30\nR&gt; [1] 45\n\n\n\n\n\n\n\nPerlin, M. S. 2021. Análise de Dados Financeiros e Econômicos Com o r. Terceira edição. publicação independente."
  },
  {
    "objectID": "04-loops.html",
    "href": "04-loops.html",
    "title": "2  Repetição estruturada de código (loops)",
    "section": "",
    "text": "Fim de conteúdo\n\n\n\nVocê chegou ao fim da versão ONLINE do livro Questões de R em Concursos Públicos. O conteúdo integral da obra pode ser adquirido na loja da Amazon como ebook, livro impresso (capa tradicional e capa dura). A compra do livro é uma ótima maneira de suportar este e outros projetos do autor."
  },
  {
    "objectID": "05-tabelas.html",
    "href": "05-tabelas.html",
    "title": "3  Operações com tabelas (dataframes e tibbles)",
    "section": "",
    "text": "Fim de conteúdo\n\n\n\nVocê chegou ao fim da versão ONLINE do livro Questões de R em Concursos Públicos. O conteúdo integral da obra pode ser adquirido na loja da Amazon como ebook, livro impresso (capa tradicional e capa dura). A compra do livro é uma ótima maneira de suportar este e outros projetos do autor."
  },
  {
    "objectID": "06-graficos.html",
    "href": "06-graficos.html",
    "title": "4  Gráficos",
    "section": "",
    "text": "Fim de conteúdo\n\n\n\nVocê chegou ao fim da versão ONLINE do livro Questões de R em Concursos Públicos. O conteúdo integral da obra pode ser adquirido na loja da Amazon como ebook, livro impresso (capa tradicional e capa dura). A compra do livro é uma ótima maneira de suportar este e outros projetos do autor."
  },
  {
    "objectID": "07-outros.html",
    "href": "07-outros.html",
    "title": "5  Outros temas",
    "section": "",
    "text": "Fim de conteúdo\n\n\n\nVocê chegou ao fim da versão ONLINE do livro Questões de R em Concursos Públicos. O conteúdo integral da obra pode ser adquirido na loja da Amazon como ebook, livro impresso (capa tradicional e capa dura). A compra do livro é uma ótima maneira de suportar este e outros projetos do autor."
  },
  {
    "objectID": "99-references.html",
    "href": "99-references.html",
    "title": "Referências Bibliográficas",
    "section": "",
    "text": "Allaire, JJ. 2022. Quarto: R Interface to Quarto Markdown Publishing\nSystem. https://github.com/quarto-dev/quarto-r.\n\n\nAllaire, JJ, Yihui Xie, Christophe Dervieux, Jonathan McPherson, Javier\nLuraschi, Kevin Ushey, Aron Atkins, et al. 2023. Rmarkdown: Dynamic\nDocuments for r. https://CRAN.R-project.org/package=rmarkdown.\n\n\nHester, Jim, and Jennifer Bryan. 2022. Glue: Interpreted String\nLiterals. https://CRAN.R-project.org/package=glue.\n\n\nHester, Jim, Hadley Wickham, and Gábor Csárdi. 2023. Fs:\nCross-Platform File System Operations Based on Libuv. https://CRAN.R-project.org/package=fs.\n\n\nIannone, Richard, Joe Cheng, Barret Schloerke, Ellis Hughes, Alexandra\nLauer, and JooYoung Seo. 2023. Gt: Easily Create Presentation-Ready\nDisplay Tables. https://CRAN.R-project.org/package=gt.\n\n\nMüller, Kirill, and Hadley Wickham. 2023. Tibble: Simple Data\nFrames. https://CRAN.R-project.org/package=tibble.\n\n\nPerlin, M. S. 2021. Análise de Dados Financeiros e Econômicos Com o\nr. Terceira edição. publicação independente.\n\n\nR Core Team. 2023b. R: A Language and Environment for Statistical\nComputing. Vienna, Austria: R Foundation for Statistical Computing.\nhttps://www.R-project.org/.\n\n\n———. 2023a. R: A Language and Environment for Statistical\nComputing. Vienna, Austria: R Foundation for Statistical Computing.\nhttps://www.R-project.org/.\n\n\nUshey, Kevin. 2023. Renv: Project Environments. https://rstudio.github.io/renv/.\n\n\nUshey, Kevin, JJ Allaire, and Yuan Tang. 2023. Reticulate: Interface\nto Python. https://CRAN.R-project.org/package=reticulate.\n\n\nWickham, Hadley. 2023a. Forcats: Tools for Working with Categorical\nVariables (Factors). https://CRAN.R-project.org/package=forcats.\n\n\n———. 2023b. Tidyverse: Easily Install and Load the Tidyverse.\nhttps://CRAN.R-project.org/package=tidyverse.\n\n\nWickham, Hadley, Winston Chang, Lionel Henry, Thomas Lin Pedersen,\nKohske Takahashi, Claus Wilke, Kara Woo, Hiroaki Yutani, and Dewey\nDunnington. 2023. Ggplot2: Create Elegant Data Visualisations Using\nthe Grammar of Graphics. https://CRAN.R-project.org/package=ggplot2.\n\n\nWickham, Hadley, Romain François, Lionel Henry, Kirill Müller, and Davis\nVaughan. 2023. Dplyr: A Grammar of Data Manipulation. https://CRAN.R-project.org/package=dplyr.\n\n\nWickham, Hadley, and Lionel Henry. 2023. Purrr: Functional\nProgramming Tools. https://CRAN.R-project.org/package=purrr.\n\n\nWickham, Hadley, Jim Hester, and Jennifer Bryan. 2023. Readr: Read\nRectangular Text Data. https://CRAN.R-project.org/package=readr.\n\n\nWickham, Hadley, Davis Vaughan, and Maximilian Girlich. 2023. Tidyr:\nTidy Messy Data. https://CRAN.R-project.org/package=tidyr.\n\n\nXie, Yihui. 2023. Knitr: A General-Purpose Package for Dynamic\nReport Generation in r. https://yihui.org/knitr/."
  }
]